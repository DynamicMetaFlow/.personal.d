#+TITLE: Personal Configuration
#+PROPERTY: header-args :results silent

* Modules
** EXWM Window Manager
*** setup
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-exwm.el
(use-package exwm
  :if (string= (getenv "EXWM_ENABLE") "t")
  :config
  (require 'exwm)
  (require 'exwm-randr)
                                        ;      (require 'exwm-systemtray)

  (setq display-time-mode t)
  (setq display-battery-mode nil)

  (setq fringe-mode '(7 . 1))

  (setq use-dialog-box nil)
  (setq exwm-workspace-show-all-buffers t)
  (setq exwm-layout-show-all-buffers t)

  (setq exwm-workspace-number 8)

  (defun exwm-workspace-number-to-string (number)
    (number-to-string (1- number)))

  (setq exwm-workspace-index-map #'exwm-workspace-number-to-string)

  (dotimes (i 8)
    (exwm-input-set-key (kbd (format "s-%d" i))
                        `(lambda ()
                           (interactive)
                           (exwm-workspace-switch-create (1- ,i)))))

  (ido-mode 0)

  (setq display-time-default-load-average nil)

  (setq window-divider-default-bottom-width 2
        window-divider-default-right-width 2)

  (setq exwm-manage-configurations '((t char-mode t)))

  (defvar exwm-toggle-workspace 0
    "Previously selected workspace. Used with `exwm-jump-to-last-exwm'.")

  (defun exwm-jump-to-last-exwm ()
    (interactive)
    (exwm-workspace-switch exwm-toggle-workspace))

  (defadvice exwm-workspace-switch (before save-toggle-workspace activate)
    (setq exwm-toggle-workspace exwm-workspace-current-index))

  (defun my/exwm-rename-buffer-to-title () (exwm-workspace-rename-buffer exwm-title))

  (add-hook 'exwm-update-title-hook 'my/exwm-rename-buffer-to-title)

  (add-hook 'exwm-floating-setup-hook 'exwm-layout-hide-mode-line)
  (add-hook 'exwm-floating-exit-hook 'exwm-layout-show-mode-line)

  (defun my-exwm-workspace-display-current ()
    "Display current workspace index."
    (interactive)
    (let ((message-log-max))
      (message (elt exwm-workspace--switch-history
                    exwm-workspace-current-index))))

  (defvar exwm-workspace-switch-wrap t
    "Whether `exwm-workspace-next' and `exwm-workspace-prev' should wrap.")

  (defun exwm-workspace-next ()
    "Switch to next exwm-workspaceective (to the right)."
    (interactive)
    (let* ((only-workspace? (equal exwm-workspace-number 1))
           (overflow? (= exwm-workspace-current-index
                         (1- exwm-workspace-number))))
      (cond
       (only-workspace? nil)
       (overflow?
        (when exwm-workspace-switch-wrap
          (exwm-workspace-switch 0)))
       (t (exwm-workspace-switch  (1+ exwm-workspace-current-index))))))

  (defun gpastel-exwm-counsel-yank-pop ()
    "Same as `counsel-yank-pop' and paste into exwm buffer."
    (interactive)
    (let ((inhibit-read-only t)
          ;; Make sure we send selected yank-pop candidate to
          ;; clipboard:
          (yank-pop-change-selection t))
      (call-interactively #'counsel-yank-pop))
    (when (derived-mode-p 'exwm-mode)
      ;; https://github.com/ch11ng/exwm/issues/413#issuecomment-386858496
      (exwm-input--set-focus (exwm--buffer->id (window-buffer (selected-window))))
      ;; (exwm-input--fake-key ?\C-v)
      ))

  (exwm-input-set-key (kbd "M-y")
                      #'gpastel-exwm-counsel-yank-pop)


  (defun exwm-counsel-yank-pop ()
    "Same as `counsel-yank-pop' and paste into exwm buffer."
    (interactive)
    (let ((inhibit-read-only t)
          ;; Make sure we send selected yank-pop candidate to
          ;; clipboard:
          (yank-pop-change-selection t))
      (call-interactively #'counsel-yank-pop))
    (when (derived-mode-p 'exwm-mode)
      (exwm-input--set-focus (exwm--buffer->id (window-buffer (selected-window))))
      (exwm-input--fake-key ?\C-v)))


  (defun exwm-workspace-prev ()
    "Switch to next exwm-workspaceective (to the right)."
    (interactive)
    (let* ((only-workspace? (equal exwm-workspace-number 1))
           (overflow? (= exwm-workspace-current-index 0)))
      (cond
       (only-workspace? nil)
       (overflow?
        (when exwm-workspace-switch-wrap
          (exwm-workspace-switch (1- exwm-workspace-number))))
       (t (exwm-workspace-switch  (1- exwm-workspace-current-index))))))

  (defun mf/get-auto-xrandr-line (display)
    "Returns the parameter for xrandr to automatically configure the display."
    (concat "--output " display " --auto"))

  (defun mf/generate-xrandr-params ()
    "Generate the parameters for xrandr."
    (let ((xrandrfile "~/.xrandrrc"))
      (if (not (file-exists-p xrandrfile))
          (apply 'concat (mapcar 'mf/get-auto-xrandr-line (mf/get-monitor-list)))
        (with-temp-puffer
         (insert-file-contents xrandrfile)
         (buffer-to-string)))))

  (defun app/configure-displays ()
    "Configure the attached displays"
    (interactive)
    (let ((xrandr-params (mf/generate-xrandr-params)))
      (start-process-shell-command "xrandr" nil (concat "xrandr " xrandr-params))))


  ;; Quick swtiching between workspaces
  (defvar exwm-toggle-workspace 0
    "Previously selected workspace. Used with `exwm-jump-to-last-exwm'.")
  (defun exwm-jump-to-last-exwm ()
    (interactive)
    (exwm-workspace-switch exwm-toggle-workspace))

  (defadvice exwm-workspace-switch (before save-toggle-workspace activate)
    (setq exwm-toggle-workspace exwm-workspace-current-index))

  (defun mf/make-workspace-list (monitors workspaces)
    "Return a list for exwm to use for workspace assignment."
    (let ((result '()))
      (dotimes (count (* (length monitors) workspaces) result)
        (setq result (append result
                             (list (+ count 1)
                                   (nth (if (evenp count) count (- count 1))
                                        monitors)))))))
  (defun mf/get-monitor-list ()
    "Get a list of connected displays."
    (let ((xrandr (split-string (shell-command-to-string "xrandr") "\n" ))
          (result '()))
      (dotimes (counter (length xrandr) result)
        (let ((monitor (mf/monitor-from-line (nth counter xrandr))))
          (when monitor
            (setq result (append result (list monitor))))))))

  (setq exwm-workspaces-per-monitor 4)

  (defun mf/monitor-from-line (line)
    "Look at a line and return the monitor if it is a matching xrandr line."
    (save-match-data
      (and (string-match " connected" line)
           (string-match "^[a-zA-Z]+-[0-9]+" line)
           (match-string 0 line ))))


  (defun my-exwm-workspaces ()
    "Calculates the number of workspaes and assigns them to monitors."
    (interactive)

    (require 'exwm-randr)
    (setq exwm-randr-workspace-output-plist
          (mf/make-workspace-list (mf/get-monitor-list) exwm-workspaces-per-monitor))
    (add-hook 'exwm-randr-screen-change-hook 'app/configure-displays)


    (dotimes (value (* exwm-workspaces-per-monitor (length (mf/get-monitor-list))))
      (let ((i (+ 1 value)))
        (exwm-input-set-key
         (kbd (format "s-%d" i))
         `(lambda () (interactive)
            (exwm-workspace-switch-create ,i)))))
    (exwm-randr-enable))


  (defun my-exwm-define-key-chords ()
    "Define local key chords for Exwm buffer."
    (map-keymap
     (lambda (event-type key-chord-map)
       (when (eq event-type 'key-chord)
         (map-keymap
          (lambda (key _)
            (define-key exwm-mode-map (string key)
              (lambda ()
                (interactive)
                (exwm-input--fake-key key))))
          key-chord-map)))
     (current-global-map)))

  (defun my/trim-non-chrome ()
    (delete-if-not (apply-partially 'string-match "- Google Chrome$")
                   ido-temp-list))

  (add-hook 'exwm-manage-finish-hook
            (defun my/exwm-manage-hook ()
              (when (string-match "Google-chrome" exwm-class-name)
                                        ;                (exwm-workspace-move-window 0)
                                        ;                (exwm-layout-hide-mode-line)
                (setq ido-make-buffer-list-hook 'my/trim-non-chrome))))

  (add-hook 'exwm-update-title-hook
            (defun my/exwm-title-hook ()
              (when (string-match "Google-chrome" exwm-class-name)
                (exwm-workspace-rename-buffer exwm-title))))

  (setq browse-url-chrome-arguments '("--new-window"))

  (add-hook 'exwm-workspace-switch-hook #'my-exwm-workspace-display-current)
  (advice-add 'exwm-workspace-add :after #'my-exwm-workspace-display-current)
  (advice-add 'exwm-workspace-delete :after #'my-exwm-workspace-display-current)


  (window-divider-mode)

  (defun ivy-ignore-exwm-buffers (str)
    (let ((buf (get-buffer str)))
      (when buf
        (with-current-buffer buf
          (or
           (file-remote-p (or (buffer-file-name) default-directory))
           (eq major-mode 'exwm-mode))))))

  (defun ivy-ignore-non-exwm-buffers (str)
    (let ((buf (get-buffer str)))
      (if buf
          (with-current-buffer buf
            (or
             (file-remote-p (or (buffer-file-name) default-directory))
             (not (eq major-mode 'exwm-mode))))
        t)))

  (defun ivy-switch-buffer-exwm ()
    "Like ivy-switch-buffer but only shows EXWM buffers."
    (interactive)
    (let ((ivy-ignore-buffers (append ivy-ignore-buffers '(ivy-ignore-non-exwm-buffers))))
      (ivy-switch-buffer)))

  (defun ivy-switch-buffer-non-exwm ()
    "Like ivy-switch-buffer but hides all EXWM buffers."
    (interactive)
    (let ((ivy-ignore-buffers (append ivy-ignore-buffers '(ivy-ignore-exwm-buffers))))
      (ivy-switch-buffer)))
    #+END_SRC

    #+results:
    : t

*** keybindings
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-exwm.el
(setq exwm-input-line-mode-passthrough t)

(defun exwm-input-line-mode ()
  "Set exwm window to line-mode and show mode line"
  (call-interactively #'exwm-input-grab-keyboard)
  (exwm-layout-show-mode-line))

(defun exwm-input-char-mode ()
  "Set exwm window to char-mode and hide mode line"
  (call-interactively #'exwm-input-release-keyboard)
  (exwm-layout-hide-mode-line))

(defun exwm-input-toggle-mode ()
  "Toggle between line- and char-mode"
  (with-current-buffer (window-buffer)
    (when (eq major-mode 'exwm-mode)
      (if (equal (second (second mode-line-process)) "line")
          (exwm-input-char-mode)
        (exwm-input-line-mode)))))

(defun exwm-input-set-global-key (key function)
  "Add KEY to `exwm-input-prefix-keys' and bind FUNCTION to KEY
          in exwm keymap"
  (cl-pushnew (elt key 0) exwm-input-prefix-keys)
  (exwm-input-set-key key function))

(defun my/switch-to-last-buffer ()
  "Switch to last open buffer in current window."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))

(define-key minibuffer-inactive-mode-map [mouse-1] #'ignore)

(push ?\s-  exwm-input-prefix-keys)

(defvar exwm-input-prefix-keys-extra nil)


(setq exwm-input-simulation-keys
      '(
        ;; movement
        ([?\C-b] . [left])
        ([?\C-f] . [right])
        ([?\C-p] . [up])
        ([?\C-n] . [down])
        ([?\C-a] . [home])
        ([?\C-e] . [end])
        ([?\M-v] . [prior])
        ([?\C-v] . [next])
        ([?\C-d] . [delete])
        ([?\C-k] . [S-end delete])

        ;; cut/paste
        ([?\C-w] . [?\C-x])
        ([?\M-w] . [?\C-c])
        ([?\C-y] . [?\C-v])
        ;; search
        ([?\C-s] . [?\C-f])))

(defun my-exwm-keybindings ()
  "Add the key bindings for exwm."
  (exwm-input-set-key (kbd "<print>") #'desktop-environment-screenshot)

  ;; (exwm-input-set-key (kbd "C-SPC")
  ;;                     (lambda ()
  ;;                       (interactive)
  ;;                       (exwm-input-line-mode)
  ;;                       (hydra-master/body)))

  (exwm-input-set-key (kbd "C-SPC")
                      (lambda ()
                        (interactive)
                        (exwm-input-line-mode)
                        (modalka-mode-hydra)))

  (exwm-input-set-key (kbd "C-4")
                      (lambda ()
                        (interactive)
                        (exwm-input-line-mode)
                        (my/org-capture-appt)))
  (exwm-input-set-key (kbd "C-1")
                      (lambda ()
                        (interactive)
                        (exwm-input-line-mode)
                        (my/org-capture-task)))

  (exwm-input-set-key (kbd "C-2")
                      (lambda ()
                        (interactive)
                        (exwm-input-line-mode)
                        (my/org-capture-journal)))


  (exwm-input-set-key (kbd "C-3")
                      (lambda ()
                        (interactive)
                        (exwm-input-line-mode)
                        (my/org-capture-note)))


  (exwm-input-set-key (kbd "s-p")   'my/switch-to-last-buffer)
  (exwm-input-set-key (kbd "s-SPC") 'exwm-jump-to-last-exwm)
  (exwm-input-set-key (kbd "s-<tab>") 'ivy-switch-buffer-exwm)


  (exwm-input-set-key (kbd "s-f")   'toggle-single-window)

  (exwm-input-set-key (kbd "s-,")   'winner-undo)
  (exwm-input-set-key (kbd "s-.")   'winner-redo)

  (exwm-input-set-key (kbd "s-r") 'exwm-reset)
  (exwm-input-set-key (kbd "s-w") 'exwm-workspace-switch)

  (exwm-input-set-key (kbd "s-l") 'windmove-right)
  (exwm-input-set-key (kbd "s-k") 'windmove-left)
  (exwm-input-set-key (kbd "s-i") 'windmove-up)
  (exwm-input-set-key (kbd "s-o") 'windmove-down)


  (exwm-input-set-key (kbd "s-L") 'buf-move-right)
  (exwm-input-set-key (kbd "s-K") 'buf-move-left)
  (exwm-input-set-key (kbd "s-I") 'buf-move-up)
  (exwm-input-set-key (kbd "s-O") 'buf-move-down)

  (exwm-input-set-key (kbd "s-x") 'exwm-input-toggle-keyboard))


    #+END_SRC

*** ibuffer
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-exwm.el
(setq ibuffer-saved-filter-groups
      (quote (("default"
               ("EXWM" (mode . exwm-mode))))))
                                        ;       ("org-mode" (mode . org-mode))
                                        ;       ("git" (mode . magit-status-mode))
                                        ;       ("dired" (mode . dired-mode))
                                        ;       ("emacs" (or
                                        ;                (name . "^\\*scratch\\*$")
                                        ;                (name . "^\\*Messages\\*$")
                                        ;                (name . "^\\*Bookmark List\\*$")
                                        ;                (name . "^\\*GNU Emacs\\*$")))))))

(add-hook 'ibuffer-mode-hook
          (lambda ()
            (ibuffer-switch-to-saved-filter-groups "default")))


(define-ibuffer-column size-h
  (:name "Size")
  (cond
   ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
   ((> (buffer-size) 100000) (format "%7.0fk" (/ (buffer-size) 1000.0)))
   ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
   (t (format "%8d" (buffer-size)))))

(define-ibuffer-column exwm-class
  (:name "Class")
  (cond
   (exwm-class-name (format "%s" exwm-class-name))
   (t (format "%s" ""))))

;; Needs work to look good, major-mode is not equal to ibuffer-formats mode
(define-ibuffer-column exwm-mode
  (:name "EXWM-Mode")
  (cond
   ((string-equal major-mode "exwm-mode") (format "%s" exwm-class-name))
   (t (format "%s" mode-name))))

(setq ibuffer-formats
      '((mark modified read-only locked " "
              (name 50 50 :left :elide)
              " "
              (size-h 16 16 :right)
              " "
              (exwm-mode 18 18 :left :elide)
              " " filename-and-process)
        (mark modified read-only locked " "
              (name 50 50 :left :elide)
              " "
              (size-h 16 16 :right)
              " "
              (mode 18 18 :left :elide)
              (exwm-class 18 18 :left :elide)
              " " filename-and-process)
        (mark " "
              (name 16 -1)
              " " filename)))

(defun my-counsel-ibuffer-by-exwm-class-name ()
  "`counsel-ibuffer' limited to Exwm buffers of same X class."
  (interactive)
  (require 'ibuffer)
  (cl-letf*
      ((class-name exwm-class-name)
       (get-buffers-function
        (symbol-function 'counsel-ibuffer--get-buffers))
       ((symbol-function 'counsel-ibuffer--get-buffers)
        (lambda ()
          (--filter (with-current-buffer (cdr it)
                      (and (eq major-mode 'exwm-mode)
                           (string-equal exwm-class-name class-name)))
                    (funcall get-buffers-function)))))
    (counsel-ibuffer)))

    #+END_SRC
*** randr
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-exwm.el
(defvar exwm-connected-displays 3
  "Number of connected displays.")

;; Update exwm-randr-workspace-output-plist with 2 or 3 outputs named
;; 'primary' and 'other-1'/'other-2'.
;; With 3 outputs connected the first workspace will be primary,
;; second workspace goes to 'other-2' and all others to 'other-1'.
;; With 2 outputs, first workspace is 'primary' display and rest 'other-1'.
;; And with only one connected output, primary has all workspaces.
(defun my/exwm-randr-screen-change ()
  (let* ((connected-cmd "xrandr -q|awk '/ connected/ {print $1}'")
         (connected (process-lines "bash" "-lc" connected-cmd))
         (primary (car connected))  ; Primary display is always first in list
         (other-1 (cadr connected))
         (other-2 (caddr connected)))
    (setq exwm-connected-displays (length connected))
    (setq exwm-randr-workspace-monitor-plist
          (append (list 0 primary)
                  (list 1 (or other-2 other-1 primary))
                  (mapcan (lambda (i) (list i (or other-1 other-2 primary)))
                          (number-sequence 2 exwm-workspace-number))))
    (exwm-randr-refresh)
    (message "Randr: %s monitors refreshed." (string-join connected ", "))))

(add-hook 'exwm-randr-screen-change-hook #'my/exwm-randr-screen-change)


    #+END_SRC

*** autostart
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-exwm.el
(defun app/autostart (application)
  "Add an application to autostart."
  (add-hook 'exwm-init-hook
            `(lambda ()
               (start-process-shell-command "autostart-process" nil ,application))))

(defun my-exwm-autostart ()
  "Add applications that will be loaded after exwm init is done."
  (mapcar (lambda (program) (app/autostart program)) exwm-autostart))


(setq exwm-autostart
      (list
                                        ;         "thinkpad-dock off"
                                        ;         "compton -b"
                                        ;         "thinkpad-touchpad off"
                                        ;         "/usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1"
                                        ;         "/usr/lib/gpaste/gpaste-daemon"
                                        ;         "pamac-tray"
                                        ;         "redshift-gtk"
                                        ;         "kdeconnect-indicator"
                                        ;         "autorandr --change"
                                        ;         "thinkpad-dock on"
       ))


(add-hook 'after-init-hook
          (lambda ()
            (exwm-randr-enable)
                                        ;              (exwm-systemtray-enable)
            (exwm-input--update-global-prefix-keys)
            (my-exwm-keybindings)
                                        ;             (my-exwm-autostart)
                                        ;              (my-exwm-workspaces)
            (exwm-enable)
            t)))
    #+END_SRC

** hydra
*** common
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-common  (:color blue
                                :hint nil)
  ("RET"   counsel-linux-app nil)
  ("SPC"   counsel-M-x nil)

  ("Q" kill-this-buffer nil)

  ("<tab>" ivy-switch-buffer-non-exwm)
  ("s-<tab>"  ivy-switch-buffer-exwm)

  ("@"   org-capture nil)
  ("W"   hydra-window/body nil)

  ("0" delete-window-balance)
  ("1" delete-other-windows)
  ("2" split-window-below)
  ("3" split-window-right)

  (";" ace-swap-window)
  ("#" hycontrol-windows-grid))
    #+END_SRC
*** master
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-master (
                        :color blue
                        :column 1
                        :inherit (hydra-common/heads))
  "Master"
  ("a" hydra-applications/body "apps")
  ("b" hydra-bookmarks/body "bookmarks")
  ("c" quick-calc "calc")
  ("e" hydra-emacs/body "emacs")
  ("f" hydra-file/body "file")
  ("l" hydra-spell/body "spell")
  ("m" boon-mode-hydra "major")
  ("M" hydra-minor/body nil)
  ("p" hydra-projects/body "projects")
  ("s" hydra-search/body "search")
  ("t" hydra-terminal/body "term")
  ("x" hydra-text/body "text"))
    #+END_SRC
*** hydra-emacs
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-emacs (:color blue :hint nil :inherit (hydra-common/heads))

  "
                                                                         ╭───────┐
     Execute       Packages         Help                     Misc        │ Emacs │
  ╭──────────────────────────────────────────────────────────────────────┴───────╯
    [_x_] counsel M-x [_p_] list      [_f_] describe function [_t_] change theme
    [_e_] exit        [_i_] install   [_v_] describe variable [_l_] list emacs process
    [_s_] system      [_u_] upgrade   [_m_] info manual       [_c_] init time
     ^ ^               ^ ^            [_k_] bindings          [_o_] unbound commands
     ^ ^               ^ ^            [_b_] personal bindings [_y_] emacs colors
     ^ ^               ^ ^             ^ ^                    [_z_] list faces
     ^ ^               ^ ^             ^ ^
  --------------------------------------------------------------------------------
        "
  ("C-h b" counsel-descbinds "bindings")
  ("f" counsel-describe-function)
  ("v" counsel-describe-variable)
  ("b" describe-personal-keybindings)
  ("c" emacs-init-time)
  ("i" package-install)
  ("k" counsel-descbinds)
  ("l" list-processes)
  ("m" info-display-manual)
  ("p" paradox-list-packages)
  ("t" counsel-load-theme)
  ("u" paradox-upgrade-packages)
  ("o" smex-show-unbound-commands)
  ("y" counsel-colors-emacs)
  ("z" counsel-faces)
  ("x" counsel-M-x)
  ("e" save-buffers-kill-emacs)
  ("s" hydra-system/body nil)
  )
    #+END_SRC

*** hydra-terminal
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-terminal (:color blue :hint nil :inherit (hydra-common/heads))

  "
                                                                        ╭──────────┐
     Terminals                     System                               │ Terminal │
  ╭─────────────────────────────────────────────────────────────────────┴──────────╯
    [_s_] new multi-term           [_c_] shell command
    [_n_] next multi-term          [_a_] aync shell command
    [_p_] previous multi-term      [_m_] man page
    [_d_] dedicated multi-term     [_l_] list system process
    [_e_] eshell
  --------------------------------------------------------------------------------
        "
  ("a" async-shell-command)
  ("c" shell-command)
  ("e" eshell)
  ("m" man)
  ("l" proced)
  ("s" multi-term)
  ("n" multi-term-next)
  ("p" multi-term-previous)
  ("d" multi-term-dedicated-toggle))

    #+END_SRC

*** hydra-file
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-file (:color blue :hint nil :inherit (hydra-common/heads))

  "
                                                                          ╭──────┐
       Ivy                    Dired            Hydras                     │ File │
  ╭───────────────────────────────────────────────────────────────────────┴──────╯
    [_f_] open file            [_d_] dired     [_ht_] text
    [_e_] open file extern                   [_hs_] spell
    [_r_] open recentf

  --------------------------------------------------------------------------------
        "
  ("f" counsel-find-file)
  ("e" counsel-find-file-extern)
  ("r" counsel-recentf "recent")
  ("d" dired-jump)
  ("hs" hydra-spell/body nil  :color blue)
  ("ht" hydra-text/body nil   :color blue)
  )
    #+END_SRC
*** hydra-narrow
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-narrow (:color blue :hint nil :inherit (hydra-common/heads))

  "
                                                                        ╭────────┐
      Narrow                                                            │ Narrow │
  ╭─────────────────────────────────────────────────────────────────────┴────────╯
    [_f_] narrow to defun
    [_p_] narrow to page
    [_s_] narrow to subtree
    [_r_] narrow to region

    [_w_] widen
  --------------------------------------------------------------------------------
        "
  ("f" narrow-to-defun)
  ("p" narrow-to-page)
  ("s" org-narrow-to-subtree)
  ("c" org-narrow-to-block)
  ("r" narrow-to-region)
  ("w" widen))
    #+END_SRC
*** hydra-spell
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-spell (:color blue :hint nil :inherit (hydra-common/heads))

  "
                                                                         ╭───────┐
      Flyspell               Ispell                      Gtranslate      │ Spell │
  ╭──────────────────────────────────────────────────────────────────────┴───────╯
    [_k_] correct word       [_w_] check word            [_g_] en ⇆ es
    [_n_] next error                                   [_G_] any lang
    [_f_] toggle flyspell
    [_p_] toggle prog mode
  --------------------------------------------------------------------------------
        "
  ("w" ispell-word)
  ("d" ispell-change-dictionary)
  ("g" google-translate-smooth-translate)
  ("G" google-translate-query-translate)
  ("f" flyspell-mode)
  ("p" flyspell-prog-mode)
  ("k" flyspell-correct-word-generic)
  ("n" flyspell-goto-next-error))
    #+END_SRC

*** hydra-text
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-text (:color blue :hint nil :inherit (hydra-common/heads))


  "
                                                                               ╭──────┐
        Size  Toggle              Unicode                        Do            │ Text │
       ╭───────────────────────────────────────────────────────────────────────┴──────╯
         _k_  [_f_] fill column     [_d_] unicode character           [_a_] align with regex
         ^↑^  [_h_] hidden chars    [_e_] evil digraphs table         [_w_] remove trailing ' '
         ^ ^  [_l_] line numbers    [_s_] specific code block         [_n_] count words
         ^↓^  [_t_] trailing ' '    [_u_] unicode character           [_i_] lorem ipsum
         _j_  [_v_] font space      [_p_] character code              [_x_] comment box
         ^ ^  [_c_] comment          ^ ^                              [_q_] boxquote
         ^ ^  [_b_] multibyte chars  ^ ^                              [_m_] iedit (multiple)
         ^ ^   ^ ^                   ^ ^                              [_r_] expand region
         ^ ^   ^ ^                   ^ ^                              [_U_] tabs to spaces
       --------------------------------------------------------------------------------
             "
  ("a" align-regexp)
  ("b" toggle-enable-multibyte-characters)
  ("c" comment-line)
  ("d" insert-char)
  ("e" evil-ex-show-digraphs)
  ("f" fci-mode)
  ("h" whitespace-mode)
  ("i" lorem-ipsum-insert-paragraphs)
  ("k" text-scale-increase :color red)
  ("j" text-scale-decrease :color red)
  ("l" linum-mode)
  ("n" count-words)
  ("m" iedit)
  ("p" describe-char)
  ("r" er/expand-region)
  ("s" charmap)
  ("t" joe-toggle-show-trailing-whitespace)
  ("u" counsel-unicode-char)
  ("v" variable-pitch-mode)
  ("w" whitespace-cleanup)
  ("U" untabify)
  ("q" hydra-boxquote/body)
  ("x" comment-box))
    #+END_SRC

*** hydra-git
    :PROPERTIES:
    :CREATED:  [2019-06-20 Thu 17:11]
    :END:
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-git (:color blue :hint nil :inherit (hydra-common/heads))

  "
                                                                           ╭─────┐
     Magit                          VC                    Timemachine      │ Git │
  ╭────────────────────────────────────────────────────────────────────────┴─────╯
    [_s_] status              [_d_] diffs between revisions  [_t_] timemachine
    [_B_] blame mode          [_b_] edition history
    [_l_] file log
  --------------------------------------------------------------------------------
        "
  ("B" magit-blame)
  ("b" vc-annotate)
  ("d" vc-diff)
  ("l" magit-log-buffer-file)
  ("s" magit-status)
  ("t" git-timemachine))
    #+END_SRC

*** hydra-window
    :PROPERTIES:
    :CREATED:  [2019-06-20 Thu 17:12]
    :END:
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-window (
                        :color red
                        :hint  nil
                        :inherit (hydra-common/heads))
  "
                                                                       ╭──────────┐
    Window         Switch           View                               │  Window  │
  ╭────────────────────────────────────────────────────────────────────┴──────────╯
       ↑          [_b_] ibuffer     [_s_] save
       _i_          [_p_] projectile  [_d_] delete
   ← _k_   _l_ →      [_e_] exwm        [_v_] view
       _o_
       ↓

     ^ ^
  --------------------------------------------------------------------------------
      "
  ("i" windmove-up)
  ("o" windmove-down)
  ("k" windmove-left)
  ("l" windmove-right)

  ("I" buf-move-up)
  ("O" buf-move-down)
  ("K" buf-move-left)
  ("L" buf-move-right)

  ("b" ibuffer)
  ("p" counsel-projectile-switch-to-buffer)
  ("e" ivy-switch-buffer-exwm)

  ("s"  ivy-push-view)
  ("d"  ivy-pop-view)
  ("v"  ivy-switch-view)

  ("0" delete-window-balance)
  ("1" delete-other-windows)
  ("2" split-window-below)
  ("3" split-window-right)

  (";" ace-swap-window "swap")
  ("@" hycontrol-windows-grid)
  )
    #+END_SRC

*** hydra-jump
    :PROPERTIES:
    :CREATED:  [2019-06-20 Thu 17:12]
    :END:
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-jump (:color blue :hint nil :inherit (hydra-common/heads))

  "
                                                                          ╭──────┐
    Window          WordChar        Line         iSearch                  │ Jump │
  ╭───────────────────────────────────────────────────────────────────────┴──────╯
    [_w_] jump        [_j_] word         [_l_] jump     [_i_] jump
    [_d_] close       [_p_] all words    [_y_] copy
    [_z_] maximize    [_b_] subword      [_m_] move
    [_s_] swap        [_c_] char         [_v_] copy region
     ^ ^              [_a_] two chars
  --------------------------------------------------------------------------------
        "
  ("w" ace-window)
  ("d" ace-delete-window)
  ("z" ace-maximize-window)
  ("s" ace-swap-window)
  ("j" avy-goto-word-1)
  ("p" avy-goto-word-0)
  ("b" avy-goto-subword-0)
  ("c" avy-goto-char)
  ("a" avy-goto-char-2)
  ("l" avy-goto-line)
  ("y" avy-copy-line)
  ("m" avy-move-line)
  ("v" avy-copy-region)
  ("i" avy-isearch)
  )
    #+END_SRC
*** hydra-register
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-register (:color blue :hint nil :inherit (hydra-common/heads))


  "
                                                                          ╭──────────┐
         Logs                        Registers                Undo        │ Register │
      ╭───────────────────────────────────────────────────────────────────┴──────────╯
        [_c_] commands history       [^e^] registers        [_u_] undo tree
        [_o_] messages
        [_l_] lossage (keystrokes)
        [_d_] diff buffer with file
      --------------------------------------------------------------------------------
            "
  ("d" joe-diff-buffer-with-file)
  ("k" counsel-yank-pop)
  ("l" view-lossage)
  ("c" counsel-command-history)
  ("m" evil-show-marks)
  ("o" view-echo-area-messages)
  ("r" evil-show-registers)
  ("u" undo-tree-visualize))
    #+END_SRC

*** hydra-search
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-search (:color blue :hint nil :inherit (hydra-common/heads))

  "
                                                                            ╭────────┐
         Files                             Buffer                           │ Search │
      ╭─────────────────────────────────────────────────────────────────────┴────────╯
        [_a_] regex search (Ag)           [_b_] by word
        [_r_] regex search (rg)           [_o_] by word (opened buffers)
        [_p_] regex search (pt)           [_w_] by word (multi)
        [_g_] regex search (grep)         [_h_] by word (grep or swiper)
        [^f^] find                        [_t_] tags & titles
        [_l_] locate                      [_s_] semantic
      --------------------------------------------------------------------------------
            "
  ("a" (let ((current-prefix-arg "-."))
         (call-interactively 'counsel-ag)))
  ("r" (let ((current-prefix-arg "-."))
         (call-interactively 'counsel-rg)))
  ("p" (let ((current-prefix-arg "-."))
         (call-interactively 'counsel-pt)))
  ("g" rgrep)
  ("l" counsel-locate)
  ("b" swiper)
  ("o" swiper-all)
  ("h" counsel-grep-or-swiper)
  ("t" counsel-imenu)
  ("s" counsel-semantic)
  ("w" swiper-multi))

    #+END_SRC

    #+results:
    : hydra-search/body
*** hydra-bookmarks
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-bookmarks (
                           :color red
                           :hint nil
                           :inherit (hydra-common/heads))

  "
                                                                     ╭───────────┐
         List                          Do                            │ Bookmarks │
  ╭──────────────────────────────────────────────────────────────────┴───────────╯
    [_l_] list bookmarks            [_j_] jump to a bookmark
     ^ ^                            [_m_] set bookmark at point
     ^ ^                            [_s_] save bookmarks
  --------------------------------------------------------------------------------
      "
  ("l" counsel-bookmark)
  ("j" bookmark-jump)
  ("m" bookmark-set)
  ("s" bookmark-save))
    #+END_SRC

*** hydra-help
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-help (:exit t :columns 4)
  "Help"
  ("f" counsel-apropos "Function search")
  ("k" view-lossage "View Keystrokes")
  ("c" find-function "Function code")
  ("P" esup "Profile")
  ("h" helpful-at-point "Help at point")
  ("p" find-function-at-point "Function at Point")
  ("l" find-library "Library source"))

    #+END_SRC
*** hydra-projects
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-projects (:color blue :hint nil :inherit (hydra-common/heads))
  "
                                                                       ╭────────────┐
       Files             Search          Buffer             Do         │ Projectile │
     ╭─────────────────────────────────────────────────────────────────┴────────────╯
       [_f_] file          [_sa_] ag          [_b_] switch         [_g_] magit
       [_l_] file dwim     [_sr_] rg          [_v_] show all       [_p_] switch
       [_r_] recent file   [_so_] occur       [_V_] ibuffer        [_P_] commander
       [_d_] dir           [_sR_] replace     [_K_] kill all       [_i_] info
       [_o_] other         [_st_] find tag
       [_u_] test file     [_sT_] make tags
                                                                           ╭────────┐
       Other Window      Run             Cache              Do             │ Fixmee │
     ╭──────────────────────────────────────────────────╯ ╭────────────────┴────────╯
       [_F_] file          [_U_] test        [_kc_] clear         [_x_] TODO & FIXME
       [_L_] dwim          [_m_] compile     [_kk_] add current   [_X_] toggle
       [_D_] dir           [_c_] shell       [_ks_] cleanup
       [_O_] other         [_C_] command     [_kd_] remove
       [_B_] buffer
     --------------------------------------------------------------------------------
           "

  ("p"   projectile-switch-project)
  ("sa"  counsel-projectile-ag)
  ("sr"  counsel-projectile-rg)
  ("b"   counsel-projectile-switch-to-buffer)
  ("B"   counsel-projectile-switch-to-buffer-other-window)
  ("d"   counsel-projectile-find-dir)
  ("D"   counsel-projectile-find-dir-other-window)
  ("f"   counsel-projectile-find-file)
  ("F"   counsel-projectile-find-file-other-window)
  ("l"   counsel-projectile-find-file-dwim)
  ("L"   counsel-projectile-find-file-dwim-other-window)

  ("c"   projectile-run-async-shell-command-in-root)
  ("C"   projectile-run-command-in-root)
  ("g"   hydra-git/body nil)
  ("i"   projectile-project-info)
  ("kc"  projectile-invalidate-cache)
  ("kd"  projectile-remove-known-project)
  ("kk"  projectile-cache-current-file)
  ("K"   projectile-kill-buffers)
  ("ks"  projectile-cleanup-known-projects)
  ("m"   projectile-compile-project)
  ("o"   projectile-find-other-file)
  ("O"   projectile-find-other-file-other-window)
  ("P"   projectile-commander)
  ("r"   projectile-recentf)
  ("so"   projectile-multi-occur)
  ("sR"   projectile-replace)
  ("st"   projectile-find-tag)
  ("sT"   projectile-regenerate-tags)
  ("u"   projectile-find-test-file)
  ("U"   projectile-test-project)
  ("v"   projectile-display-buffer)
  ("V"   projectile-ibuffer)

  ("X"   fixmee-mode)
  ("x"   fixmee-view-listing))

(define-key projectile-mode-map (kbd "C-c o") #'hydra-project/body)

    #+END_SRC
*** hydra-torus
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-torus (:color red :hint nil :inherit (hydra-common/heads))

  "
                                                                                             ╭─────────┐
      Switch                    Move                        Do                               │  Torus  │
  ╭──────────────────────────────────────────────────────────────────────────────────────────┴─────────╯
    [_c_] circle          [_<up>_]  prev-location         [_#_]  layout            [_s_] search
    [_l_] location        [_<down>_] next-location        [_ac_] add-circle        [_h_] search-history
    [_t_] torus                                         [_al_] add-location      [_m_] meta-history
                        [_<left>_]  prev-circle         [_at_] add-torus
                        [_<right>_] next-circle
                                                      [_dc_] delete-circle
                                                      [_dl_] delete-location
                        [_<prior>_] newer-history       [_dt_] delete-torus
                        [_<next>_]  older-history
     ^ ^
  -------------------------------------------------------------------------------------------------------
      "

  ("#" torus-layout-menu :color blue)

  ("c" torus-switch-circle :color blue)
  ("l" torus-switch-location :color blue)
  ("t" torus-switch-torus :color blue)

  ("ac" torus-add-circle :color blue)
  ("al" torus-add-location :color blue)
  ("at" torus-add-torus :color blue)

  ("dl" torus-delete-location :color blue)
  ("dc" torus-delete-circle :color blue)
  ("dt" torus-delete-torus :color blue)

  ("<up>"   torus-previous-location)
  ("<down>" torus-next-location)
  ("<left>" torus-previous-circle)
  ("<right>" torus-next-circle)


  ("s" torus-search :color blue)
  ("h" torus-search-history :color blue)
  ("m" torus-search-meta-history :color blue)

  ("<prior>" torus-history-newer)
  ("<next>" torus-history-older)

  )

    #+END_SRC

    #+results:
    : hydra-torus/body

*** hydra-applications
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-applications (:exit t :columns 4)
  "Applications"
  ("p" counsel-list-processes "Show Processes")
  ("r" elfeed "RSS Feeds"))
    #+END_SRC
*** hydra-org-refiler
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defvar org-default-projects-dir   "~/org/projects/"                     "Primary GTD directory")
(defvar org-default-notes-dir "~/org/notes/"                     "Directory of notes modeled after Zettelkasten includes an Archive, and Notes")
(defvar org-default-completed-dir  "~/org/projects/completed"            "Directory of completed project files")
(defvar org-default-inbox-file     "~/org/agenda/inbox.org"         "New stuff collects in this file")
(defvar org-default-tasks-file     "~/org/agenda/tasks.org"           "Tasks, TODOs and little projects")
(defvar org-default-incubate-file  "~/org/agenda/incubate.org"        "Ideas simmering on back burner")
(defvar org-default-calendar-file  "~/org/agenda/calendar.org"        "Ideas simmering on back burner")
(defvar org-default-delegate-file  "~/org/agenda/delegate.org"        "Ideas simmering on back burner")
(defvar org-default-waiting-file  "~/org/agenda/waiting.org"        "Ideas simmering on back burner")
(defvar org-default-completed-file nil                              "Ideas simmering on back burner")
(defvar org-default-notes-file     "~/org/agenda/inbox.org"   "Non-actionable, personal notes")

(defhydra hydra-org-refiler (:hint nil)
  "
     ^Update^        ^Refile^         ^Calendar^        ^Ref^         ^Move^           ^Go To^
     ^^^^^^^^^^------------------------------------------------------------------------------------------
     _t_: todo      _T_: tasks      _c c_: calendar  _r d_: web      _m p_: projects   _g p_: projects
     _s_: schedule  _I_: incubate   _c t_: tickler   _r w_: docs     _m n_: notes      _g c_: completed
     _d_: deadline  _W_: waiting    _c d_: delegate  _r i_: images
     _h_: headline  _R_: refile


     "
  ("<up>" org-previous-visible-heading)
  ("<down>" org-next-visible-heading)
  ("k" org-previous-visible-heading)
  ("j" org-next-visible-heading)

  ("T" org-refile-to-task)
  ("I" org-refile-to-incubate)
  ("W" org-refile-to-waiting)
  ("R"  org-refile)

  ("c c" refile-to-calendar)
  ("c t" refile-to-tickler)
  ("c d" org-refile-to-delegate)

  ("r d" note-to-documents)
  ("r w" note-to-websites)
  ("r i" note-to-images)

  ("m p" org-refile-to-projects-dir)
  ("m n" org-refile-to-notes-dir)

  ("t" org-todo)
  ("s" org-schedule)
  ("d" org-deadline)
  ("h" org-rename-header)

  ("g p" (dired org-default-projects-dir))
  ("g c" (dired org-default-completed-dir))
  ("[\t]" (org-cyce))

  ("s" (org-save-all-org-buffers) "save")

  ("a" org-archive-subtree "archive")
  ("d" org-cut-subtree "delete")
  ("q" (my/switch-to-last-buffer) "quit" :color blue))

    #+END_SRC

    #+results:
    : hydra-org-refiler/body
*** hydra-minor modes
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-minor (:exit t :columns 4)
  "Minor modes"
  ("r" spray-mode "Speed read")
  ("n" em/narrow-or-widen-dwim "Narrow / Widen")
  ("i" iedit-mode "Iedit mode"))
    #+END_SRC
*** hydra-python
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(with-no-warnings
  (defhydra hydra-python (:exit t :columns 4
                                :inherit (hydra-common/heads))
    "Python"
    ("#" poporg-dwim "Edit Comment")
    ("," dumb-jump-back "Jump back")
    ("." dumb-jump-go "Jump to definition")
    ("D" hydra-python-django/body "Django")
    ("L" flycheck-prev-error "Prev lint error")
    ("T" pythonic-tests-all "Run pythonic test")
    ("a" pytest-all "Run all tests")
    ("b" python-shell-send-buffer "Send buffer to python")
    ("u" em-python-pur "Upgrade pip requirements")
    ;;("r" python-shell-send-buffer "Send line/region to python")
    ("r" run-python "REPL")
                                        ;    ("d" helm-dash-at-point "Docs")
    ("c" em-python-execute "Compile / Execute")
    ("i" dumb-jump-quick-look "Definition Info")
    ("l" flycheck-next-error "Next lint error")
    ("t" pythonic-tests-run "Run current test")
    ("V" flycheck-verify-setup "Verify linting")
    ("v" em-python-environment "Check environment")
    ("s" isortify-buffer "Sort imports")
    ;;("n" flyceck "Run all tests")
    ("f" blacken-buffer "Format buffer code")))
    #+END_SRC

*** hydra-exwm
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-exwm (:exit t
                            :columns 2
                            :color blue
                            :inherit (hydra-common/heads))

  "EXWM"
  ("0" delete-window "delete")

  ("s"  #'exwm-input-send-next-key "send key")

  ("1" ace-delete-window "other")

  ("t"  #'exwm-floating-toggle-floating "toggle floating")

  ("2" split-window-below "below")

  ("f"  #'exwm-layout-set-fullscreen "fullscreen")

  ("3" split-window-right "right")

  ("m"  #'exwm-workspace-move-window "move window")

  (";" ace-swap-window "swap")

  ("r" rename-buffer "rename")

  ("e" exwm-edit--compose "compose")

  ("g" hycontrol-windows-grid "grid"))

    #+END_SRC
*** hydra-ibuffer
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-ibuffer-main (:color pink :hint nil)
  "
   ^Navigation^ | ^Mark^        | ^Actions^        | ^View^
  -^----------^-+-^----^--------+-^-------^--------+-^----^-------
    _k_:    ʌ   | _m_: mark     | _D_: delete      | _g_: refresh
   _RET_: visit | _u_: unmark   | _S_: save        | _s_: sort
    _j_:    v   | _*_: specific | _a_: all actions | _/_: filter
  -^----------^-+-^----^--------+-^-------^--------+-^----^-------
  "
  ("j" ibuffer-forward-line)
  ("RET" ibuffer-visit-buffer :color blue)
  ("k" ibuffer-backward-line)

  ("m" ibuffer-mark-forward)
  ("u" ibuffer-unmark-forward)
  ("*" hydra-ibuffer-mark/body :color blue)

  ("D" ibuffer-do-delete)
  ("S" ibuffer-do-save)
  ("a" hydra-ibuffer-action/body :color blue)

  ("g" ibuffer-update)
  ("s" hydra-ibuffer-sort/body :color blue)
  ("/" hydra-ibuffer-filter/body :color blue)

  ("o" ibuffer-visit-buffer-other-window "other window" :color blue)
  ("q" ibuffer-quit "quit ibuffer" :color blue)
  ("." nil "toggle hydra" :color blue))

(defhydra hydra-ibuffer-mark (:color teal :columns 5
                                     :after-exit (hydra-ibuffer-main/body))
  "Mark"
  ("*" ibuffer-unmark-all "unmark all")
  ("M" ibuffer-mark-by-mode "mode")
  ("m" ibuffer-mark-modified-buffers "modified")
  ("u" ibuffer-mark-unsaved-buffers "unsaved")
  ("s" ibuffer-mark-special-buffers "special")
  ("r" ibuffer-mark-read-only-buffers "read-only")
  ("/" ibuffer-mark-dired-buffers "dired")
  ("e" ibuffer-mark-dissociated-buffers "dissociated")
  ("h" ibuffer-mark-help-buffers "help")
  ("z" ibuffer-mark-compressed-file-buffers "compressed")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-action (:color teal :columns 4
                                       :after-exit
                                       (if (eq major-mode 'ibuffer-mode)
                                           (hydra-ibuffer-main/body)))
  "Action"
  ("A" ibuffer-do-view "view")
  ("E" ibuffer-do-eval "eval")
  ("F" ibuffer-do-shell-command-file "shell-command-file")
  ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
  ("H" ibuffer-do-view-other-frame "view-other-frame")
  ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
  ("M" ibuffer-do-toggle-modified "toggle-modified")
  ("O" ibuffer-do-occur "occur")
  ("P" ibuffer-do-print "print")
  ("Q" ibuffer-do-query-replace "query-replace")
  ("R" ibuffer-do-rename-uniquely "rename-uniquely")
  ("T" ibuffer-do-toggle-read-only "toggle-read-only")
  ("U" ibuffer-do-replace-regexp "replace-regexp")
  ("V" ibuffer-do-revert "revert")
  ("W" ibuffer-do-view-and-eval "view-and-eval")
  ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
  ("b" nil "back"))

(defhydra hydra-ibuffer-sort (:color amaranth :columns 3)
  "Sort"
  ("i" ibuffer-invert-sorting "invert")
  ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
  ("v" ibuffer-do-sort-by-recency "recently used")
  ("s" ibuffer-do-sort-by-size "size")
  ("f" ibuffer-do-sort-by-filename/process "filename")
  ("m" ibuffer-do-sort-by-major-mode "mode")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-filter (:color amaranth :columns 4)
  "Filter"
  ("m" ibuffer-filter-by-used-mode "mode")
  ("M" ibuffer-filter-by-derived-mode "derived mode")
  ("n" ibuffer-filter-by-name "name")
  ("c" ibuffer-filter-by-content "content")
  ("e" ibuffer-filter-by-predicate "predicate")
  ("f" ibuffer-filter-by-filename "filename")
  (">" ibuffer-filter-by-size-gt "size")
  ("<" ibuffer-filter-by-size-lt "size")
  ("/" ibuffer-filter-disable "disable")
  ("b" hydra-ibuffer-main/body "back" :color blue))


    #+END_SRC

    #+results:
    : hydra-ibuffer-main/body

*** hydra-org-table
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-org-table-helper (:color pink :hint nil)
  "
  org table helper
  _r_ recalculate     _w_ wrap region      _c_ toggle coordinates
  _i_ iterate table   _t_ transpose        _D_ toggle debugger
  _B_ iterate buffer  _E_ export table     _n_ remove number separators
  _e_ eval formula    _s_ sort lines       _d_ edit field

  _q_ quit
  "
  ("E" org-table-export :color blue)
  ("s" org-table-sort-lines)
  ("d" org-table-edit-field)
  ("e" org-table-eval-formula)
  ("r" org-table-recalculate)
  ("i" org-table-iterate)
  ("B" org-table-iterate-buffer-tables)
  ("w" org-table-wrap-region)
  ("D" org-table-toggle-formula-debugger)
  ("t" org-table-transpose-table-at-point)
  ("n" dfeich/org-table-remove-num-sep :color blue)
  ("c" org-table-toggle-coordinate-overlays :color blue)
  ("q" nil :color blue))
    #+END_SRC

    #+results:
    : hydra-org-table-helper/body

*** hydra-babel
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-babel-helper (:color pink :hint nil)
  "
  org babel src block helper functions
  _n_ next       _i_ info           _I_ insert header
  _p_ prev       _c_ check
  _h_ goto head  _E_ expand
  ^ ^            _s_ split
  _q_ quit       _r_ remove result  _e_ examplify region

  "
  ("i" org-babel-view-src-block-info)
  ("I" org-babel-insert-header-arg)
  ("c" org-babel-check-src-block :color blue)
  ("s" org-babel-demarcate-block :color blue)
  ("n" org-babel-next-src-block)
  ("p" org-babel-previous-src-block)
  ("E" org-babel-expand-src-block :color blue)
  ("e" org-babel-examplify-region :color blue)
  ("r" org-babel-remove-result :color blue)
  ("h" org-babel-goto-src-block-head)
  ("q" nil :color blue))

    #+END_SRC

    #+results:
    : hydra-babel-helper/body

*** hydra-context-hydra-launcher
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defun context-hydra-launcher ()
  "A launcher for hydras based on the current context."
  (interactive)
  (cl-case major-mode
    ('org-mode (let* ((elem (org-element-context))
                      (etype (car elem))
                      (type (org-element-property :type elem)))
                 (cl-case etype
                   (src-block (hydra-babel-helper/body))
                   (link (hydra-org-link-helper/body))
                   ((table-row table-cell) (hydra-org-table-helper/body))
                   (t (message "No specific hydra for %s/%s" etype type)
                      (hydra-org-default/body)))))

    ('bibtex-mode (org-ref-bibtex-hydra/body))
    ('ibuffer-mode (hydra-ibuffer-main/body))

    (t (message "No hydra for this major mode: %s" major-mode))))

    #+END_SRC
*** hydra-org-link
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-org-link (:color pink :hint nil)
  "
  org link helper
  _i_ backward slurp     _o_ forward slurp    _n_ next link
  _j_ backward barf      _k_ forward barf     _p_ previous link

  _q_ quit
  "
  ("i" org-link-edit-backward-slurp)
  ("o" org-link-edit-forward-slurp)
  ("j" org-link-edit-backward-barf)
  ("k" org-link-edit-forward-barf)
  ("n" org-next-link)
  ("p" org-previous-link)
  ("q" nil :color blue))


    #+END_SRC

*** hydra-clock
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-clock (:color blue)
  "
      ^
      ^Clock^             ^Do^
      ^─────^─────────────^──^─────────
      _q_ quit            _c_ cancel
      ^^                  _d_ display
      ^^                  _e_ effort
      ^^                  _i_ in
      ^^                  _g_ goto
      ^^                  _o_ out
      ^^                  _r_ report
      ^^                  ^^
      "
  ("q" nil)
  ("c" org-clock-cancel :color pink)
  ("d" org-clock-display)
  ("e" org-clock-modify-effort-estimate)
  ("i" org-clock-in)
  ("g" org-clock-goto)
  ("o" org-clock-out)
  ("r" org-clock-report))

    #+END_SRC

    #+results:
    : hydra-clock/body

*** hydra-windows-hydra
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra windows-hydra ()
  "Window Management"
  ("a" (call-interactively #'ace-window) "ace")
  ("v" (flip-frame) "flip-vertically")
  ("h" (flop-frame) "flop-horizontally")
  ("r" (rotate-frame-clockwise) "rotate clockwise")
  ("R" (rotate-frame-anticlockwise) "rotate anti-clockwise")
  ("t" (transpose-frame) "transpose")
  ("w" (call-interactively #'exwm-workspace-move-window) "exwm move win to workspace")
  ("<left>" (call-interactively #'shrink-window-horizontally) "shrink-window-horizontally")
  ("<right>" (call-interactively #'enlarge-window-horizontally) "enlarge-window-horizontally")
  ("<down>" (call-interactively #'shrink-window) "shrink-window")
  ("<up>" (call-interactively #'enlarge-window) "enlarge-window")
  ("<s-up>" (windmove-up) "move up")
  ("<s-down>" (windmove-down) "move down")
  ("<s-right>" (windmove-right) "move right")
  ("<s-left>" (windmove-left) "move left")
  ("0" (delete-window) "")
  ("s-0" (delete-window) "")
  ("1" (delete-other-windows) "")
  ("s-1" (delete-other-windows) "")
  ("2" (split-window-below) "")
  ("s-2" (split-window-below) "")
  ("3" (split-window-right) "")
  ("s-3" (split-window-right) "")
  ("q" nil "Quit"))

    #+END_SRC

    #+results:
    : windows-hydra/body

*** hydra-caps-hydra
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-caps (:exit nil)
  "NAVI-MODE"
  ("<menu>" nil)

  ("=" ((lambda ()
          (start-process-shell-command "notify-send" nil "notify-send Smarparens-Strict-Mode Toggled")
          (call-interactively #'smartparens-strict-mode))))

  ("C-g" (keyboard-quit))
  ("g" (keyboard-quit))
  ("SPC" (call-interactively #'set-mark-command))
  ("C-SPC" (call-interactively #'set-mark-command))
  ("C-n" (next-line))
  (";" (call-interactively #'goto-last-change))
  ("," (call-interactively #'goto-last-change-reverse))
  ("C-p" (previous-line))
  ("C-f" (forward-char))
  ("C-b" (backward-char))
  ("C-v" (scroll-up-command))
  ("v" (scroll-up-command))
  ("M-v" (scroll-down-command))
  ("V" (scroll-down-command))

  ("j" (dumb-jump-go))
  ("k" (dumb-jump-back))
  ("l" (dumb-jump-quick-look))

  ("<" (beginning-of-buffer))
  (">" (end-of-buffer))
  ("\[" (backward-paragraph))
  ("\]" (forward-paragraph))
  ("s-f" (sp-forward-symbol))
  ("M-f" (forward-word))
  ("s-b" (sp-backward-symbol))
  ("M-b" (backward-word))

  ("e" (sp-forward-sexp))
  ("a" (sp-backward-sexp))
  ("f" (sp-down-sexp))
  ("b" (sp-up-sexp))
  ("m" (call-interactively #'magit-status))
  ("n" (sp-next-sexp))
  ("p" (sp-previous-sexp))
  ("s" (sp-select-next-thing))
  ("S" (sp-select-previous-thing))

  ("B" (helm-buffers-list))
  ("E" ((lambda ()
          (flycheck-mode 1)
          (flycheck-list-errors))))
  ("P" (projectile-commander))
  ("F" (call-interactively #'helm-find-files))
  ("D" (dired (helm-current-directory)))
  ("M" (call-interactively #'magit-status))

  ("/" (helm-swoop))
  ("+" (operate-on-number-at-point)))

    #+END_SRC

    #+results:
    : caps-hydra/body

*** hydra-undo-tree
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-undo-tree (:color yellow
                                  :hint nil
                                  )
  "
    _p_: undo  _n_: redo _s_: save _l_: load   "
  ("p"   undo-tree-undo)
  ("n"   undo-tree-redo)
  ("s"   undo-tree-save-history)
  ("l"   undo-tree-load-history)
  ("u"   undo-tree-visualize "visualize" :color blue)
  ("q"   nil "quit" :color blue))

    #+END_SRC

    #+results:
    : hydra-undo-tree/body

*** hydra-pdftools
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-hydra.el
(defhydra hydra-pdftools (:color blue :hint nil)
  "
                                                                        ╭───────────┐
         Move  History   Scale/Fit     Annotations  Search/Link    Do   │ PDF Tools │
     ╭──────────────────────────────────────────────────────────────────┴───────────╯
        ^^^_g_^^^       _B_    ^↧^    _+_    ^ ^     [_al_] list    [_s_] search      [_u_] revert buffer
        ^^^^↑^^^^       ^↑^    _H_    ^↑^  ↦ _W_ ↤   [_am_] markup  [_o_] outline     [_i_] info
        ^^^_p_^^^       ^ ^    ^↥^    _0_    ^ ^     [_at_] text    [_F_] link        [_d_] midgnight mode
        ^^^^↑^^^^       ^↓^  ╭─^─^─┐  ^↓^  ╭─^ ^─┐   [_ad_] delete  [_f_] search link [_D_] print mode
   _h_ ← _e_/_t_ → _l_  _N_  │ _P_ │  _-_    _b_     [_aa_] dired
        ^^^^↓^^^^       ^ ^  ╰─^─^─╯  ^ ^  ╰─^ ^─╯   [_y_]  yank
        ^^^_n_^^^       ^ ^  _r_eset slice box
        ^^^^↓^^^^
        ^^^_G_^^^
     --------------------------------------------------------------------------------
          "
  ("\\" hydra-master/body "back")
  ("<ESC>" nil "quit")
  ("al" pdf-annot-list-annotations)
  ("ad" pdf-annot-delete)
  ("aa" pdf-annot-attachment-dired)
  ("am" pdf-annot-add-markup-annotation)
  ("at" pdf-annot-add-text-annotation)
  ("y"  pdf-view-kill-ring-save)
  ("+" pdf-view-enlarge :color red)
  ("-" pdf-view-shrink :color red)
  ("0" pdf-view-scale-reset)
  ("H" pdf-view-fit-height-to-window)
  ("W" pdf-view-fit-width-to-window)
  ("P" pdf-view-fit-page-to-window)
  ("n" pdf-view-next-page-command :color red)
  ("p" pdf-view-previous-page-command :color red)
  ("d" pdf-view-midnight-minor-mode)
  ("D" pdf-view-printer-minor-mode)
  ("b" pdf-view-set-slice-from-bounding-box)
  ("r" pdf-view-reset-slice)
  ("g" pdf-view-first-page)
  ("G" pdf-view-last-page)
  ("e" pdf-view-goto-page)
  ("t" pdf-view-goto-label)
  ("o" pdf-outline)
  ("s" pdf-occur)
  ("i" pdf-misc-display-metadata)
  ("u" pdf-view-revert-buffer)
  ("F" pdf-links-action-perfom)
  ("f" pdf-links-isearch-link)
  ("B" pdf-history-backward :color red)
  ("N" pdf-history-forward :color red)
  ("l" image-forward-hscroll :color red)
  ("h" image-backward-hscroll :color red))
    #+END_SRC

    #+results:
    : hydra-pdftools/body
** transient
   :PROPERTIES:
   :CREATED:  [2019-06-28 Fri 15:54]
   :END:
   :LOGBOOK:
   - CLOSING NOTE [2019-06-28 Fri 15:54]
   :END:
   #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-transient.el
(use-package transient
  :config
  (add-to-list 'load-path "~/Public/matcha")
  (load-file "~/Public/matcha/matcha.el")
  (matcha-setup))
   #+END_SRC
*** org-agenda-process
   #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-transient.el
(require 'matcha-base)
(require 'org)

(define-transient-command org-agenda-process ()
  "Agenda"

  [["Move"
   ("n" "Next" org-next-visible-heading :transient t)
   ("p" "Prev" org-previous-visible-heading :transient t)]

   ["Update"
    ("t" "Todo" org-todo :transient t)
    ("s" "Schedule" org-schedule :transient t)
    ("d" "Deadline" org-deadline :transient t)
    ("h" "Rename" org-rename-header :transient t)
    ("a" "Archive" org-archive-subtree :transient t)
    ("d" "Delete" org-cut-subtree :transient t)
    ("S" "Save.." org-save-all-org-buffers :transient t)]

   ["Create"
    ("P" "Project" org-refile-to-projects-dir :transient t)
    ("N" "Note" org-refile-to-notes-dir :transient t)]

   ["Refile to"
    ("T" "Tasks" org-refile-to-task :transient t)
    ("I" "Incubate" org-refile-to-incubate :transient t)
    ("W" "Waiting" org-refile-to-waiting :transient t)
    ("R" "Other.." org-refile :transient t)]

   ["Calendar"
    ("c c" "Calendar" refile-to-calendar :transient t)
    ("c t" "Tickler" refile-to-tickler :transient t)
    ("c d" "Delegate" org-refile-to-delegate :transient t)]

   ["Reference"
    ("r d" "Document" note-to-documents :transient t)
    ("r w" "Website" note-to-websites :transient t)
    ("r i" "Images" note-to-images :transient t)]])




    #+END_SRC
** modalka
   :PROPERTIES:
   :CREATED:  [2019-06-28 Fri 16:56]
   :END:
*** setup
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-modalka.el
(use-package modalka
  :config
  (modalka-global-mode 1)

  (defun normal-mode-modalka ()
    (interactive)
    (if (modalka-mode nil)
        (modalka-mode 1)
      (nil)))

  (defun insert-mode-modalka ()
    (interactive)
    (modalka-mode 0))

  (setq-default cursor-type '(bar . 1))
  (setq modalka-cursor-type 'box)

  (setq org-capture-mode-hook 'insert-mode-modalka)

    #+END_SRC
*** modalka-major-mode
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-modalka.el
(defun modalka-select-major-mode (modalka-mode-map)
  (let ((modalka-mode-command (cdr (assoc major-mode modalka-mode-map))))
    (if modalka-mode-command (apply modalka-mode-command))))

(defun modalka-mode-hydra ()
  (interactive)
  (modalka-select-major-mode modalka-major-mode-hydra-list))

(setq modalka-key-list '
      ((org-mode . (message "%s" "command from org mode"))
       (lisp-mode . (message "%s" "command from lisp mode"))
       (python-mode . (message "%s" "command from python mode"))))

(setq modalka-major-mode-hydra-list '
      ((org-mode . (matcha-org-mode))
       (emacs-lisp-mode . (matcha-emacs-lisp-mode))
       (js-mode . (matcha-indium-mode/body))
       (js2-mode . (matcha-indium-mode/body))
       (rjsx-mode . (matcha-indium-mode/body))
       (json-mode . (matcha-json-mode))
       (css-mode . (matcha-css-mode))
       (scss-mode . (matcha-css-mode))
       (web-mode . (matcha-web-mode/body))
       (html-mode . (matcha-web-mode/body))
       (mhtml-mode . (matcha-web-mode/body))
       (exwm-mode . (hydra-exwm/body))
       (elfeed-search-mode . (hydra-elfeed-search/body))
       (python-mode . (matcha-python-mode))))


(custom-set-variables
 '(modalka-excluded-modes
   (quote
    (
     ediff-mode
     helpful-mode
     guix-mode
     dired-mode
     magit-mode
     magit-popup-mode
     debugger-mode
     ediff-mode
     help-mode
     git-rebase-mode
     mu4e-headers-mode
     mu4e-view-mode
     help-mode
     org-agenda-mode
     org-capture-mode
     emms-playlist-mode
     pdf-tools-modes
     ,*dashboard*
     ,*Messages*
     makey-key-mode
     ))))

    #+END_SRC
*** keybindings
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-modalka.el
(define-key modalka-mode-map [remap self-insert-command] 'ignore)

(define-key global-map [escape] #'normal-mode-modalka)
(define-key modalka-mode-map (kbd "SPC") 'counsel-M-x)
(define-key modalka-mode-map (kbd "<return>") 'counsel-linux-app)
(define-key modalka-mode-map (kbd "<tab>") 'my/switch-to-last-buffer)


(define-key modalka-mode-map (kbd "a")  'matcha-org-agenda)
(define-key modalka-mode-map (kbd "b")  'ivy-switch-buffer)
(define-key modalka-mode-map (kbd "c")  'hydra-copy/body)
(define-key modalka-mode-map (kbd "d")  'dired-jump)
(define-key modalka-mode-map (kbd "e")  'hydra-emacs/body)
(define-key modalka-mode-map (kbd "f")  'hydra-file/body)
(define-key modalka-mode-map (kbd "g")  'magit-status)
(define-key modalka-mode-map (kbd "h")  'hydra-help/body)
(define-key modalka-mode-map (kbd "i") #'insert-mode-modalka)
(define-key modalka-mode-map (kbd "j")  'hydra-jump/body)
(define-key modalka-mode-map (kbd "k")  'hydra-delete/body)
(define-key modalka-mode-map (kbd "l")  'org-goto-current-datetree-entry)
(define-key modalka-mode-map (kbd "m")  'modalka-mode-hydra)
(define-key modalka-mode-map (kbd "n")  'hydra-narrow/body)
(define-key modalka-mode-map (kbd "o")  'objed-activate)
(define-key modalka-mode-map (kbd "p")  nil)
(define-key modalka-mode-map (kbd "q")  'hydra-master/body)
(define-key modalka-mode-map (kbd "r")  'hydra-register/body)
(define-key modalka-mode-map (kbd "s")  nil)
(define-key modalka-mode-map (kbd "t")  'torus-search)
(define-key modalka-mode-map (kbd "u")  nil)
(define-key modalka-mode-map (kbd "v")  nil)
(define-key modalka-mode-map (kbd "w")  'hydra-window/body)
(define-key modalka-mode-map (kbd "x")  nil)
(define-key modalka-mode-map (kbd "y")  'hydra-paste/body)
(define-key modalka-mode-map (kbd "z")  'ivy-resume)

(define-key modalka-mode-map (kbd "A")  nil)
(define-key modalka-mode-map (kbd "B")  'ivy-switch-buffer-exwm)
(define-key modalka-mode-map (kbd "C")  nil)
(define-key modalka-mode-map (kbd "D")  nil)
(define-key modalka-mode-map (kbd "E")  nil)
(define-key modalka-mode-map (kbd "F")  nil)
(define-key modalka-mode-map (kbd "G")  'hydra-git/body)
(define-key modalka-mode-map (kbd "H")  nil)
(define-key modalka-mode-map (kbd "I")  nil)
(define-key modalka-mode-map (kbd "J")  nil)
(define-key modalka-mode-map (kbd "K")  nil)
(define-key modalka-mode-map (kbd "L")  nil)
(define-key modalka-mode-map (kbd "M")  'hydra-minor/body)
(define-key modalka-mode-map (kbd "N")  nil)
(define-key modalka-mode-map (kbd "O")  nil)
(define-key modalka-mode-map (kbd "P")  nil)
(define-key modalka-mode-map (kbd "Q")  nil)
(define-key modalka-mode-map (kbd "R")  nil)
(define-key modalka-mode-map (kbd "S")  nil)
(define-key modalka-mode-map (kbd "T")  'hydra-torus/body)
(define-key modalka-mode-map (kbd "U")  nil)
(define-key modalka-mode-map (kbd "V")  nil)
(define-key modalka-mode-map (kbd "W")  nil)
(define-key modalka-mode-map (kbd "X")  nil)
(define-key modalka-mode-map (kbd "Y")  nil)
(define-key modalka-mode-map (kbd "Z")  nil)

(define-key modalka-mode-map (kbd "0")  'delete-window)
(define-key modalka-mode-map (kbd "1")  'delete-other-windows)
(define-key modalka-mode-map (kbd "2")  'split-window-below)
(define-key modalka-mode-map (kbd "3")  'split-window-right)
(define-key modalka-mode-map (kbd "4")  nil)
(define-key modalka-mode-map (kbd "5")  nil)
(define-key modalka-mode-map (kbd "6")  nil)
(define-key modalka-mode-map (kbd "8")  nil)
(define-key modalka-mode-map (kbd "9")  nil)

)
    #+END_SRC
** objed
   :PROPERTIES:
   :CREATED:  [2019-06-28 Fri 16:56]
   :END:
   #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-objed.el
(use-package objed
  :config

  (require 'objed)

  (add-to-list 'objed-keeper-commands 'undo-tree-undo)
  (add-to-list 'objed-keeper-commands 'undo-tree-redo)
  (add-to-list 'objed-keeper-commands 'undo-tree-visualize)

  (defvar objed--extra-face-remaps nil)

  (defun objed-add-face-remaps (&rest _)
    "Add extra face remaps when objed activates."
    (when (memq 'objed-hl (assq 'hl-line face-remapping-alist))
      (push (face-remap-add-relative 'solaire-hl-line-face 'objed-hl)
            objed--extra-face-remaps)))

  (defun objed-remove-face-remaps (&rest _)
    "Remove extra face remaps when objed de-activates."
    (unless (memq 'objed-hl (assq 'hl-line face-remapping-alist))
      (dolist (remap objed--extra-face-remaps)
        (face-remap-remove-relative remap))
      (setq objed--extra-face-remaps nil)))

  (advice-add 'objed--init :after #'objed-add-face-remaps)
  (advice-add 'objed--reset :after #'objed-remove-face-remaps)

                                        ;(define-key objed-user-map "f" nil)
  (define-key objed-user-map "d" 'xref-find-definitions)
  (define-key objed-user-map "r" 'xref-find-references)

  (define-key objed-op-map "j" 'counsel-imenu)
  (define-key objed-op-map "f" 'counsel-find-file)
  (define-key objed-op-map "b" 'ivy-switch-buffer))




   #+END_SRC
** Hyperbole
   :PROPERTIES:
   :CREATED:  [2019-06-28 Fri 16:56]
   :END:
   #+BEGIN_SRC emacs-lisp :tangle no
(use-package hyperbole
  :config
  (add-to-list 'hyperbole-web-search-alist '("DuckDuckGo" . "https://duckduckgo.com/?q=%s")))
   #+END_SRC

** howm
   :PROPERTIES:
   :CREATED:  [2019-06-28 Fri 16:56]
   :END:
**** package
     #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-howm.el

(setq howm-template
      ":HIDDEN:
  ,#+PARENTS:
  ,#+CHILDREN:
  ,#+FRIENDS:

  :RELATED:
  %file
  %title

  :RESOURCES:

  :END:
  ,#+TITLE: %cursor
  %fname
  %date
  ,#+CATEGORY:
  ,#+KEYWORDS:

    ")


     #+END_SRC
**** functions
     #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-howm.el
(use-package howm
  :config
  (require 'howm)

  (define-key howm-view-summary-mode-map (kbd "M-C-m") 'howm-open-new-frame-summary)
  (define-key howm-view-summary-mode-map [tab] 'my/howm-view-summary-open)


  (defvar howm-view-title-header "#+TITLE:")

  (defvar howm-view-header-format
    "\n\n#+INCLUDE: %s\n")

  (setq howm-template-rules
        '(("%title" . howm-template-title)
          ("%date" . howm-template-date)
          ("%file" . howm-template-previous-file)
          ("%parent" . howm-template-parent)
          ("%fname" . howm-template-filename)
          ("%cursor" . howm-template-cursor)))

  (defun howm-template-title (arg)
    (insert (cdr (assoc 'title arg))))

  (defun howm-template-filename (arg)
    (insert (concat ">>>" (file-name-base buffer-file-name))))

  (defun howm-template-parent (arg)
    (insert (cdr (assoc 'parent arg))))

  (defun howm-template-date (arg)
    (insert (cdr (assoc 'date arg))))

  (defun howm-template-previous-file (arg)
    (insert (cdr (assoc 'file arg))))

  (defun howm-template-cursor (arg))

  (setq howm-file-name-format "%Y-%m-%dT%H.%M.%S.org")
  (setq howm-template-date-format "#+DATE: [%Y-%m-%d %H:%M]")
  (setq howm-directory "~/org/notes/")
  (setq howm-view-preview-narrow nil)

  (add-hook 'org-mode-hook 'howm-mode)
  (add-to-list 'auto-mode-alist '("\\.howm$" . org-mode))



  (setq howm-view-split-horizontally t)
  (setq howm-view-keep-one-window t)

  (setq howm-menu-refresh-after-save nil)
  (setq howm-menu-expiry-hours 6)  ;; cache menu N hours
  (setq howm-menu-file "0000-00-00-000000.txt")  ;; don't *search*

  (setq howm-view-use-grep t)
  (setq howm-view-grep-command "rg")
  (setq howm-view-grep-option "-nH --no-heading --color never")
  (setq howm-view-grep-extended-option nil)
  (setq howm-view-grep-fixed-option "-F")
  (setq howm-view-grep-expr-option nil)
  (setq howm-view-grep-file-stdin-option nil)

  ;; howm-menu
  (defun howm-menu-with-j1 (orig-fun &rest args)
    (setq howm-view-grep-option "-nH --no-heading -j1 --color never")
    (apply orig-fun args)
    (setq howm-view-grep-option "-nH --no-heading --color never"))

  (advice-add 'howm-menu-refresh :around #'howm-menu-with-j1)

  (setq howm-view-search-in-result-correctly t)

  (setq howm-view-list-title-type 2)
  (setq howm-view-summary-format "")

  (defun howm-search-title (title)
    (interactive "sSearch title: ")
    (message title)
    (howm-search (format "^* +%s" (regexp-quote title)) nil))

  (defun howm-list-grep-in-new-frame (&optional completion-p)
    (interactive "P")
    (select-frame (make-frame))
    (howm-list-grep completion-p))

  (defvar *howm-new-frame* nil)

  (defun howm-new-frame ()
    (when *howm-new-frame*
      (select-frame (make-frame))))
  (add-hook 'howm-view-before-open-hook 'howm-new-frame)

  (defun howm-open-new-frame (opener)
    ;; move cursor back from contents to summary in the original frame
    (let (new-frame)
      (save-window-excursion
        (let ((*howm-new-frame* t))
          (funcall opener))
        (setq new-frame (selected-frame)))
      (select-frame new-frame)))

  (defun howm-open-new-frame-summary ()
    (interactive)
    (howm-open-new-frame #'howm-view-summary-open-sub))

  (defun howm-open-new-frame-contents ()
    (interactive)
    (howm-open-new-frame #'howm-view-contents-open-sub))


  (defun howm-create-and-link (&optional which-template)
    (interactive "p")
    (let ((b (current-buffer))
          (p (point)))
      (prog1
          (howm-create which-template)
        (let ((f (buffer-file-name)))
          (when (and f (buffer-file-name b))
            (with-current-buffer b
              (goto-char p)
              (insert (format howm-template-file-format
                              (abbreviate-file-name f))
                      "\n")))))))

  (defun howm-open-from-calendar ()
    (interactive)
    (require 'howm-mode)
    (let* ((mdy (calendar-cursor-to-date t))
           (m (car mdy))
           (d (second mdy))
           (y (third mdy))
           (ti (encode-time 0 0 0 d m y))
           (pc (howm-folder-get-page-create howm-directory (howm-file-name ti)))
           (page (car pc))
           (createp (cdr pc)))
      (other-window 1)
      (howm-page-open page)
      (if createp
          (howm-create-here)
        (howm-set-mode))))
  (require 'calendar)


  (defun my-howm-switch-to-summary ()
    (interactive)
    (switch-to-buffer "*howmS*")
    (riffle-summary-check t))

  (add-hook 'howm-view-contents-mode-hook
            (lambda ()
              (setq default-directory howm-directory)
              (howm-mode 1)))
  (defadvice riffle-contents-show (around howm-mode (item-list) activate)
    ad-do-it
    (when howm-mode
      (howm-initialize-buffer)))


  (defun howm-export-to-org ()
    "Remove formatting and export to plain text
    when in howmC view"
    (interactive)
    (copy-whole-buffer-to-clipboard)
    (find-file   (concat "~/notes_export_" (format-time-string "%m-%d-%H%M%S") ".org"))
    (yank)
    (goto-char(point-min))
    (replace-string  "#+TITLE: "  "* ")
    (goto-char(point-min))
    (replace-string "#+DATE: " "")
    (goto-char(point-min))
    (replace-string "#+KEYWORDS: " "")
    (goto-char(point-min))
    (replace-regexp "^==========================>>> .*$" ""))


  (defun howm-insert-filename ()
    (interactive)
    (insert (concat ">>>" (file-name-base buffer-file-name))))


  (defun howm-create (&optional which-template here)
    (interactive "p")
    (let* ((t-c (howm-create-default-title-content))
           (title (car t-c))
           (content (cdr t-c)))
      (howm-create-file-with-title title which-template nil here content)
      (org-cycle '(16))
      ))


  (defun my/howm-view-summary-open ()
    (interactive)
    (howm-view-summary-open)
    (delete-other-windows))

  (defun my/howm-view-summary-open ()
    (interactive)
    (howm-view-summary-open)
    (org-cycle '(16)))

  (defun howm-org-include-file ()
    (interactive)
    (save-excursion
      (setq current-buffer buffer-file-name)
      (switch-to-buffer "*scratch*")
      (insert "\n\n")
      (insert "#+INCLUDE: \"" current-buffer "\" :only-contents t :lines \"10-\"\n\n"))))


     #+END_SRC
** emms
   :PROPERTIES:
   :CREATED:  [2019-06-28 Fri 16:56]
   :END:
   #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-emms.el
(use-package emms
  :config
  (require 'emms)
  (emms-all)
  (emms-default-players)
  (setq emms-playlist-buffer-name "*Music*")
  (setq emms-info-asynchronously t)
  (setq emms-info-functions '(emms-info-libtag))
  (emms-mode-line 0)
  (emms-playing-time 1)

  (setq emms-source-file-default-directory "/home/alexander/org/data/c0/80320c-060b-4348-a413-ee7d8ed40dd6/"))

   #+END_SRC
** circe
   :PROPERTIES:
   :CREATED:  [2019-06-28 Fri 16:56]
   :END:
   #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-circe.el
(use-package circe
  :config
  (require 'circe)
  (setf (cdr tracking-mode-map) nil)
  (defun my/rename-irc-channel-buffer ()
    (rename-buffer (concat (buffer-name) "@" (with-circe-server-buffer circe-network))))
  (add-hook 'circe-channel-mode-hook 'my/rename-irc-channel-buffer)

  (defun my/highlight-channel ()
    (interactive)
    (setq-local my/buffer-notify t))
  (add-hook 'tracking-buffer-added-hook 'my/highlight-channel)
  (defun my/de-highlight-channel ()
    (interactive)
    (setq-local my/buffer-notify nil))
  (add-hook 'tracking-buffer-removed-hook 'my/de-highlight-channel)
  (enable-circe-color-nicks)
  (setq lui-fill-column 100000
        lui-time-stamp-position 'left
        circe-lagmon-timer-tick 120
        circe-reduce-lurker-spam t
        circe-server-buffer-name "{network}"
        circe-default-nick "Dynamicmetaflow"
        circe-default-user "Dynamicmetaflow"
        circe-default-realname "Dynamicmetaflow"
        ))
   #+END_SRC
** pdf-tools
   :PROPERTIES:
   :CREATED:  [2019-06-28 Fri 16:56]
   :END:
   #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-pdf-tools.el
(use-package pdf-tools
  :defer 0.1
  :config
  (unless noninteractive
    (pdf-tools-install))
  (setq-default pdf-view-display-size 'fit-page))
   #+END_SRC

** elfeed
   :PROPERTIES:
   :CREATED:  [2019-06-28 Fri 16:56]
   :END:
   #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-elfeed.el
(use-package elfeed)
   #+END_SRC
** torus
   :PROPERTIES:
   :CREATED:  [2019-06-28 Fri 16:56]
   :END:
   #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-torus.el
(use-package torus
  :defer 0.1
  :bind-keymap ("C-x t" . torus-map)
  :bind (
         :map torus-map
         ("t" . torus-copy-to-circle))
  :hook ((emacs-startup . torus-start)
         (kill-emacs . torus-quit))
  :custom (
           (torus-binding-level 1)
           (torus-verbosity 1)
           (torus-dirname (concat user-emacs-directory (file-name-as-directory "torus")))
           (torus-load-on-startup t)
           (torus-save-on-exit t)
           (torus-autoread-file (concat torus-dirname "last.el"))
           (torus-autowrite-file torus-autoread-file)
           (torus-backup-number 5)
           (torus-history-maximum-elements 30)
           (torus-maximum-horizontal-split 3)
           (torus-maximum-vertical-split 4)
           (torus-display-tab-bar t)
           (torus-separator-torus-circle " >> ")
           (torus-separator-circle-location " > ")
           (torus-prefix-separator "/")
           (torus-join-separator " & "))
  :config
  (torus-init)
  (torus-install-default-bindings)
  (defun torus-read (filename)
    "Read main torus variables from FILENAME as Lisp code."
    (interactive
     (list
      (read-file-name
       "Torus file : "
       (file-name-as-directory torus-dirname))))
    (let*
        ((file-basename (file-name-nondirectory filename))
         (minus-len-ext (- (min (length torus-extension)
                                (length filename))))
         (buffer))
      (unless (equal (cl-subseq filename minus-len-ext) torus-extension)
        (setq filename (concat filename torus-extension)))
      (when (torus--update-input-history file-basename)
        (if (file-exists-p filename)
            (progn
              (setq buffer (find-file-noselect filename))
              (eval-buffer buffer)
              (kill-buffer buffer))
          (message "File %s does not exist." filename))))
    ;; Also saved in file
                                        ;(torus--update-meta)
                                        ;(torus--build-index)
                                        ;(torus--build-meta-index)
    (torus--jump))
  (setq torus-prefix-key (kbd "C-x t"))

  )

   #+END_SRC

** dumb-jump
   :PROPERTIES:
   :CREATED:  [2019-06-28 Fri 16:56]
   :END:
   #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-dumb-jump.el
(use-package dumb-jump)
   #+END_SRC

   #+results:

** desktop-environment
   :PROPERTIES:
   :CREATED:  [2019-06-28 Fri 16:56]
   :END:
   #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-desktop-environment.el
(use-package desktop-environment
  :config
  (setq desktop-environment-screenshot-partial-command "scrot -s screenshot.png")
  (setq desktop-environment-screenshot-directory "~/Pictures"))

   #+END_SRC
** json-mode
   :PROPERTIES:
   :CREATED:  [2019-06-28 Fri 16:56]
   :END:
   #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-json-mode.el
(use-package json-mode)
   #+END_SRC

   #+results:

** web-beautify
   :PROPERTIES:
   :CREATED:  [2019-06-28 Fri 16:56]
   :END:
   #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-web-beautify.el
(use-package web-beautify)
   #+END_SRC

   #+results:

** web-mode
   :PROPERTIES:
   :CREATED:  [2019-06-28 Fri 16:56]
   :END:
   #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/modules/module-web-mode.el
(use-package web-mode)
   #+END_SRC

   #+results:

* Helpers
** org
   :PROPERTIES:
   :CREATED:  [2019-06-28 Fri 16:56]
   :END:
*** org-contrib-autoloads
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/helpers/helper-org.el
(after "org-contrib-autoloads"
    #+END_SRC
*** org-id
    :PROPERTIES:
    :CREATED:  [2019-06-28 Fri 09:50]
    :END:
    :LOGBOOK:
    - CLOSING NOTE [2019-06-28 Fri 09:50]
    :END:
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/helpers/helper-org.el
(defun my/org-add-ids-to-headlines-in-file ()
  "Add CUSTOM_ID properties to all headlines in the
      current file which do not already have one."
  (interactive)
  (org-map-entries (lambda () (my/org-custom-id-get (point) 'create))))

(defun my/org-custom-id-get (&optional pom create prefix)
  "Get the CUSTOM_ID property of the entry at point-or-marker POM.
      If POM is nil, refer to the entry at point. If the entry does
      not have an CUSTOM_ID, the function returns nil. However, when
      CREATE is non nil, create a CUSTOM_ID if none is present
      already. PREFIX will be passed through to `org-id-new'. In any
      case, the CUSTOM_ID of the entry is returned."
  (interactive)
  (org-with-point-at pom
    (let ((id (org-entry-get nil "EXPORT_FILE_NAME")))
      (cond
       ((and id (stringp id) (string-match "\\S-" id))
        id)
       (create
        (setq id (org-id-new (concat prefix "h")))
        (org-entry-put pom "EXPORT_FILENAME" id)
        (org-id-add-location id (buffer-file-name (buffer-base-buffer)))
        id)))))
    #+END_SRC
*** org-mode-hooks
    :PROPERTIES:
    :CREATED:  [2019-06-28 Fri 09:50]
    :END:
    :LOGBOOK:
    - CLOSING NOTE [2019-06-28 Fri 09:50]
    :END:
    #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/helpers/helper-org.el
   (defun my-org-mode-hooks ()
     (visual-line-mode)
     (turn-on-auto-fill)
     (turn-on-flyspell)
     (outline-minor-mode))

  (defvar my-cpp-other-file-alist
    '(("\\.org\\'" (".org_archive"))
      ))

  (setq-default ff-other-file-alist 'my-cpp-other-file-alist)

  (defun my/insert-created-timestamp()
    "Insert a CREATED property using org-expiry.el for TODO entries"
    (org-entry-put nil "CREATED" (format-time-string "<%Y-%m-%d %a %H:%M>"))
    (org-expiry-insert-created)
    (org-back-to-heading)
    (org-end-of-line)
    (insert " "))

  (add-hook 'org-capture-before-finalize-hook 'my/insert-created-timestamp)
  (add-hook 'org-capture-prepare-finalize-hook 'org-id-store-link)


   #+END_SRC
*** org-log
    :PROPERTIES:
    :CREATED:  [2019-06-28 Fri 09:50]
    :END:
     :LOGBOOK:
     - CLOSING NOTE [2019-06-28 Fri 09:50]
     :END:
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/helpers/helper-org.el
;   (add-to-list 'org-log-note-headings
;                '(property . "Property %-12s from %-12S %t"))

   (defun my/org-property-change-note (prop val)
     (message (concat "Changing " prop " from \n" val))
     (if (not 'my/org-property-previous-val)
         (if (not (member prop my/org-property-ignored-properties))
         (org-add-log-setup 'property prop my/org-property-previous-val))))


   (defun org-add-log-note (&optional _purpose)
     "Pop up a window for taking a note, and add this note later."
     (remove-hook 'post-command-hook 'org-add-log-note)
     (setq org-log-note-window-configuration (current-window-configuration))
     (delete-other-windows)
     (move-marker org-log-note-return-to (point))
     (pop-to-buffer-same-window (marker-buffer org-log-note-marker))
     (goto-char org-log-note-marker)
     (org-switch-to-buffer-other-window "*Org Note*")
     (erase-buffer)
     (if (memq org-log-note-how '(time state))
         (org-store-log-note)
       (let ((org-inhibit-startup t)) (org-mode))
       (insert (format "# Insert note for %s.
   # Finish with C-c C-c, or cancel with C-c C-k.\n\n"
                       (cond
                        ((eq org-log-note-purpose 'clock-out) "stopped clock")
                        ((eq org-log-note-purpose 'done)  "closed todo item")
                        ((eq org-log-note-purpose 'state)
                         (format "state change from \"%s\" to \"%s\""
                                 (or org-log-note-previous-state "")
                                 (or org-log-note-state "")))
                        ((eq org-log-note-purpose 'reschedule)
                         "rescheduling")
                        ((eq org-log-note-purpose 'delschedule)
                         "no longer scheduled")
                        ((eq org-log-note-purpose 'redeadline)
                         "changing deadline")
                        ((eq org-log-note-purpose 'deldeadline)
                         "removing deadline")
                        ((eq org-log-note-purpose 'refile)
                         "refiling")
                        ((eq org-log-note-purpose 'note)
                         "this entry")
                        ((eq org-log-note-purpose 'property)
                         (format "\"%s\" property change from \"%s\""
                                 (or org-log-note-state "")
                                 (or org-log-note-previous-state "")))
                        (t (error "This should not happen")))))
       (when org-log-note-extra (insert org-log-note-extra))
       (setq-local org-finish-function 'org-store-log-note)
       (run-hooks 'org-log-buffer-setup-hook)))

   (add-hook 'org-property-changed-functions 'my/org-property-change-note)

   (defun my/org-insert-link-all ()
     (interactive)
     (while org-stored-links
       (with-simulated-input "RET RET"
         (org-insert-link))
       (if (last org-stored-links)
           (progn
             (if (org-in-item-p)
                 (org-insert-item)
               (insert ", "))))))


   ;; Record time and note when a task is completed
;   (setq org-log-done 'note)

   ;; Record time and note when the scheduled date of a task is modified
   (setq org-log-reschedule 'note)


  #+END_SRC

*** org-archive
    :PROPERTIES:
    :CREATED:  [2019-06-28 Fri 09:50]
    :END:
     :LOGBOOK:
     - CLOSING NOTE [2019-06-28 Fri 09:50]
     :END:
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/helpers/helper-org.el
   (defun org-archive-done-tasks ()
     (interactive)
     (org-map-entries 'org-archive-subtree "/DONE" 'file))

   #+END_SRC
*** org-insert-link
    :PROPERTIES:
    :CREATED:  [2019-06-28 Fri 09:50]
    :END:
     :LOGBOOK:
     - CLOSING NOTE [2019-06-28 Fri 09:50]
     :END:
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/helpers/helper-org.el
   (defun org-insert-link-with-default-description (file-name)
     (interactive (list (read-file-name "File: ")))
     (org-insert-link file-name file-name (file-name-nondirectory file-name)))

   #+END_SRC
*** export-headlines
    :PROPERTIES:
    :CREATED:  [2019-06-28 Fri 09:50]
    :END:
     :LOGBOOK:
     - CLOSING NOTE [2019-06-28 Fri 09:50]
     :END:
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/helpers/helper-org.el
   (defun my/org-export-headlines-to-org ()
     "Export all subtrees that are *not* tagged with :noexport: to
   separate files.

   Subtrees that do not have the :EXPORT_FILE_NAME: property set
   are exported to a filename derived from the headline text."
     (interactive)
                                           ;  (save-buffer)
     (let ((modifiedp (buffer-modified-p)))
       (save-excursion
         (goto-char (point-min))
         (goto-char (re-search-forward "^*"))
         (set-mark (line-beginning-position))
         (goto-char (point-max))
         (org-map-entries
          (lambda ()
            (let ((export-file (org-entry-get (point) "EXPORT_FILE_NAME")))
              (unless export-file
                (org-set-property
                 "EXPORT_FILE_NAME"
                 (replace-regexp-in-string " " "_" (nth 4 (org-heading-components)))))
              (deactivate-mark)
              (org-org-export-to-org nil t)
              (unless export-file (org-delete-property "EXPORT_FILE_NAME"))
              (set-buffer-modified-p modifiedp)))
          "-noexport" 'region-start-level))))

   #+END_SRC
*** quick capture
    :PROPERTIES:
    :CREATED:  [2019-06-28 Fri 09:50]
    :END:
      :LOGBOOK:
      - CLOSING NOTE [2019-06-28 Fri 09:50]
      :END:
 #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/helpers/helper-org.el
   (defun my/org-capture-task ()
      (interactive)
      (org-capture nil "t"))

    (defun my/org-capture-note ()
      (interactive)
      (org-capture nil "n"))

    (defun my/org-capture-appt ()
      (interactive)
      (org-capture nil "a"))

    (defun my/org-capture-log ()
      (interactive)
      (org-capture nil "l"))

    (defun my/org-capture-journal ()
      (interactive)
      (org-capture nil "j"))

#+END_SRC
*** org-tree-open-in-right-frame
    :PROPERTIES:
    :CREATED:  [2019-06-28 Fri 09:50]
    :END:
     :LOGBOOK:
     - CLOSING NOTE [2019-06-28 Fri 09:50]
     :END:
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/helpers/helper-org.el
   (defun org-tree-open-in-right-frame ()
     (interactive)
     (org-tree-to-indirect-buffer)
     (windmove-right))

  #+END_SRC

*** autoload-ends
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/helpers/helper-org.el
 )
#+END_SRC

** exwm
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/helpers/helper-exwm.el
(defun my/switch-to-last-buffer ()
    "Switch to last open buffer in current window."
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer) 1)))

  (defun ivy-ignore-exwm-buffers (str)
    (let ((buf (get-buffer str)))
      (when buf
        (with-current-buffer buf
          (or
           (file-remote-p (or (buffer-file-name) default-directory))
           (eq major-mode 'exwm-mode))))))

  (defun ivy-ignore-non-exwm-buffers (str)
    (let ((buf (get-buffer str)))
      (if buf
          (with-current-buffer buf
            (or
             (file-remote-p (or (buffer-file-name) default-directory))
             (not (eq major-mode 'exwm-mode))))
        t)))

  (defun ivy-switch-buffer-exwm ()
    "Like ivy-switch-buffer but only shows EXWM buffers."
    (interactive)
    (let ((ivy-ignore-buffers (append ivy-ignore-buffers '(ivy-ignore-non-exwm-buffers))))
      (ivy-switch-buffer)))

  (defun ivy-switch-buffer-non-exwm ()
    "Like ivy-switch-buffer but hides all EXWM buffers."
    (interactive)
    (let ((ivy-ignore-buffers (append ivy-ignore-buffers '(ivy-ignore-exwm-buffers))))
      (ivy-switch-buffer)))

#+END_SRC
* Activities
** org
   :PROPERTIES:
   :CREATED:  [2019-06-28 Fri 09:51]
   :END:
   :LOGBOOK:
   - CLOSING NOTE [2019-06-28 Fri 09:51]
   :END:
*** org-contrib-autoloads
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org.el
(after "org-contrib-autoloads"
#+END_SRC
*** org-todo
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org.el
  ;; Keep tasks with dates on the global todo lists
  (setq org-agenda-todo-ignore-with-date nil)

  ;; Keep tasks with deadlines on the global todo lists
  (setq org-agenda-todo-ignore-deadlines nil)

  ;; Keep tasks with scheduled dates on the global todo lists
  (setq org-agenda-todo-ignore-scheduled nil)

  ;; Keep tasks with timestamps on the global todo lists
  (setq org-agenda-todo-ignore-timestamp nil)

  ;; Remove completed deadline tasks from the agenda view
  (setq org-agenda-skip-deadline-if-done nil)

  ;; Remove completed scheduled tasks from the agenda view
  (setq org-agenda-skip-scheduled-if-done nil)

  ;; Remove completed items from search results
  (setq org-agenda-skip-timestamp-if-done nil)

  ;; Skip scheduled items if they are repeated beyond the current deadline.
  (setq org-agenda-skip-scheduled-if-deadline-is-shown  (quote repeated-after-deadline))

  (setq org-agenda-include-diary nil)
  (setq org-agenda-insert-diary-extract-time t)

  (setq org-default-notes-file "~/org/notes/inbox.org")

  ;; =TODO= state keywords and colour settings:
  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                (sequence "WAITING(w)" "HOLD(h)" "DELEGATE(D)" "|" "CANCELLED(c@/!)" "MEETING" "SCHEDULED")
                (sequence "ACTIVE(a)" "|" "DISABLED(i)")
                )))

  ;; ;; TODO Other todo keywords doesn't have appropriate faces yet. They should
  ;; ;; have faces similar to spacemacs defaults.
  (setq org-todo-keyword-faces
        (quote (("TODO" :foreground "red" :weight bold)
                ("NEXT" :foreground "#007cee" :weight bold)
                ("DONE" :foreground "forest green" :weight bold)
                ("WAITING" :foreground "orange" :weight bold)
                ("DELEGATE" :foreground "purple" :weight bold)
                ("HOLD" :foreground "magenta" :weight bold)
                ("CANCELLED" :foreground "red" :weight bold)
                ("MEETING" :foreground "forest green" :weight bold)
                ("SCHEDULED" :foreground "forest green" :weight bold))))

  (setq org-use-fast-todo-selection t)

  ;; This cycles through the todo states but skips setting timestamps and
  ;; entering notes which is very convenient when all you want to do is fix
  ;; up the status of an entry.
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)

  (setq org-todo-state-tags-triggers
        (quote (("CANCELLED" ("CANCELLED" . t))
                ("WAITING" ("WAITING" . t))
                ("HOLD" ("WAITING") ("HOLD" . t))
                (done ("WAITING") ("HOLD"))
                ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))

#+END_SRC
*** org-refile
    :PROPERTIES:
    :CREATED:  [2019-06-19 Wed 17:53]
    :END:
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org.el
  (setq org-refile-targets (quote ((nil :maxlevel . 9)
                                   (org-agenda-files :maxlevel . 9)
                                   ("~/.personal.d/personal-config.org" :maxlevel . 9)
                                   ("~/.emacs.d/config.org" :maxlevel . 9)
                                   )))

  (setq org-refile-use-outline-path 'file
        org-indent-indentation-per-level nil
        org-outline-path-complete-in-steps nil)


  ;; Allow refile to create parent tasks with confirmation
  (setq org-refile-allow-creating-parent-nodes (quote confirm))

  (setq org-refile-target-verify-function 'bh/verify-refile-target)

#+END_SRC
*** org-clock
    :PROPERTIES:
    :CREATED:  [2019-06-19 Wed 17:53]
    :END:
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org.el
  (setq org-agenda-clock-consistency-checks
        (quote (:max-duration "4:00"
                              :min-duration 0
                              :max-gap 0
                              :gap-ok-around ("4:00"))))

  ;; Agenda clock report parameters
  (setq org-agenda-clockreport-parameter-plist
        (quote (:link t :maxlevel 5 :fileskip0 t :compact t :narrow 80)))

  ;; Show lot of clocking history so it's easy to pick items off the C-F11 list
  (setq org-clock-history-length 23)
  ;; Resume clocking task on clock-in if the clock is open
  (setq org-clock-in-resume t)
  ;; Change tasks to NEXT when clocking in
  (setq org-clock-in-switch-to-state 'bh/clock-in-to-next)
  ;; Separate drawers for clocking and logs
  (setq org-drawers (quote ("PROPERTIES" "LOGBOOK")))
  ;; Save clock data and state changes and notes in the LOGBOOK drawer
  (setq org-clock-into-drawer t)

  (setq org-log-into-drawer t)
  ;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
  (setq org-clock-out-remove-zero-time-clocks t)
  ;; Clock out when moving task to a done state
  (setq org-clock-out-when-done t)
  ;; Save the running clock and all clock history when exiting Emacs, load it on startup
  (setq org-clock-persist t)
  ;; Do not prompt to resume an active clock
  (setq org-clock-persist-query-resume nil)
  ;; Enable auto clock resolution for finding open clocks
                                          ;(setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
  (setq org-clock-auto-clock-resolution nil)
  ;; Include current clocking task in clock reports
  (setq org-clock-report-include-clocking-task t)
  ;; Resolve open clocks if the user is idle for more than 10 minutes.
  (setq org-clock-idle-time 10)
  ;;
  ;; Resume clocking task when emacs is restarted
  (org-clock-persistence-insinuate)

  (setq bh/keep-clock-running nil)


  (setq org-time-stamp-rounding-minutes (quote (1 1)))
  ;; ;; Sometimes I change tasks I'm clocking quickly - this removes clocked
  ;; ;; tasks with 0:00 duration
  ;; (setq org-clock-out-remove-zero-time-clocks t)

  ;; Set default column view headings: Task Effort Clock_Summary
  (setq org-columns-default-format
        "%1PRIORITY %50ITEM %13AREA %10DEADLINE %50OUTCOME %10Effort(Effort){:} %10CLOCKSUM")
  ;; global Effort estimate values
  ;; global STYLE property values for completion
  (setq org-global-properties (quote (("Effort_ALL" . "0:15 0:30 0:45 1:00 2:00 3:00 4:00 5:00 6:00 0:00")
                                      ("STYLE_ALL" . "habit"))))

#+END_SRC
*** org-tags
    :PROPERTIES:
    :CREATED:  [2019-06-19 Wed 17:53]
    :END:
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org.el
  (setq org-fast-tag-selection-include-todo t)

  (setq org-tag-alist (quote (("WAITING" . ?w)
                              ("HOLD" . ?h)
                              ("NOTE" . ?n)
                              ("CANCELLED" . ?c)
                              ("FLAGGED" . ??))))

  (setq org-agenda-hide-tags-regexp "noexport\\|HOLD\\|REFILE\\|ARCHIVE\\|NOW\\|ignore\\|WAITING\\|nobrain\\|connect\\|clarify\\|capture\\|ATTACH")

  ;; Allow setting single tags without the menu
  (setq org-fast-tag-selection-single-key (quote expert))


#+END_SRC
*** org-expiry
    :PROPERTIES:
    :CREATED:  [2019-06-19 Wed 17:53]
    :END:
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org.el
    (require 'org-expiry)

    (setq org-expiry-created-property-name "CREATED")

    (setq org-expiry-inactive-timestamps t)
    (org-expiry-insinuate)

    (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
#+END_SRC
*** org-babel
    :PROPERTIES:
    :CREATED:  [2019-06-19 Wed 17:53]
    :END:
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org.el
  (setq org-confirm-babel-evaluate nil
        org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-src-preserve-indentation t
        org-src-window-setup 'current-window)

  (setq org-modules '(org-habit
                      org-timer
                      org-collector))

  (org-babel-do-load-languages
   (quote org-babel-load-languages)
   (quote ((emacs-lisp . t)
           (scheme . t)
           (dot . t)
           (ditaa . t)
           (python . t)
           (gnuplot . t)
           (shell . t)
           (ledger . t)
           (org . t)
           (plantuml . t)
           (latex . t))))

  (defadvice org-babel-execute-src-block (around load-language nil activate)
    "Load language if needed"
    (let ((language (org-element-property :language (org-element-at-point))))
      (unless (cdr (assoc (intern language) org-babel-load-languages))
        (add-to-list 'org-babel-load-languages (cons (intern language) t))
        (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
      ad-do-it))



  (defun bh/display-inline-images ()
    (condition-case nil
        (org-display-inline-images)
      (error nil)))

  (add-hook 'org-babel-after-execute-hook 'bh/display-inline-images 'append)



  (setq org-confirm-babel-evaluate nil)

  (setq org-babel-results-keyword "results")

  (setq org-ditaa-jar-path "~/.emacs.d/ditaa0_9/ditaa0_9.jar")


#+END_SRC
*** org-habit
    :PROPERTIES:
    :CREATED:  [2019-06-19 Wed 17:53]
    :END:
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org.el
(require 'org-habit)

  (setq org-habit-show-habits-only-for-today t)
  (setq org-agenda-tags-column -100
        org-habit-graph-column 45
        org-habit-preceding-days 28
        org-agenda-start-with-log-mode nil)

  (setq org-habit-show-habits t)

#+END_SRC
*** org-agenda
    :PROPERTIES:
    :CREATED:  [2019-06-19 Wed 17:47]
    :END:
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org.el
(setq org-agenda-entry-text-maxlines 10)

(setq org-agenda-entry-text-leaders " ")

(setq org-agenda-inhibit-startup t)

(setq org-agenda-use-tag-inheritance nil)

(setq org-agenda-files (apply 'append
                              (mapcar
                               (lambda (directory)
                                 (directory-files-recursively
                                  directory org-agenda-file-regexp))
                               '("~/org/agenda/" ))))

(setq org-agenda-timegrid-use-ampm t)

(setq org-agenda-use-time-grid nil)


(setq org-show-entry-below (quote ((default))))

;; Tags with fast selection keys
;; Disable the default org-mode stuck projects agenda view
(setq org-stuck-projects (quote ("" nil nil "")))

;; Limit restriction lock highlighting to the headline only
(setq org-agenda-restriction-lock-highlight-subtree nil)

;; Always hilight the current agenda line
(add-hook 'org-agenda-mode-hook
          '(lambda () (hl-line-mode 1))
          'append)



(setq org-agenda-auto-exclude-function 'bh/org-auto-exclude-function)


;; For tag searches ignore tasks with scheduled and deadline dates
(setq org-agenda-tags-todo-honor-ignore-options t)



(setq org-agenda-inhibit-startup t)

(setq org-agenda-span 'week)

(setq org-agenda-follow-indirect t)

(defvar org-timeline-files nil
  "The files to be included in `org-timeline-all-files'. Follows
          the same rules as `org-agenda-files'")

(setq org-timeline-files '("~/org/agenda/archive"))


;; Overwrite the current window with the agenda
(setq org-agenda-window-setup 'current-window)

;; Do not dim blocked tasks
(setq org-agenda-dim-blocked-tasks nil)

;; Compact the block agenda view
(setq org-agenda-compact-blocks t)

;; Agenda clock report parameters
(setq org-agenda-clockreport-parameter-plist
      (quote (:link t :maxlevel 5 :fileskip0 t :compact nil :narrow 80)))

;; Agenda log mode items to display (closed and state changes by default)
(setq org-agenda-log-mode-items (quote (closed state clock)))

;; Keep tasks with dates on the global todo lists
(setq org-agenda-todo-ignore-with-date nil)

;; Keep tasks with deadlines on the global todo lists
(setq org-agenda-todo-ignore-deadlines nil)

;; Keep tasks with scheduled dates on the global todo lists
(setq org-agenda-todo-ignore-scheduled nil)

;; Keep tasks with timestamps on the global todo lists
(setq org-agenda-todo-ignore-timestamp nil)

;; Remove completed deadline tasks from the agenda view
(setq org-agenda-skip-deadline-if-done t)

;; Remove completed scheduled tasks from the agenda view
(setq org-agenda-skip-scheduled-if-done t)

;; Remove completed items from search results
(setq org-agenda-skip-timestamp-if-done t)

;; Include agenda archive files when searching for things
(setq org-agenda-text-search-extra-files (quote (agenda-archives)))

;; Show all future entries for repeating tasks
(setq org-agenda-repeating-timestamp-show-all t)

;; Show all agenda dates - even if they are empty
(setq org-agenda-show-all-dates t)

;; Start the weekly agenda on Monday
(setq org-agenda-start-on-weekday 1)

(setq org-default-priority ?C)

(defun set-agenda/personal ()
  (interactive)
  (setq org-agenda-files (apply 'append
                                (mapcar
                                 (lambda (directory)
                                   (directory-files-recursively
                                    directory org-agenda-file-regexp))
                                 '("~/org/agenda/" )))))

(defun set-agenda/projects ()
  (interactive)
  (setq org-agenda-files (apply 'append
                                (mapcar
                                 (lambda (directory)
                                   (directory-files-recursively
                                    directory org-agenda-file-regexp))
                                 '("~/org/projects/" )))))


(defun agenda/calendar ()
  (interactive)
  (org-agenda nil "S"))

(defun my/agenda ()
  (interactive)
  (org-agenda nil " "))

(defun agenda/waiting ()
  (interactive)
  (org-agenda nil "w"))

(defun agenda/someday ()
  (interactive)
  (org-agenda nil "s"))

(defun agenda/next-tasks ()
  (interactive)
  (org-agenda nil "n"))



;; Use sticky agenda's so they persist
;;(setq org-agenda-sticky t)

;; Custom agenda command definitions
(setq org-agenda-custom-commands
      (quote (("h" "Habits" tags-todo "STYLE=\"habit\""
               ((org-agenda-overriding-header "Habits")
                (org-agenda-sorting-strategy
                 '(todo-state-down effort-up category-keep))))

              ("S" "Schedule" agenda "" nil)




              ("s" "Someday/Maybe"
               ((tags-todo "-CANCELLED/!"
                           ((org-agenda-overriding-header "Stuck Projects")
                            (org-agenda-skip-function 'bh/skip-non-stuck-projects)
                            (org-agenda-sorting-strategy
                             '(category-keep))))

                                  (tags-todo "HOLD/!"
                             ((org-agenda-overriding-header (concat "Someday/Maybe"
                                                                    (if bh/hide-scheduled-and-waiting-next-tasks
                                                                        ""
                                                                      " (including WAITING and SCHEDULED tasks)")))
                              (org-agenda-skip-function 'bh/skip-non-tasks)
                              (org-tags-match-list-sublevels nil)
                              (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                              (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                              (org-agenda-sorting-strategy
                               '(todo-state-down
                                 category-keep))))) nil)

                (" " "Agenda"
                 ((tags-todo "-HOLD-CANCELLED/!"
                             ((org-agenda-overriding-header "Projects")
                              (org-agenda-skip-function 'bh/skip-non-projects)
                              (org-tags-match-list-sublevels 'indented)
                              (org-agenda-sorting-strategy
                               '(priority-down
                                 category-keep))))

                  (tags-todo "-CANCELLED/!NEXT"
                             ((org-agenda-overriding-header (concat "Next Tasks"
                                                                    (if bh/hide-scheduled-and-waiting-next-tasks
                                                                        ""
                                                                      " (including WAITING and SCHEDULED tasks)")))
                              (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
                              (org-tags-match-list-sublevels t)
                              (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                              (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                              (org-agenda-sorting-strategy
                               '(priority-down effort-up category-keep))))

                  (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                             ((org-agenda-overriding-header (concat "Subtasks"
                                                                    (if bh/hide-scheduled-and-waiting-next-tasks
                                                                        ""
                                                                      " (including WAITING and SCHEDULED tasks)")))
                              (org-agenda-skip-function 'bh/skip-non-project-tasks)
                              (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                              (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                              (org-agenda-sorting-strategy
                               '(category-keep))))


                  (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                             ((org-agenda-overriding-header (concat "Actions"
                                                                    (if bh/hide-scheduled-and-waiting-next-tasks
                                                                        ""
                                                                      " (including WAITING and SCHEDULED tasks)")))
                              (org-agenda-skip-function 'bh/skip-project-tasks)
                              (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                              (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                              (org-agenda-sorting-strategy
                               '(todo-state-down
                                 category-keep))))


                  ) nil)

                ("c" "Completed" ((tags "-REFILE/+DONE"
                                        ((org-agenda-overriding-header "Completed Tasks")
                                         (org-tags-match-list-sublevels nil)))))

                ("n" "Next Tasks" ((tags "-REFILE/+NEXT"
                                        ((org-agenda-overriding-header "Next Tasks")
                                         (org-tags-match-list-sublevels nil)))))

                ("w" "Waiting" ((tags-todo "WAITING"
                             ((org-agenda-overriding-header (concat "Waiting and Postponed"
                                                                    (if bh/hide-scheduled-and-waiting-next-tasks
                                                                        ""
                                                                      " (including WAITING and SCHEDULED tasks)")))
                              (org-agenda-skip-function 'bh/skip-non-tasks)
                              (org-tags-match-list-sublevels nil)
                              (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                              (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                              (org-agenda-sorting-strategy
                               '(todo-state-down
                                 category-keep))))))

                )))

             ;; Limit restriction lock highlighting to the headline only
             (setq org-agenda-restriction-lock-highlight-subtree nil)


             ;; Sorting order for tasks on the agenda
             (setq org-agenda-sorting-strategy
                   (quote ((agenda habit-down time-up user-defined-up effort-up category-keep)
                           (todo category-up effort-up)
                           (tags category-up effort-up)
                           (search category-up))))


             ;; Display tags farther right
             (setq org-agenda-tags-column -102)

             ;;
             ;; Agenda sorting functions
             ;;
             (setq org-agenda-cmp-user-defined 'bh/agenda-sort)

             (defun org-agenda-current-subtree-or-region (only-todos)
               "Display an agenda view for the current subtree or region.
    With prefix, display only TODO-keyword items."
               (interactive "P")
               (let ((starting-point (point))
                     header)
                 (with-current-buffer (or (buffer-base-buffer (current-buffer))
                                          (current-buffer))
                   (if (use-region-p)
                       (progn
                         (setq header "Region")
                         (put 'org-agenda-files 'org-restrict (list (buffer-file-name (current-buffer))))
                         (setq org-agenda-restrict (current-buffer))
                         (move-marker org-agenda-restrict-begin (region-beginning))
                         (move-marker org-agenda-restrict-end
                                      (save-excursion
                                        ;; If point is at beginning of line, include
                                        ;; heading on that line by moving forward 1.
                                        (goto-char (1+ (region-end)))
                                        (org-end-of-subtree))))
                     ;; No region; restrict to subtree.
                     (save-excursion
                       (save-restriction
                         ;; In case the command was called from an indirect buffer, set point
                         ;; in the base buffer to the same position while setting restriction.
                         (widen)
                         (goto-char starting-point)
                         (setq header "Subtree")
                         (org-agenda-set-restriction-lock))))
                   ;; NOTE: Unlike other agenda commands, binding `org-agenda-sorting-strategy'
                   ;; around `org-search-view' seems to have no effect.
                   (let ((org-agenda-sorting-strategy '(priority-down timestamp-up))
                         (org-agenda-overriding-header header)))
                   (org-agenda nil " "))
                 (org-agenda-remove-restriction-lock t)
                 (message nil)))

             (setq appt-display-diary nil)
             (appt-activate t)
             (setq appt-display-interval 5)
             (setq appt-message-warning-time 15)
             (setq appt-display-mode-line t)
             (display-time)
             (setq appt-display-format 'window)
             (setq appt-disp-window-function #'ora-appt-display)
             (run-at-time "1 hour" 3600 #'ora-org-agenda-to-appt)
             (remove-hook 'org-finalize-agenda-hook #'ora-org-agenda-to-appt)
             (add-hook 'org-finalize-agenda-hook #'ora-org-agenda-to-appt)

             (defun ora-appt-display (min-to-app new-time msg)
               "our little façade-function for ora-org-popup"
               (ora-org-popup (format "Appointment in %s minute(s)" min-to-app) msg
                              "~/Pictures/Icons/Gnome-appointment-soon.png") )

             (defun ora-org-agenda-to-appt ()
               "Erase all reminders and rebuild reminders for today from the agenda"
               (interactive)
               ;; (setq appt-time-msg-list nil)
               (org-agenda-to-appt))


             (defun ora-start-process (cmd)
               (start-process
                cmd nil shell-file-name
                shell-command-switch
                (format "nohup 1>/dev/null 2>/dev/null %s" cmd)))

             (defun ora-org-popup (title msg &optional icon sound)
               "Show a popup if we're on X, or echo it otherwise; TITLE is the title
              of the message, MSG is the context. Optionally, you can provide an ICON and
              a sound to be played"
               (interactive)
               (if (eq window-system 'x)
                   (progn
                     (notifications-notify
                      :title title
                      :body msg
                      :app-icon icon
                      :urgency 'low)
                     (ora-start-process
                      (concat "mplayer -really-quiet " sound " 2> /dev/null")))
                 ;; text only version
                 (message (concat title ": " msg))))

             (defun bh/org-agenda-to-appt ()
               (interactive)
               (setq appt-time-msg-list nil)
               (org-agenda-to-appt))

             ;; Rebuild the reminders everytime the agenda is displayed
             (add-hook 'org-finalize-agenda-hook 'bh/org-agenda-to-appt 'append)

             ;; Activate appointments so we get notifications,
             ;; but only run this when emacs is idle for 15 seconds
             (run-with-idle-timer 15 nil (lambda () (appt-activate t)))

             ;; If we leave Emacs running overnight - reset the appointments one minute after midnight
             (run-at-time "24:01" nil 'bh/org-agenda-to-appt)




 #+END_SRC
*** org-directory
    :PROPERTIES:
    :CREATED:  [2019-06-19 Wed 17:53]
    :END:
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org.el
  (setq org-agenda-directory "~/org/agenda/")
  (setq org-ref-directory "~/org/notes/")
  (setq org-meta-directory "~/org/meta/")

  (setq org-attach-directory "~/org/notes/data/")

  (setq org-file-inbox (concat org-agenda-directory      "inbox.org"))
  (setq org-file-journal (concat org-agenda-directory    "log.org"))
    (setq org-file-reference (concat org-ref-directory  "reference.org"))
  (setq org-file-calendar (concat org-agenda-directory   "calendar.org"))

 #+END_SRC
*** org-archive
    :PROPERTIES:
    :CREATED:  [2019-06-19 Wed 17:53]
    :END:
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org.el
  (setq org-archive-mark-done nil)

  (setq org-archive-location "~/org/agenda/log.org::datetree/* Completed Tasks")



#+END_SRC
*** org-capture
    :PROPERTIES:
    :ID:       b0c2f0a6-9fc8-4745-9b77-00af7eeb7c7a
    :CREATED:  [2019-06-19 Wed 17:53]
    :END:
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org.el
    (setq org-capture-templates
          (quote (
          ("a" "Appointment" entry (file+headline "~/org/agenda/calendar.org") (file "~/.emacs.d/templates/event.tmplt")  :clock-in t :clock-resume t)
          ("t" "Task" entry (file org-file-inbox) (file "~/.emacs.d/templates/todo.tmplt") :clock-in t :clock-resume t)
          ("n" "Note" entry (file org-file-inbox) (file "~/.emacs.d/templates/note.tmplt") :clock-in t :clock-resume t)
          ("j" "Journal" entry (file+datetree "~/org/agenda/log.org")  "** %^{Title}  :journal: \n\n %?" :clock-in t :clock-resume t)
          )))

 #+END_SRC
*** bh functions
    :PROPERTIES:
    :CREATED:  [2019-06-19 Wed 17:53]
    :END:
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org.el
     (defmacro bh/agenda-sort-test (fn a b)
        "Test for agenda sort"
        `(cond
                                              ; if both match leave them unsorted
          ((and (apply ,fn (list ,a))
                (apply ,fn (list ,b)))
           (setq result nil))
                                              ; if a matches put a first
          ((apply ,fn (list ,a))
           (setq result -1))
                                              ; otherwise if b matches put b first
          ((apply ,fn (list ,b))
           (setq result 1))
                                              ; if none match leave them unsorted
          (t nil)))

      (defmacro bh/agenda-sort-test-num (fn compfn a b)
        `(cond
          ((apply ,fn (list ,a))
           (setq num-a (string-to-number (match-string 1 ,a)))
           (if (apply ,fn (list ,b))
               (progn
                 (setq num-b (string-to-number (match-string 1 ,b)))
                 (setq result (if (apply ,compfn (list num-a num-b))
                                  -1
                                1)))
             (setq result -1)))
          ((apply ,fn (list ,b))
           (setq result 1))
          (t nil)))

      (defun bh/agenda-sort (a b)
        "Sorting strategy for agenda items.
      Late deadlines first, then scheduled, then non-late deadlines"
        (let (result num-a num-b)
          (cond
           ;; time specific items are already sorted first by org-agenda-sorting-strategy

           ;; non-deadline and non-scheduled items next
           ((bh/agenda-sort-test 'bh/is-not-scheduled-or-deadline a b))

           ;; deadlines for today next
           ((bh/agenda-sort-test 'bh/is-due-deadline a b))

           ;; late deadlines next
           ((bh/agenda-sort-test-num 'bh/is-late-deadline '> a b))

           ;; scheduled items for today next
           ((bh/agenda-sort-test 'bh/is-scheduled-today a b))

           ;; late scheduled items next
           ((bh/agenda-sort-test-num 'bh/is-scheduled-late '> a b))

           ;; pending deadlines last
           ((bh/agenda-sort-test-num 'bh/is-pending-deadline '< a b))

           ;; finally default to unsorted
           (t (setq result nil)))
          result))

      (defun bh/is-project-p ()
        "Any task with a todo keyword subtask"
        (save-restriction
          (widen)
          (let ((has-subtask)
                (subtree-end (save-excursion (org-end-of-subtree t)))
                (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
            (save-excursion
              (forward-line 1)
              (while (and (not has-subtask)
                          (< (point) subtree-end)
                          (re-search-forward "^\*+ " subtree-end t))
                (when (member (org-get-todo-state) org-todo-keywords-1)
                  (setq has-subtask t))))
            (and is-a-task has-subtask))))

      (defun bh/is-project-subtree-p ()
        "Any task with a todo keyword that is in a project subtree.
      Callers of this function already widen the buffer view."
        (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                    (point))))
          (save-excursion
            (bh/find-project-task)
            (if (equal (point) task)
                nil
              t))))

      (defun bh/is-task-p ()
        "Any task with a todo keyword and no subtask"
        (save-restriction
          (widen)
          (let ((has-subtask)
                (subtree-end (save-excursion (org-end-of-subtree t)))
                (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
            (save-excursion
              (forward-line 1)
              (while (and (not has-subtask)
                          (< (point) subtree-end)
                          (re-search-forward "^\*+ " subtree-end t))
                (when (member (org-get-todo-state) org-todo-keywords-1)
                  (setq has-subtask t))))
            (and is-a-task (not has-subtask)))))

      (defun bh/is-subproject-p ()
        "Any task which is a subtask of another project"
        (let ((is-subproject)
              (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
          (save-excursion
            (while (and (not is-subproject) (org-up-heading-safe))
              (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
                (setq is-subproject t))))
          (and is-a-task is-subproject)))

      (defun bh/list-sublevels-for-projects-indented ()
        "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
        This is normally used by skipping functions where this variable is already local to the agenda."
        (if (marker-buffer org-agenda-restrict-begin)
            (setq org-tags-match-list-sublevels 'indented)
          (setq org-tags-match-list-sublevels nil))
        nil)

      (defun bh/list-sublevels-for-projects ()
        "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
        This is normally used by skipping functions where this variable is already local to the agenda."
        (if (marker-buffer org-agenda-restrict-begin)
            (setq org-tags-match-list-sublevels t)
          (setq org-tags-match-list-sublevels nil))
        nil)

      (defvar bh/hide-scheduled-and-waiting-next-tasks t)

      (defun bh/toggle-next-task-display ()
        (interactive)
        (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
        (when  (equal major-mode 'org-agenda-mode)
          (org-agenda-redo))
        (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

      (defun bh/skip-stuck-projects ()
        "Skip trees that are not stuck projects"
        (save-restriction
          (widen)
          (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
            (if (bh/is-project-p)
                (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                       (has-next ))
                  (save-excursion
                    (forward-line 1)
                    (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                      (unless (member "WAITING" (org-get-tags))
                        (setq has-next t))))
                  (if has-next
                      nil
                    next-headline)) ; a stuck project, has subtasks but no next task
              nil))))

      (defun bh/skip-non-stuck-projects ()
        "Skip trees that are not stuck projects"
        ;; (bh/list-sublevels-for-projects-indented)
        (save-restriction
          (widen)
          (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
            (if (bh/is-project-p)
                (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                       (has-next ))
                  (save-excursion
                    (forward-line 1)
                    (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                      (unless (member "WAITING" (org-get-tags))
                        (setq has-next t))))
                  (if has-next
                      next-headline
                    nil)) ; a stuck project, has subtasks but no next task
              next-headline))))

      (defun bh/skip-non-projects ()
        "Skip trees that are not projects"
        ;; (bh/list-sublevels-for-projects-indented)
        (if (save-excursion (bh/skip-non-stuck-projects))
            (save-restriction
              (widen)
              (let ((subtree-end (save-excursion (org-end-of-subtree t))))
                (cond
                 ((bh/is-project-p)
                  nil)
                 ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
                  nil)
                 (t
                  subtree-end))))
          (save-excursion (org-end-of-subtree t))))

      (defun bh/skip-non-tasks ()
        "Show non-project tasks.
      Skip project and sub-project tasks, habits, and project related tasks."
        (save-restriction
          (widen)
          (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
            (cond
             ((bh/is-task-p)
              nil)
             (t
              next-headline)))))

      (defun bh/skip-project-trees-and-habits ()
        "Skip trees that are projects"
        (save-restriction
          (widen)
          (let ((subtree-end (save-excursion (org-end-of-subtree t))))
            (cond
             ((bh/is-project-p)
              subtree-end)
             ((org-is-habit-p)
              subtree-end)
             (t
              nil)))))

      (defun bh/skip-projects-and-habits-and-single-tasks ()
        "Skip trees that are projects, tasks that are habits, single non-project tasks"
        (save-restriction
          (widen)
          (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
            (cond
             ((org-is-habit-p)
              next-headline)
             ((and bh/hide-scheduled-and-waiting-next-tasks
                   (member "WAITING" (org-get-tags)))
              next-headline)
             ((bh/is-project-p)
              next-headline)
             ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
              next-headline)
             (t
              nil)))))

      (defun bh/skip-project-tasks-maybe ()
        "Show tasks related to the current restriction.
      When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
      When not restricted, skip project and sub-project tasks, habits, and project related tasks."
        (save-restriction
          (widen)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (next-headline (save-excursion (or (outline-next-heading) (point-max))))
                 (limit-to-project (marker-buffer org-agenda-restrict-begin)))
            (cond
             ((bh/is-project-p)
              next-headline)
             ((org-is-habit-p)
              subtree-end)
             ((and (not limit-to-project)
                   (bh/is-project-subtree-p))
              subtree-end)
             ((and limit-to-project
                   (bh/is-project-subtree-p)
                   (member (org-get-todo-state) (list "NEXT")))
              subtree-end)
             (t
              nil)))))

      (defun bh/skip-project-tasks ()
        "Show non-project tasks.
      Skip project and sub-project tasks, habits, and project related tasks."
        (save-restriction
          (widen)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
            (cond
             ((bh/is-project-p)
              subtree-end)
             ((org-is-habit-p)
              subtree-end)
             ((bh/is-project-subtree-p)
              subtree-end)
             (t
              nil)))))

      (defun bh/skip-non-project-tasks ()
        "Show project tasks.
      Skip project and sub-project tasks, habits, and loose non-project tasks."
        (save-restriction
          (widen)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
            (cond
             ((bh/is-project-p)
              next-headline)
             ((org-is-habit-p)
              subtree-end)
             ((and (bh/is-project-subtree-p)
                   (member (org-get-todo-state) (list "NEXT")))
              subtree-end)
             ((not (bh/is-project-subtree-p))
              subtree-end)
             (t
              nil)))))

      (defun bh/skip-projects-and-habits ()
        "Skip trees that are projects and tasks that are habits"
        (save-restriction
          (widen)
          (let ((subtree-end (save-excursion (org-end-of-subtree t))))
            (cond
             ((bh/is-project-p)
              subtree-end)
             ((org-is-habit-p)
              subtree-end)
             (t
              nil)))))

      (defun bh/skip-non-subprojects ()
        "Skip trees that are not projects"
        (let ((next-headline (save-excursion (outline-next-heading))))
          (if (bh/is-subproject-p)
              nil
            next-headline)))

      ;; Show 20 minute clocking gaps. Hit "v c" in the agenda view
      (setq org-agenda-clock-consistency-checks
            '(:max-duration "4:00"
                            :min-duration 0
                            :max-gap 30
                            :gap-ok-around ("4:00" "11:00" "19:00" "20:00" "21:00")))

      (defun bh/widen ()
        (interactive)
        (if (equal major-mode 'org-agenda-mode)
            (progn
              (org-agenda-remove-restriction-lock)
              (when org-agenda-sticky
                (org-agenda-redo)))
          (widen)))

      (add-hook 'org-agenda-mode-hook
                '(lambda () (org-defkey org-agenda-mode-map "W" (lambda () (interactive) (setq bh/hide-scheduled-and-waiting-next-tasks t) (bh/widen))))
                'append)

      (defun bh/skip-non-archivable-tasks ()
        "Skip trees that are not available for archiving."
        (save-restriction
          (widen)
          ;; Consider only tasks with done todo headings as archivable candidates
          (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
                (subtree-end (save-excursion (org-end-of-subtree t))))
            (if (member (org-get-todo-state) org-todo-keywords-1)
                (if (member (org-get-todo-state) org-done-keywords)
                    (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
                           (a-month-ago (* 60 60 24 (+ daynr 1)))
                           (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                           (this-month (format-time-string "%Y-%m-" (current-time)))
                           (subtree-is-current (save-excursion
                                                 (forward-line 1)
                                                 (and (< (point) subtree-end)
                                                      (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                      (if subtree-is-current
                          subtree-end ; Has a date in this month or last month, skip it
                        nil))  ; available to archive
                  (or subtree-end (point-max)))
              next-headline))))

      (defun bh/is-not-scheduled-or-deadline (date-str)
        (and (not (bh/is-deadline date-str))
             (not (bh/is-scheduled date-str))))

      (defun bh/is-due-deadline (date-str)
        (string-match "Deadline:" date-str))

      (defun bh/is-late-deadline (date-str)
        (string-match "\\([0-9]*\\) d\. ago:" date-str))

      (defun bh/is-pending-deadline (date-str)
        (string-match "In \\([^-]*\\)d\.:" date-str))

      (defun bh/is-deadline (date-str)
        (or (bh/is-due-deadline date-str)
            (bh/is-late-deadline date-str)
            (bh/is-pending-deadline date-str)))

      (defun bh/is-scheduled (date-str)
        (or (bh/is-scheduled-today date-str)
            (bh/is-scheduled-late date-str)))

      (defun bh/is-scheduled-today (date-str)
        (string-match "Scheduled:" date-str))

      (defun bh/is-scheduled-late (date-str)
        (string-match "Sched\.\\(.*\\)x:" date-str))

      (defun bh/find-project-task ()
        "Move point to the parent (project) task if any"
        (save-restriction
          (widen)
          (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
            (while (org-up-heading-safe)
              (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
                (setq parent-task (point))))
            (goto-char parent-task)
            parent-task)))

      (defun bh/verify-refile-target ()
        "Exclude todo keywords with a done state from refile targets"
        (not (member (nth 2 (org-heading-components)) org-done-keywords)))

      (defun bh/clock-in-to-next (kw)
        "Switch a task from TODO to NEXT when clocking in.
                         Skips capture tasks, projects, and subprojects.
                         Switch projects and subprojects from NEXT back to TODO"
        (when (not (and (boundp 'org-capture-mode) org-capture-mode))
          (cond
           ((and (member (org-get-todo-state) (list "TODO"))
                 (bh/is-task-p))
            "NEXT")
           ((and (member (org-get-todo-state) (list "NEXT"))
                 (bh/is-project-p))
            "TODO"))))

#+END_SRC
*** autoloads-end
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org.el
)
#+END_SRC
** org-refiler
   :PROPERTIES:
   :CREATED:  [2019-06-28 Fri 09:51]
   :END:
   :LOGBOOK:
   - CLOSING NOTE [2019-06-28 Fri 09:51]
   :END:
*** hydra
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org-refiler.el
  (use-package hydra
    :config
#+END_SRC
*** org-refile-directly
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org-refiler.el
  (setq org-refile-use-outline-path 'file
        org-outline-path-complete-in-steps nil)

  (defun org-subtree-region ()
    "Return a list of the start and end of a subtree."
    (save-excursion
      (list (progn (org-back-to-heading) (point))
            (progn (org-end-of-subtree)  (point)))))

  (defvar org-refile-directly-show-after nil
    "When refiling directly (using the `org-refile-directly'
   function), show the destination buffer afterwards if this is set
   to `t', otherwise, just do everything in the background.")

  (defun org-refile-directly (file-dest)
    "Move the current subtree to the end of FILE-DEST.
   If SHOW-AFTER is non-nil, show the destination window,
   otherwise, this destination buffer is not shown."
    (interactive "fDestination: ")

    (defun dump-it (file contents)
      (find-file-other-window file-dest)
      (goto-char (point-max))
      (insert "\n" contents))

    (save-excursion
      (let* ((region (org-subtree-region))
             (contents (buffer-substring (first region) (second region))))
        (apply 'kill-region region)
        (if org-refile-directly-show-after
            (save-current-buffer (dump-it file-dest contents))
          (save-window-excursion (dump-it file-dest contents))))))

  #+END_SRC

*** org-boxes-workflow
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org-refiler.el
  (defun org-boxes-workflow ()
    "Load the default tasks file and start our hydra on the first task shown."
    (interactive)
    (find-file org-default-inbox-file)
    (goto-char (point-min))
    (org-next-visible-heading 1)
    (org-agenda-process))

  #+END_SRC
*** org-refile-to
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org-refiler.el
  (defun org-refile-to-incubate ()
    "Refile (move) the current Org subtree to `org-default-incubate-file'."
    (interactive)
    (org-todo "HOLD")
    (org-refile-directly org-default-incubate-file)
    (kill-line))

  (defun org-refile-to-waiting ()
    "Refile (move) the current Org subtree to `org-default-incubate-file'."
    (interactive)
    (org-todo "WAITING")

    (org-refile-directly org-default-waiting-file)
    (kill-line))

  (defun org-refile-to-calendar ()
    "Refile (move) the current Org subtree to `org-default-incubate-file'."
    (interactive)
    (org-todo "TODO")

    (org-refile-directly org-default-calendar-file)
    (kill-line))

  (defun org-refile-to-task ()
    "Refile (move) the current Org subtree to `org-default-tasks-file'."
    (interactive)
    (org-todo "TODO")

    (org-refile-directly org-default-tasks-file)
    (kill-line))

  (defun org-refile-to-projects-dir ()
    "Move the current subtree to a file in the `projects' directory."
    (interactive)
    (org-refile-subtree-to-file org-default-projects-dir))

  (defun org-refile-to-technical-dir ()
    "Move the current subtree to a file in the `technical' directory."
    (interactive)
    (org-refile-subtree-to-file org-default-technical-dir))

  (defun org-refile-to-personal-dir ()
    "Move the current subtree to a file in the `personal' directory."
    (interactive)
    (org-refile-subtree-to-file org-default-personal-dir))

  (defun org-refile-to-notes-dir ()
    "Move the current subtree to a file in the `zettelkasten' directory."
    (interactive)
    (org-refile-notes-to-file org-default-notes-dir))

  (defun org-refile-to-headline (file headline)
    (let ((pos (save-excursion
                 (find-file file)
                 (org-find-exact-headline-in-buffer headline))))
      (org-refile nil nil (list headline file nil pos))
      (switch-to-buffer (current-buffer))))

  (defun org-refile-to-process ()
    "Refile (move) the current Org subtree to `org-default-incubate-file'."
    (interactive)

    (org-refile-directly "~/org/notes/process.org")
    (kill-line)
    )

  (defun org-refile-to-cross-ref ()
    "Refile (move) the current Org subtree to `org-default-incubate-file'."
    (interactive)

    (org-refile-directly "~/org/notes/cross-reference.org")
    (kill-line))
  #+END_SRC

*** note-to
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org-refiler.el
  (defun note-to-websites ()
    (interactive)
    (org-refile-to-headline org-file-reference "Websites"))

  (defun note-to-images ()
    (interactive)
    (org-refile-to-headline org-file-reference "Images"))

  (defun note-to-videos ()
    (interactive)
    (org-refile-to-headline org-file-reference "Videos"))

  (defun note-to-audio ()
    (interactive)
    (org-refile-to-headline org-file-reference "Audio"))

  (defun note-to-documents ()
    (interactive)
    (org-refile-to-headline org-file-reference "Documents"))

  (defun refile-to-tickler ()
    (interactive)
    (org-refile-to-headline org-file-calendar "Tickler"))

  (defun refile-to-calendar ()
    (interactive)
    (org-refile-to-headline org-file-calendar "Calendar"))

  (defun org-refile-to-delegate ()
    "Refile (move) the current Org subtree to `org-default-incubate-file'."
    (interactive)
    (org-todo "DELEGATE")

    (org-refile-directly org-default-delegate-file)
    (kill-line))

  #+END_SRC
*** org-refile-subtree-to-file
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org-refiler.el
  (defun org-refile-subtree-to-file (dir)
    "Archive the org-mode subtree and create an entry in the
   directory folder specified by DIR. It attempts to move as many of
   the subtree's properties and other features to the new file."
    (interactive "DDestination: ")
    (let* ((props      (org-subtree-metadata))
           (head       (plist-get props :header))
           (body       (plist-get props :body))
           (tags       (plist-get props :tags))
           (properties (plist-get props :properties))
           (area       (plist-get props :region))
           (filename   (org-filename-from-title head))
           (filepath   (format "%s/%s.org" dir filename)))
      (apply #'delete-region area)
      (org-create-org-file filepath head body)))

  (defun org-create-org-file (filepath header body)
    "Create a new Org file by FILEPATH. The contents of the file is
   pre-populated with the HEADER, BODY and any associated TAGS."
    (find-file-other-window filepath)
    (org-set-file-property "TITLE" header t)
    (org-set-file-property "CATEGORY" "project")
  ;  (when tags
  ;    (org-set-file-property "FILETAGS" (s-join " " tags)))

    ;;  Insert any drawer properties as #+PROPERTY entries:
    (when properties
      (goto-char (point-min))
      (or (re-search-forward "^\s*_\s$" nil t) (point-max))
      (--map (insert (format "#+PROPERTY: %s %s\n" (first it) (second it))) properties))

    ;; My auto-insert often adds an initial headline for a subtree, and in this
    ;; case, I don't want that... Yeah, this isn't really globally applicable,
    ;; but it shouldn't cause a problem for others.
    (when (re-search-forward "^\\* [0-9]$" nil t)
      (replace-match ""))

    (delete-blank-lines)
    (goto-char (point-max))
    (insert "\n")
    (insert "\n")
    (insert "* TODO " header)
    (insert "\n")
    (insert body))
  #+END_SRC
*** org-refile-notes-to-file
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org-refiler.el
  (defun org-refile-notes-to-file (dir)
    "Archive the org-mode subtree and create an entry in the
    directory folder specified by DIR. It attempts to move as many of
    the subtree's properties and other features to the new file."
    (interactive "DDestination: ")
    (let* ((props      (org-subtree-metadata))
           (head       (plist-get props :header))
           (body       (plist-get props :body))
           (tags       (plist-get props :tags))
                                          ;          (properties (plist-get props :properties))
           (area       (plist-get props :region))
           (filename   (concat (format-time-string "%Y-%m-%dT%H.%M.%S")))
           (filepath   (format "%s/%s.org" dir filename)))
      (apply #'delete-region area)
      (org-create-notes-file filepath head body tags)))

  (defun org-create-notes-file (filepath header body tags)
    "Create a new Org file by FILEPATH. The contents of the file is
    pre-populated with the HEADER, BODY and any associated TAGS."
    (find-file filepath)
    (org-set-file-property "TITLE" header t)
    (org-set-file-property "DATE" (format-time-string "<%Y-%m-%d %H:%M>"))
    (org-set-file-property "KEYWORDS" (s-join "" tags))
    (goto-char (point-min))
    (when (re-search-forward "REFILE" nil t)
      (replace-match ""))

    (delete-blank-lines)
    (goto-char (point-max))
    (insert "\n\n")
                                          ;   (insert "* " header)
                                          ;   (insert "\n\n")
    (insert body)
    (goto-char (point-min))
    (save-buffer))
  #+END_SRC
*** org-rename-header
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org-refiler.el
  (defun org-rename-header (label)
    "Rename the current section's header to LABEL, and moves the
    point to the end of the line."
    (interactive (list
                  (read-string "Header: "
                               (substring-no-properties (org-get-heading t t t t)))))
    (org-back-to-heading)
    (replace-string (org-get-heading t t t t) label))
  #+END_SRC
*** todays-journal-entry
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org-refiler.el
  (defun todays-journal-entry ()
    "Return the full pathname to the day's journal entry file.
    Granted, this assumes each journal's file entry to be formatted
    with year/month/day, as in `20190104' for January 4th.

    Note: `org-journal-dir' variable must be set to the directory
    where all good journal entries live, e.g. ~/journal."
    (let* ((daily-name   (format-time-string "%Y-%m-%d"))
           (file-name    (concat org-journal-dir daily-name)))
      (expand-file-name file-name)))
  #+END_SRC
*** org-subtree-metadata helpers
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org-refiler.el
(cl-defun unpackaged/org-refile-to-datetree (&key (date (calendar-current-date)) entry)
  "Refile ENTRY or current node to entry for DATE in datetree in FILE."
  (interactive)
  (require 'org-datetree)
  (setq file "~/org/agenda/log.org")
  (unless entry
    (org-cut-subtree))
  (condition-case err
      (with-current-buffer (or (org-find-base-buffer-visiting file)
                               (find-file-noselect file))
        (org-datetree-file-entry-under (or entry (car kill-ring)) date)
        (save-buffer))
    (error (unless entry
             (org-paste-subtree))
           (message "Unable to refile! %s" err))))


  (defun org-subtree-metadata ()
    "Return a list of key aspects of an org-subtree. Includes the
    following: header text, body contents, list of tags, region list
    of the start and end of the subtree."
    (save-excursion
      ;; Jump to the parent header if not already on a header
      (when (not (org-at-heading-p))
        (org-previous-visible-heading 1))

      (let* ((context (org-element-context))
             (attrs   (second context))
             (props   (org-entry-properties)))

        (list :region     (list (plist-get attrs :begin) (plist-get attrs :end))
              :header     (plist-get attrs :title)
              :tags       (org-get-subtree-tags props)
              :properties (org-get-subtree-properties attrs)
              :body       (org-get-subtree-content attrs)))))

  (defun org-get-subtree-tags (&optional props)
    "Given the properties, PROPS, from a call to
    `org-entry-properties', return a list of tags."
    (unless props
      (setq props (org-entry-properties)))
    (let ((tag-label (if org-get-subtree-tags-inherited "ALLTAGS" "TAGS")))
      (-some->> props
                (assoc tag-label)
                cdr
                substring-no-properties
                (s-split ":")
                (--filter (not (equalp "" it))))))

  (defvar org-get-subtree-tags-inherited t
    "Returns a subtree's tags, and all tags inherited (from tags
      specified in parents headlines or on the file itself). Defaults
      to true.")

  (defun org-get-subtree-properties (attributes)
    "Return a list of tuples of a subtrees properties where the keys are strings."

    (defun symbol-upcase? (sym)
      (let ((case-fold-search nil))
        (string-match-p "^:[A-Z]+$" (symbol-name sym))))

    (defun convert-tuple (tup)
      (let ((key (first tup))
            (val (second tup)))
        (list (substring (symbol-name key) 1) val)))

    (->> attributes
         (-partition 2)                         ; Convert plist to list of tuples
         (--filter (symbol-upcase? (first it))) ; Remove lowercase tuples
         (-map 'convert-tuple)))

  (defun org-get-subtree-content (attributes)
    "Return the contents of the current subtree as a string."
    (let ((header-components '(clock diary-sexp drawer headline inlinetask
                                     node-property planning property-drawer section)))

      (goto-char (plist-get attributes :contents-begin))

      ;; Walk down past the properties, etc.
      (while
          (let* ((cntx (org-element-context))
                 (elem (first cntx))
                 (props (second cntx)))
            (when (member elem header-components)
              (goto-char (plist-get props :end)))))

      ;; At this point, we are at the beginning of what we consider
      ;; the contents of the subtree, so we can return part of the buffer:
      (buffer-substring-no-properties (point) (org-end-of-subtree))))

  (defun org-filename-from-title (title)
    "Creates a useful filename based on a header string, TITLE.
    For instance, given the string:    What's all this then?
         This function will return:    whats-all-this-then"
    (let* ((no-letters (rx (one-or-more (not alphanumeric))))
           (init-try (->> title
                          downcase
                          (replace-regexp-in-string "'" "")
                          (replace-regexp-in-string no-letters "-"))))
      (string-trim init-try "-+" "-+")))

  (defun org-set-file-property (key value &optional spot)
    "Make sure file contains a top-level, file-wide property.
    KEY is something like `TITLE' or `FILETAGS'. This function makes
    sure that the property contains the contents of VALUE, and if the
    file doesn't have the property, it is inserted at either SPOT, or
    if nil,the top of the file."
    (save-excursion
      (goto-char (point-min))
      (let ((case-fold-search t))
        (if (re-search-forward (format "^#\\+%s:\s*\\(.*\\)" key) nil t)
            (replace-match value nil nil nil 1)

          (cond
           ;; if SPOT is a number, go to it:
           ((numberp spot) (goto-char spot))
           ;; If SPOT is not given, jump to first blank line:
           ((null spot) (progn (goto-char (point-min))
                               (re-search-forward "^\s*$" nil t)))
           (t (goto-char (point-min))))

          (insert (format "#+%s: %s\n" (upcase key) value))))))


  #+END_SRC
*** end
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org-refiler.el
)
  #+END_SRC

** org-journal
   :PROPERTIES:
   :CREATED:  [2019-06-28 Fri 09:51]
   :END:
   :LOGBOOK:
   - CLOSING NOTE [2019-06-28 Fri 09:51]
   :END:
*** org-journal-autoloads
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org-journal.el
      (use-package org-journal
        :config
#+END_SRC
*** journal
  #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org-journal.el
      (setq journal-author "Alexander Soto")

      ;; This is the base folder where all your "books"
      ;; will be stored.
      (setq journal-base-dir "~/org/notes")


      ;; These are your "books" (folders), add as many as you like.
      ;; Note: "sub volumes" are acheivable with sub folders.
      (setq journal-books
            '("projects"
              "personal"))

      ;; Functions for journal
      (defun get-journal-file-today (book)
        "Return today's filename for a books journal file."
        (interactive (list (completing-read "Book: " journal-books) ))
        (cond

         ((string-match "personal" book)
          (expand-file-name
           (concat journal-base-dir book "/"
                   (format-time-string "%Y-%m-%dT%H.%M.%S") ".org.gpg" )))

         ((unless (equal book '("personal"))
            (expand-file-name
             (concat journal-base-dir book "/"
                     (format-time-string "%Y-%m-%dT%H.%M.%S") ".org" ))))))

      (defun journal-today ()
        "Load todays journal entry for book"
        (interactive)
        (auto-insert-mode)
        (find-file (call-interactively 'get-journal-file-today)) )

      (defun journal-entry-date ()
        "Inserts the journal heading based on the file's name."
        (when (string-match
               "\\(20[0-9][0-9]\\)\\([0-9][0-9]\\)\\([0-9][0-9]\\)\\(.org\\)"
               (buffer-name))
          (let ((year  (string-to-number (match-string 2 (buffer-name))))
                (month (string-to-number (match-string 3 (buffer-name))))
                (day   (string-to-number (match-string 4 (buffer-name))))
                (datim nil))
            (setq datim (encode-time 0 0 0 day month year))
            (format-time-string "%Y-%m-%d (%A)" datim))))

            (eval-after-load 'autoinsert
        '(define-auto-insert
           '("\\(20[0-9][0-9]\\)\\(-\\)\\([0-9][0-9]\\)\\(-\\)\\([0-9][0-9]\\)\\(-\\)\\([0-9][0-9][0-9][0-9][0-9][0-9]\\)\\(.*\\)" . "Journal Header")
           '("Short description: "
             "#+TITLE: "
             (read-string "Title: ") \n
             "#+DATE: " (format-time-string "<%Y-%m-%d %H:%M>") \n
             "#+KEYWORDS: "
             (read-string "Keyword: ") \n \n

             > _ \n \n \n \n \n
             "
      ---
      ,*Related:*


      ---
      ,*References:*
      "

             )))

   #+END_SRC
*** autoload-ends
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/activity/activity-org-journal.el
)
#+END_SRC

* Bindings
** general-autoloads
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/bindings/bindings.el
(after "general-autoloads"
#+END_SRC
** Global
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/bindings/bindings.el
(general-define-key
"C-x b"    #'ivy-switch-buffer-non-exwm
"<print>"  #'desktop-environment-screenshot
"C-4"      #'my/org-capture-appt
"C-1"      #'my/org-capture-task
"C-2"      #'my/org-capture-journal
"C-3"      #'my/org-capture-note
"s-p"      #'my/switch-to-last-buffer
"s-SPC"    #'exwm-jump-to-last-exwm
"s-<tab>"  #'ivy-switch-buffer-exwm
"s-f"      #'toggle-single-window
"s-,"      #'winner-undo
"s-."      #'winner-redo
"s-r"      #'exwm-reset
"s-w"      #'exwm-workspace-switch
"s-l"      #'windmove-right
"s-k"      #'windmove-left
"s-i"      #'windmove-up
"s-o"      #'windmove-down
"s-L"      #'buf-move-right
"s-K"      #'buf-move-left
"s-I"      #'buf-move-up
"s-O"      #'buf-move-down
"s-x"      #'exwm-input-toggle-keyboard)

#+END_SRC
** Modes
*** Org
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/bindings/bindings.el
    (after "org-contrib-autoloads"

      (general-def org-mode-map


      )


      (general-def org-agenda-mode-map
      "x"   'org-agenda-exit
      "'"   'org-agenda-set-restriction-lock-from-agenda
      "\\"   'org-agenda-remove-restriction-lock

      )
)

#+END_SRC
** Prefix
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/bindings/bindings.el
  (general-define-key
  :prefix "C-c"

  )

#+END_SRC
** Definer
  #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/bindings/bindings.el
    (general-define-key
         :keymaps 'key-translation-map
         "ESC" (kbd "C-g"))

        (defconst my-leader "C-c")

        (general-create-definer my-leader-def
          :prefix my-leader)

    ;; Global
        (my-leader-def



          )

    ;; Modes
        (my-leader-def
          :keymaps 'org-mode-map

          )

   #+END_SRC

** Unbound
  #+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/bindings/bindings.el
    (general-unbind
      "C-x m"
      )
  #+END_SRC
** autoload-ends
#+BEGIN_SRC emacs-lisp :tangle ~/.personal.d/bindings/bindings.el
)
#+END_SRC
