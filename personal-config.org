:HIDDEN:
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>

#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>

#+PROPERTY: header-args :tangle personal-config.el
#+EXPORT_EXCLUDE_TAGS: noexport
#+HTML_HEAD_EXTRA: <style>div#content { max-width: 2000px; }</style>
:END:
#+TITLE: Personal Configuration
#+TODO: ACTIVE | DISABLED

* Modules
** EXWM Window Manager
*** config
 #+BEGIN_SRC emacs-lisp
   (use-package exwm
     :config
     (server-start)
     (require 'exwm)
     (require 'exwm-systemtray)
     (require 'exwm-randr)

     (display-time-mode t)
     (display-battery-mode nil)

     (setq use-dialog-box nil)
     (setq exwm-workspace-show-all-buffers t)
     (setq exwm-layout-show-all-buffers t)

     (setq exwm-workspace-index-map
           (lambda (index) (number-to-string (1+ index))))

     (dotimes (i 10)
       (exwm-input-set-key (kbd (format "s-%d" i))
                           `(lambda ()
                              (interactive)
                              (exwm-workspace-switch-create (1- ,i)))))

     (ido-mode 0)

     (setq display-time-default-load-average nil)

     (setq window-divider-default-bottom-width 2
           window-divider-default-right-width 2)

     (setq exwm-manage-configurations '((t char-mode t)))

     (setq exwm-workspace-number 9)

     (defvar exwm-toggle-workspace 0
       "Previously selected workspace. Used with `exwm-jump-to-last-exwm'.")

     (defun exwm-jump-to-last-exwm ()
       (interactive)
       (exwm-workspace-switch exwm-toggle-workspace))

     (defadvice exwm-workspace-switch (before save-toggle-workspace activate)
       (setq exwm-toggle-workspace exwm-workspace-current-index))

     (defun my/exwm-rename-buffer-to-title () (exwm-workspace-rename-buffer exwm-title))

     (add-hook 'exwm-update-title-hook 'my/exwm-rename-buffer-to-title)

     (add-hook 'exwm-floating-setup-hook 'exwm-layout-hide-mode-line)
     (add-hook 'exwm-floating-exit-hook 'exwm-layout-show-mode-line)

     (defun my-exwm-workspace-display-current ()
       "Display current workspace index."
       (interactive)
       (let ((message-log-max))
         (message (elt exwm-workspace--switch-history
                       exwm-workspace-current-index))))

     (add-hook 'exwm-workspace-switch-hook #'my-exwm-workspace-display-current)
     (advice-add 'exwm-workspace-add :after #'my-exwm-workspace-display-current)
     (advice-add 'exwm-workspace-delete :after #'my-exwm-workspace-display-current)


     (window-divider-mode))
   #+END_SRC
*** packages
**** xelb
 #+BEGIN_SRC emacs-lisp
   (use-package xelb)
 #+END_SRC
**** exwm-edit
 #+BEGIN_SRC emacs-lisp
   (use-package exwm-edit)
 #+END_SRC
*** keybindings
 #+BEGIN_SRC emacs-lisp
   (setq exwm-input-line-mode-passthrough t)

   (defun exwm-input-line-mode ()
     "Set exwm window to line-mode and show mode line"
     (call-interactively #'exwm-input-grab-keyboard)
     (exwm-layout-show-mode-line))

   (defun exwm-input-char-mode ()
     "Set exwm window to char-mode and hide mode line"
     (call-interactively #'exwm-input-release-keyboard)
     (exwm-layout-hide-mode-line))

   (defun exwm-input-toggle-mode ()
     "Toggle between line- and char-mode"
     (with-current-buffer (window-buffer)
       (when (eq major-mode 'exwm-mode)
         (if (equal (second (second mode-line-process)) "line")
             (exwm-input-char-mode)
           (exwm-input-line-mode)))))

   (defun exwm-input-set-global-key (key function)
     "Add KEY to `exwm-input-prefix-keys' and bind FUNCTION to KEY
        in exwm keymap"
     (cl-pushnew (elt key 0) exwm-input-prefix-keys)
     (exwm-input-set-key key function))

   (defun my/switch-to-last-buffer ()
     "Switch to last open buffer in current window."
     (interactive)
     (switch-to-buffer (other-buffer (current-buffer) 1)))

   (define-key minibuffer-inactive-mode-map [mouse-1] #'ignore)

   (defun my-counsel-ibuffer-by-exwm-class-name ()
     "`counsel-ibuffer' limited to Exwm buffers of same X class."
     (interactive)
     (require 'ibuffer)
     (cl-letf*
         ((class-name exwm-class-name)
          (get-buffers-function
           (symbol-function 'counsel-ibuffer--get-buffers))
          ((symbol-function 'counsel-ibuffer--get-buffers)
           (lambda ()
             (--filter (with-current-buffer (cdr it)
                         (and (eq major-mode 'exwm-mode)
                              (string-equal exwm-class-name class-name)))
                       (funcall get-buffers-function)))))
       (counsel-ibuffer)))

   (setq windmove-wrap-around t)

   (push ?\s-  exwm-input-prefix-keys)
   ;(push ?\M-  exwm-input-prefix-keys)
   ;(add-to-list 'exwm-input-prefix-keys ?\C-\s)
   ;(add-to-list 'exwm-input-prefix-keys ?\C-\c)




   (defvar exwm-input-prefix-keys-extra nil)

   ;;Send next key/sequence to XWindow
   (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)
   ;;Enter fullscreen
   (define-key exwm-mode-map [?\C-c C-f] 'exwm-layout-set-fullscreen)
   ;;Hide a floating windows
   (define-key exwm-mode-map [?\C-c C-h] 'exwm-floating-hide)
   ;;Switch to char-mode
   (define-key exwm-mode-map [?\C-c C-k] 'exwm-input-release-keyboard)
   ;;Move window to new workspace
   (define-key exwm-mode-map [?\C-c C-w] 'exwm-workspace-move-window)
   ;;Toggle floating
   (define-key exwm-mode-map [?\C-c C-t C-f] 'exwm-floating-toggle-floating)
   ;;Toggle mode-line
   (define-key exwm-mode-map [?\C-c C-t C-m] 'exwm-layout-toggle-mode-line)

   (setq exwm-input-simulation-keys
         '(
           ;; movement
           ([?\C-b] . [left])
           ([?\C-f] . [right])
           ([?\C-p] . [up])
           ([?\C-n] . [down])
           ([?\C-a] . [home])
           ([?\C-e] . [end])
           ([?\M-v] . [prior])
           ([?\C-v] . [next])
           ([?\C-d] . [delete])
           ([?\C-k] . [S-end delete])

           ;; cut/paste
           ([?\C-w] . [?\C-x])
           ([?\M-w] . [?\C-c])
           ([?\C-y] . [?\C-v])
           ;; search
           ([?\C-s] . [?\C-f])))

(defun my-exwm-keybindings ()
  "Add the key bindings for exwm."
  (exwm-input-set-key (kbd "<print>") #'desktop-environment-screenshot)

  (exwm-input-set-key (kbd "C-SPC")
                      (lambda ()
                        (interactive)
                        (exwm-input-line-mode)
                        (hydra-master/body)))

  (exwm-input-set-key (kbd "s-m")
                      (lambda ()
                        (interactive)
                        (exwm-input-line-mode)
                        (boon-mode-hydra)))

  (exwm-input-set-key  (kbd "s-;") 'counsel-switch-buffer)
  (exwm-input-set-key  (kbd "s-p") 'my/switch-to-last-buffer)
  (exwm-input-set-key (kbd "s-SPC") 'exwm-jump-to-last-exwm)


  (exwm-input-set-key (kbd "s-f") 'my/toggle-maximize)

  (exwm-input-set-key (kbd "s-,") 'winner-undo)
  (exwm-input-set-key (kbd "s-.") 'winner-redo)

  (exwm-input-set-key (kbd "s-r") #'exwm-reset)
  (exwm-input-set-key (kbd "s-w") #'exwm-workspace-switch)

  (exwm-input-set-key (kbd "s-x") #'exwm-input-toggle-keyboard))


 #+END_SRC
*** randr
 #+BEGIN_SRC emacs-lisp
   (setq exwm-randr-workspace-output-plist '(0 "eDP1" 1 "HDMI2" 2 "VGA1"))

   (add-hook 'exwm-randr-screen-change-hook
               (lambda ()
                 (start-process-shell-command
                  "xrandr" nil "xrandr --output HDMI2 --left-of VGA1 --auto")))

 #+END_SRC
*** ibuffer
 #+BEGIN_SRC emacs-lisp
   (setq ibuffer-saved-filter-groups
     (quote (("default"
       ("EXWM" (mode . exwm-mode))
       ("org-mode" (mode . org-mode))
       ("git" (mode . magit-status-mode))
       ("dired" (mode . dired-mode))
       ("emacs" (or
                 (name . "^\\*scratch\\*$")
                 (name . "^\\*Messages\\*$")
                 (name . "^\\*Bookmark List\\*$")
                 (name . "^\\*GNU Emacs\\*$")))))))

   (add-hook 'ibuffer-mode-hook
             (lambda ()
               (ibuffer-switch-to-saved-filter-groups "default")))



   ;; Use human readable Size column instead of original one
   (define-ibuffer-column size-h
     (:name "Size")
     (cond
      ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
      ((> (buffer-size) 100000) (format "%7.0fk" (/ (buffer-size) 1000.0)))
      ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
      (t (format "%8d" (buffer-size)))))

   (define-ibuffer-column exwm-class
     (:name "Class")
     (cond
      (exwm-class-name (format "%s" exwm-class-name))
      (t (format "%s" ""))))

   ;; Needs work to look good, major-mode is not equal to ibuffer-formats mode
   (define-ibuffer-column exwm-mode
     (:name "EXWM-Mode")
     (cond
      ((string-equal major-mode "exwm-mode") (format "%s" exwm-class-name))
      (t (format "%s" mode-name))))

   (setq ibuffer-formats
         '((mark modified read-only locked " "
                 (name 50 50 :left :elide)
                 " "
                 (size-h 16 16 :right)
                 " "
                 (exwm-mode 18 18 :left :elide)
                 " " filename-and-process)
           (mark modified read-only locked " "
                 (name 50 50 :left :elide)
                 " "
                 (size-h 16 16 :right)
                 " "
                 (mode 18 18 :left :elide)
                 (exwm-class 18 18 :left :elide)
                 " " filename-and-process)
           (mark " "
                 (name 16 -1)
                 " " filename)))
 #+END_SRC
*** autostart
 #+BEGIN_SRC emacs-lisp
   (defun app/autostart (application)
     "Add an application to autostart."
     (add-hook 'exwm-init-hook
               `(lambda ()
                  (start-process-shell-command "autostart-process" nil ,application))))

   (defun my-exwm-autostart ()
     "Add applications that will be loaded after exwm init is done."
     (mapcar (lambda (program) (app/autostart program)) exwm-autostart))


   (setq exwm-autostart
         (list
          "nm-applet"
          "compton -b"
          "volumeicon"
          "thinkpad-touchpad off"
          "/usr/bin/dunst"
          "/usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1"
          "pamac-tray"
          "autorandr --change"
          "xfce4-power-manager"
          "redshift-gtk"
          ))


   (add-hook 'after-init-hook
             (lambda ()
               (my-exwm-autostart)
               (exwm-systemtray-enable)
               (exwm-nw-mode)
               (exwm-randr-enable)
               (exwm-input--update-global-prefix-keys)
               (my-exwm-keybindings)
               (exwm-init))
             t)
 #+END_SRC
** torus
#+BEGIN_SRC emacs-lisp
    (use-package torus
      :init
  (defun torus-read (filename)
    "Read main torus variables from FILENAME as Lisp code."
    (interactive
     (list
      (read-file-name
       "Torus file : "
       (file-name-as-directory torus-dirname))))
    (let*
        ((file-basename (file-name-nondirectory filename))
         (minus-len-ext (- (min (length torus-extension)
                                (length filename))))
         (buffer))
      (unless (equal (cl-subseq filename minus-len-ext) torus-extension)
        (setq filename (concat filename torus-extension)))
      (when (torus--update-input-history file-basename)
        (if (file-exists-p filename)
            (progn
              (setq buffer (find-file-noselect filename))
              (eval-buffer buffer)
              (kill-buffer buffer))
          (message "File %s does not exist." filename))))
    ;; Also saved in file
    ;; (torus--update-meta)
    ;; (torus--build-index)
    ;; (torus--build-meta-index)
    (torus--jump))
      (setq torus-prefix-key (kbd "C-x t"))

      :bind-keymap ("C-x t" . torus-map)
      :bind (
             :map torus-map
             ("t" . torus-copy-to-circle))
      :hook ((emacs-startup . torus-start)
             (kill-emacs . torus-quit))
      :custom (
               (torus-binding-level 1)
               (torus-verbosity 1)
               (torus-dirname (concat user-emacs-directory (file-name-as-directory "torus")))
               (torus-load-on-startup t)
               (torus-save-on-exit t)
               (torus-autoread-file (concat torus-dirname "last.el"))
               (torus-autowrite-file torus-autoread-file)
               (torus-backup-number 5)
               (torus-history-maximum-elements 30)
               (torus-maximum-horizontal-split 3)
               (torus-maximum-vertical-split 4)
               (torus-display-tab-bar t)
               (torus-separator-torus-circle " >> ")
               (torus-separator-circle-location " > ")
               (torus-prefix-separator "/")
               (torus-join-separator " & "))
      :config
      (torus-init)
      (torus-install-default-bindings)
    )

#+END_SRC

** boon
*** setup
#+BEGIN_SRC emacs-lisp
    (use-package boon
      :config
      (require 'boon-qwerty)
      (boon-mode)

  )
#+END_SRC
*** boon-objed
#+BEGIN_SRC emacs-lisp
  ;; (defvar boon-objed-map (make-sparse-keymap))
  ;; (append boon-mode-map-alist (cons 'boon-objed-state boon-objed-map))

  (defvar-local boon-objed-state nil "Non-nil when boon objed mode is activated.")

  (defun boon-reset-all-mode-states ()
    (interactive)
    (mapcar (lambda (boon-mode)
              (setq boon-mode nil)) boon-mode-map-alist))




  (defun boon-set-objed-state ()
    "Switch to objed state."
    (boon-set-state 'boon-objed-state))

  (setq boon-key-list '
        ((org-mode . (message "%s" "command from org mode"))
         (lisp-mode . (message "%s" "command from lisp mode"))
         (python-mode . (message "%s" "command from python mode"))))
#+END_SRC
*** boon-major-mode
#+BEGIN_SRC emacs-lisp
  (defun boon-detect-mode (boon-mode-map)
    (let ((boon-mode-command (cdr (assoc major-mode boon-mode-map))))
      (if boon-mode-command (apply boon-mode-command))))

  (setq boon-major-mode-hydra-list '
        ((org-mode . (hydra-org/body))
         (emacs-lisp-mode . (hydra-lisp/body))
         (js2-mode . (hydra-javascript/body))
         (json-mode . (hydra-json/body))
         (sql-mode . (hydra-sql/body))
         (css-mode . (hydra-css/body))
         (scss-mode . (hydra-scss/body))
         (javascript-mode . (hydra-javascript/body))
         (yaml-mode . (hydra-yaml/body))
         (c++-mode . (hydra-c++/body))
         (web-mode . (hydra-web/body))
         (html-mode . (hydra-html/body))
         (exwm-mode . (hydra-exwm/body))
         (python-mode . (hydra-python/body))))

  (defun boon-select-major-mode (boon-mode-map)
    (let ((boon-mode-command (cdr (assoc major-mode boon-mode-map))))
      (if boon-mode-command (apply boon-mode-command))))

  (defun boon-mode-hydra ()
    (interactive)
    (boon-select-major-mode boon-major-mode-hydra-list))

  (define-key boon-command-map (kbd "SPC")   'hydra-master/body)
  (define-key boon-command-map (kbd "RET")   'counsel-linux-app)

  (define-key boon-command-map  (kbd "m")   'boon-mode-hydra)

  (define-key boon-command-map (kbd "5")     'hydra-narrow/body)
  (define-key boon-command-map (kbd "8")     'objed-mode)

  (define-key boon-command-map (kbd "<f12>") 'hydra-emacs/body)
  (define-key boon-command-map (kbd "g")     'hydra-jump/body)
  (define-key boon-command-map (kbd "G")     'hydra-goto/body)

  (define-key boon-command-map (kbd "r")     'hydra-search/body)
  (define-key boon-command-map (kbd "b")     'hydra-register/body)

  (define-key boon-command-map (kbd "/")     'hui-search-web)
  (define-key boon-command-map (kbd "F")     'my/exwm-counsel-yank-pop)
  (define-key boon-command-map (kbd "H")     'avy-goto-word-1)
  (define-key boon-command-map (kbd "h")     'avy-goto-char)

#+END_SRC
*** boon-special
#+BEGIN_SRC emacs-lisp
  (custom-set-variables
   '(boon-special-mode-list
     (quote
      (
       magit-mode
       magit-popup-mode
       debugger-mode
       git-rebase-mode
       help-mode
       org-agenda-mode
       ,,*dashboard*
       ))))


#+END_SRC

** objed
#+BEGIN_SRC emacs-lisp
  (use-package objed)
#+END_SRC

** emms
#+BEGIN_SRC emacs-lisp
 (use-package emms
 :ensure t
 :config
 (require 'emms)
    (emms-all)
    (emms-default-players)
    (setq emms-source-file-default-directory "/home/alexander/org/data/c0/80320c-060b-4348-a413-ee7d8ed40dd6/")

    (setq emms-playlist-buffer-name "*Music*")
    (setq emms-info-asynchronously t)
    (setq emms-info-functions '(emms-info-libtag))
    (emms-mode-line 0)
    (emms-playing-time 1))
#+END_SRC

** pdf-tools
 #+BEGIN_SRC emacs-lisp
(use-package pdf-tools :ensure t
  :config
  (unless noninteractive
    (pdf-tools-install))
  (setq-default pdf-view-display-size 'fit-page))
 #+END_SRC

** Hyperbole
#+BEGIN_SRC emacs-lisp
(use-package hyperbole
  :ensure t
  :config
  (defun goto-button (heading loc)
    (widen)
    (goto-char(point-min))
    (search-forward-regexp heading)
    (org-narrow-to-subtree)
    (search-forward-regexp loc)
    (recenter-top-bottom))

  (defun my/avy-goto-jump (char &optional arg)
    "Jump to the currently visible CHAR.
  The window scope is determined by `avy-all-windows' (ARG negates it)."
    (interactive (list (read-char "char: " t)
                       current-prefix-arg))

    (avy-with avy-goto-char
      (avy-jump
       (if (= 13 char)
           "\n"
         (regexp-quote (string char)))
       :window-flip arg))
    (hkey-either arg))

  )


#+END_SRC
** howm
*** functions
  #+BEGIN_SRC emacs-lisp
(defvar howm-view-title-header "#+TITLE:")

(defvar howm-view-header-format
  "\n\n#+INCLUDE: %s\n")

(setq howm-template-rules
      '(("%title" . howm-template-title)
        ("%date" . howm-template-date)
        ("%file" . howm-template-previous-file)
        ("%parent" . howm-template-parent)
        ("%fname" . howm-template-filename)
        ("%cursor" . howm-template-cursor)))

(defun howm-template-title (arg)
  (insert (cdr (assoc 'title arg))))

(defun howm-template-filename (arg)
  (insert (concat ">>>" (file-name-base buffer-file-name))))

(defun howm-template-parent (arg)
  (insert (cdr (assoc 'parent arg))))

(defun howm-template-date (arg)
  (insert (cdr (assoc 'date arg))))

(defun howm-template-previous-file (arg)
  (insert (cdr (assoc 'file arg))))

(defun howm-template-cursor (arg))

(setq howm-file-name-format "%Y-%m-%dT%H.%M.%S.org")
(setq howm-template-date-format "#+DATE: [%Y-%m-%d %H:%M]")
(setq howm-directory "~/org/notes/")
(setq howm-view-preview-narrow nil)

(add-hook 'org-mode-hook 'howm-mode)
(add-to-list 'auto-mode-alist '("\\.howm$" . org-mode))



(setq howm-view-split-horizontally t)
(setq howm-view-keep-one-window t)

(setq howm-menu-refresh-after-save nil)
(setq howm-menu-expiry-hours 6)  ;; cache menu N hours
(setq howm-menu-file "0000-00-00-000000.txt")  ;; don't *search*

(setq howm-view-use-grep t)
(setq howm-view-grep-command "rg")
(setq howm-view-grep-option "-nH --no-heading --color never")
(setq howm-view-grep-extended-option nil)
(setq howm-view-grep-fixed-option "-F")
(setq howm-view-grep-expr-option nil)
(setq howm-view-grep-file-stdin-option nil)

;; howm-menu
(defun howm-menu-with-j1 (orig-fun &rest args)
  (setq howm-view-grep-option "-nH --no-heading -j1 --color never")
  (apply orig-fun args)
  (setq howm-view-grep-option "-nH --no-heading --color never"))

(advice-add 'howm-menu-refresh :around #'howm-menu-with-j1)

(setq howm-view-search-in-result-correctly t)

(setq howm-view-list-title-type 2)
(setq howm-view-summary-format "")

(defun howm-search-title (title)
  (interactive "sSearch title: ")
  (message title)
  (howm-search (format "^* +%s" (regexp-quote title)) nil))

(defun howm-list-grep-in-new-frame (&optional completion-p)
  (interactive "P")
  (select-frame (make-frame))
  (howm-list-grep completion-p))

(defvar *howm-new-frame* nil)

(defun howm-new-frame ()
  (when *howm-new-frame*
    (select-frame (make-frame))))
(add-hook 'howm-view-before-open-hook 'howm-new-frame)

(defun howm-open-new-frame (opener)
  ;; move cursor back from contents to summary in the original frame
  (let (new-frame)
    (save-window-excursion
      (let ((*howm-new-frame* t))
        (funcall opener))
      (setq new-frame (selected-frame)))
    (select-frame new-frame)))

(defun howm-open-new-frame-summary ()
  (interactive)
  (howm-open-new-frame #'howm-view-summary-open-sub))

(defun howm-open-new-frame-contents ()
  (interactive)
  (howm-open-new-frame #'howm-view-contents-open-sub))


(defun howm-create-and-link (&optional which-template)
  (interactive "p")
  (let ((b (current-buffer))
        (p (point)))
    (prog1
        (howm-create which-template)
      (let ((f (buffer-file-name)))
        (when (and f (buffer-file-name b))
          (with-current-buffer b
            (goto-char p)
            (insert (format howm-template-file-format
                            (abbreviate-file-name f))
                    "\n")))))))

(defun howm-open-from-calendar ()
  (interactive)
  (require 'howm-mode)
  (let* ((mdy (calendar-cursor-to-date t))
         (m (car mdy))
         (d (second mdy))
         (y (third mdy))
         (ti (encode-time 0 0 0 d m y))
         (pc (howm-folder-get-page-create howm-directory (howm-file-name ti)))
         (page (car pc))
         (createp (cdr pc)))
    (other-window 1)
    (howm-page-open page)
    (if createp
        (howm-create-here)
      (howm-set-mode))))
(require 'calendar)


(defun my-howm-switch-to-summary ()
  (interactive)
  (switch-to-buffer "*howmS*")
  (riffle-summary-check t))

(add-hook 'howm-view-contents-mode-hook
          (lambda ()
            (setq default-directory howm-directory)
            (howm-mode 1)))
(defadvice riffle-contents-show (around howm-mode (item-list) activate)
  ad-do-it
  (when howm-mode
    (howm-initialize-buffer)))


(defun howm-export-to-org ()
  "Remove formatting and export to plain text
  when in howmC view"
  (interactive)
  (copy-whole-buffer-to-clipboard)
  (find-file   (concat "~/notes_export_" (format-time-string "%m-%d-%H%M%S") ".org"))
  (yank)
  (goto-char(point-min))
  (replace-string  "#+TITLE: "  "* ")
  (goto-char(point-min))
  (replace-string "#+DATE: " "")
  (goto-char(point-min))
  (replace-string "#+KEYWORDS: " "")
  (goto-char(point-min))
  (replace-regexp "^==========================>>> .*$" ""))


(defun howm-insert-filename ()
  (interactive)
  (insert (concat ">>>" (file-name-base buffer-file-name))))


(defun howm-create (&optional which-template here)
  (interactive "p")
  (let* ((t-c (howm-create-default-title-content))
         (title (car t-c))
         (content (cdr t-c)))
    (howm-create-file-with-title title which-template nil here content)
    (org-cycle '(16))
    ))


(defun my/howm-view-brain ()
  (interactive)
  (howm-view-summary-open)
  (my/org-brain-visualize-current))

(defun my/howm-view-summary-open ()
  (interactive)
  (howm-view-summary-open)
  (delete-other-windows))


(defun my/howm-view-summary-open ()
  (interactive)
  (howm-view-summary-open)
  (org-cycle '(16)))

(defun howm-friendship-to ()
  (interactive)
  (howm-create)
  (org-brain-add-friendship)
  (search-forward "#+TITLE:")
  (org-cycle '(16)))

(defun howm-parent-to ()
  (interactive)
  (howm-create)
  (org-brain-add-child)
  (search-forward "#+TITLE:")
  (org-cycle '(16)))


(defun howm-child-to ()
  (interactive)
  (howm-create)
  (org-brain-add-parent)
  (search-forward "#+TITLE:")
  (org-cycle '(16))

  )

(defun howm-org-include-file ()
  (interactive)
  (save-excursion
    (setq current-buffer buffer-file-name)
    (switch-to-buffer "*scratch*")
    (insert "\n\n")
    (insert "#+INCLUDE: \"" current-buffer "\" :only-contents t :lines \"10-\"\n\n")))


  #+END_SRC
*** package
   #+BEGIN_SRC emacs-lisp
(use-package howm
  :demand t
  :init
  (setq howm-template
":HIDDEN:
,#+PARENTS:
,#+CHILDREN:
,#+FRIENDS:

:RELATED:
%file
%title

:RESOURCES:

:END:
,#+TITLE: %cursor
%fname
%date
,#+CATEGORY:
,#+KEYWORDS:

  ")

:config
(define-key howm-view-summary-mode-map (kbd "M-C-m") 'howm-open-new-frame-summary)
(define-key howm-view-summary-mode-map [tab] 'my/howm-view-summary-open))


   #+END_SRC
** projectile
  #+BEGIN_SRC emacs-lisp
(use-package projectile
  :custom
  (projectile-use-git-grep t)
  (projectile-create-missing-test-files t)
  (projectile-completion-system 'ivy)
  (projectile-switch-project-action  #'projectile-commander)
  (projectile-discover-projects-in-search-path "~/org/projects")
  :config
  (define-key projectile-mode-map (kbd "C-x p") 'projectile-command-map)
  (projectile-mode +1)
  (counsel-projectile-mode +1)
  (def-projectile-commander-method ?S
    "Run a search in the project"
    (counsel-projectile-rg))
  (def-projectile-commander-method ?s
    "Open a *eshell* buffer for the project."
    (projectile-run-eshell))
  (def-projectile-commander-method ?d
    "Open project root in dired."
    (projectile-dired))
  (def-projectile-commander-method ?g
    "Show magit status."
    (magit-status)))

(use-package counsel-projectile
  :after ivy projectile
  :bind (("C-c s" . counsel-projectile-rg)))

(use-package ibuffer-projectile
                                        ;:bind ("C-x C-b" . ibuffer)
  :config
  (add-hook 'ibuffer-hook
            (lambda ()
              (ibuffer-projectile-set-filter-groups)
              (unless (eq ibuffer-sorting-mode 'alphabetic)
                (ibuffer-do-sort-by-alphabetic)))))



  #+END_SRC
** ivy-xref
#+BEGIN_SRC emacs-lisp
  (use-package ivy-xref
    :ensure t
    :init (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))
#+END_SRC
** goto-last-point
#+BEGIN_SRC emacs-lisp
  (use-package goto-last-point
    :ensure t
    :demand t
    :config (goto-last-point-mode))
#+END_SRC
** goto-last-change
#+BEGIN_SRC emacs-lisp
  (use-package goto-last-change
    :ensure t
    :bind
    (:map boon-goto-map
          ("SPC" . goto-last-change)))
#+END_SRC
** edit-indirect
#+BEGIN_SRC emacs-lisp
  (use-package edit-indirect)
#+END_SRC
** gpastel
#+BEGIN_SRC emacs-lisp
  (use-package gpastel
  :config
  (exwm-input-set-key (kbd "M-y") #'my/exwm-counsel-yank-pop)
  (defun my/exwm-counsel-yank-pop ()
    "Same as `counsel-yank-pop' and paste into exwm buffer."
    (interactive)
    (let ((inhibit-read-only t)
          (yank-pop-change-selection t))
      (call-interactively #'counsel-yank-pop))
    (when (derived-mode-p 'exwm-mode)
      (exwm-input--set-focus (exwm--buffer->id (window-buffer (selected-window))))
      (exwm-input--fake-key ?\C-v))))

#+END_SRC

** telephone-line
#+BEGIN_SRC emacs-lisp
  (use-package telephone-line
    :config
    (telephone-line-defsegment my-vc-info ()
    (when vc-mode
    (cond
    ((string-match "Git[:-]" vc-mode)
    (let ((branch (mapconcat 'concat (cdr (split-string vc-mode "[:-]")) "-")))
    (concat "" (format " %s" branch))))
    ((string-match "SVN-" vc-mode)
    (let ((revision (cadr (split-string vc-mode "-"))))
    (concat "" (format "SVN-%s" revision))))
    (t (format "%s" vc-mode)))))

    (telephone-line-defsegment* telephone-line-boon-mode-segment ()
         (let ((tag (cond
                     (boon-command-state  "CMD")
                     (boon-insert-state   "INS")
                     (boon-special-state  "SPC")
                     (boon-objed-state    "OBJ")
                     )))
           (if telephone-line-evil-use-short-tag
               (seq-take tag 1)
             tag)))

    ;; (telephone-line-defsegment* my-airline-position-segment (&optional lines columns)
    ;;   (let* ((l (number-to-string (if lines lines 1)))
    ;;          (c (number-to-string (if columns columns 2))))
    ;;     (if (eq major-mode 'paradox-menu-mode)
    ;;         (telephone-line-raw mode-line-front-space t)
    ;;         (concat " " "%" l "l:%" c "c"))))

    ;; (setq tel
        (setq telephone-line-lhs
          '((evil   . (telephone-line-boon-mode-segment))
            (accent . (my-vc-info
                       telephone-line-process-segment))
            (nil    . (telephone-line-buffer-segment
                       telephone-line-projectile-segment))))

    (setq telephone-line-rhs
          '((nil    . (telephone-line-flycheck-segment
                       telephone-line-misc-info-segment))

            (accent . (telephone-line-major-mode-segment))
            (nil    . (telephone-line-hud-segment))))
                       ;; my-airline-position-segment))))

    (setq display-time-format "%l:%M %p")
    (setq display-time-default-load-average nil)
    (setq display-time-use-mail-icon t)
    (setq display-time-mail-file t)

    (display-time-mode t)

    (telephone-line-mode 1))
#+END_SRC
** hydra
*** package
  #+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t
  :defer 0.1
  :init
  (define-key boon-moves-map  (kbd "SPC") 'hydra-master/body)
  :config

  (defun counsel-projectile-switch-to-buffer-other-window ()
    "Jump to a buffer in the current project."
    (interactive)
    (other-window 1)
    (counsel-projectile-switch-to-buffer))

  (defun counsel-projectile-find-dir-other-window ()
    "Jump to a buffer in the current project."
    (interactive)
    (other-window 1)
    (counsel-projectile-find-dir))

  (defun counsel-projectile-find-file-other-window ()
    "Jump to a buffer in the current project."
    (interactive)
    (other-window 1)
    (counsel-projectile-find-file))

  (defun counsel-projectile-find-file-dwim-other-window ()
    "Jump to a buffer in the current project."
    (interactive)
    (other-window 1)
    (counsel-projectile-find-file-dwim))

  (setq lv-use-separator t)
  (set-face-attribute 'hydra-face-blue nil :foreground "deep sky blue" :weight 'bold))
  #+END_SRC
*** common
**** setup
   #+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defhydra hydra-common  (
                           :color blue
                           :hint nil
                           :pre (progn
                                  (exwm-input-line-mode))
                           :post (progn
                                   (exwm-input-char-mode)))
    ("RET"   counsel-linux-app nil)
    ("SPC" counsel-M-x nil)
    ("<tab>" counsel-switch-buffer nil)
    ("DEL"   hydra-master/body)
    ("q" nil)



    ("m"   boon-mode-hydra "mode")
    ("b"   hydra-buffers/body "buffers")
    ("/"   hydra-search/body "search")
    ("\\"   hydra-narrow/body "narrow")
    (","   hydra-jump/body "jump")
    ("."   hydra-register/body "register")



    ))
   #+END_SRC
**** major-mode-hydras
***** hydra-org
   #+BEGIN_SRC emacs-lisp :results silent
  (defhydra hydra-org (:exit t :columns 4
:inherit (hydra-common/heads))

    "Org mode"
    ("u" org-up-element "Up element")
    ("d" org-down-element "Down element")
    ("b" org-next-block "Next block")
    ("e" org-export-dispatch "Export")
    ("t" org-todo "Toggle todo states")
    ("T" org-babel-tangle "Tangle code")
    ("c" org-babel-execute-src-block "Run block")
    ("," outline-show-children "Show node children")
    ("." org-tree-to-indirect-buffer "Edit in buffer")
    ("'" org-edit-special "Code buffer"))
   #+END_SRC
***** hydra-python
  #+BEGIN_SRC emacs-lisp :results silent
  (with-no-warnings
  (defhydra hydra-python (:exit t :columns 4)
    "Python"
    ("#" poporg-dwim "Edit Comment")
    ("," dumb-jump-back "Jump back")
    ("." dumb-jump-go "Jump to definition")
    ("D" hydra-python-django/body "Django")
    ("L" flycheck-prev-error "Prev lint error")
    ("T" pythonic-tests-all "Run pythonic test")
    ("a" pytest-all "Run all tests")
    ("b" python-shell-send-buffer "Send buffer to python")
    ("u" em-python-pur "Upgrade pip requirements")
    ;;("r" python-shell-send-buffer "Send line/region to python")
    ("r" run-python "REPL")
    ("d" helm-dash-at-point "Docs")
    ("c" em-python-execute "Compile / Execute")
    ("i" dumb-jump-quick-look "Definition Info")
    ("l" flycheck-next-error "Next lint error")
    ("t" pythonic-tests-run "Run current test")
    ("V" flycheck-verify-setup "Verify linting")
    ("v" em-python-environment "Check environment")
    ("s" isortify-buffer "Sort imports")
    ;;("n" flyceck "Run all tests")
    ("f" blacken-buffer "Format buffer code")))
  #+END_SRC
***** hydra-lisp
  #+BEGIN_SRC emacs-lisp
  (defhydra hydra-lisp (:exit t :columns 4)
    "Lisp Mode"
    ("r" ielm "Interactive REPL")
    ("." dumb-jump-go "Jump definition")
    ("v" flycheck-verify-setup "Verify linting")
    ("f" elisp-format-buffer "Format buffer")
    ("d" checkdoc "Lint doc strings")
    ("l" package-lint-current-buffer "Lint code")
    ("c" emacs-lisp-byte-compile-and-load "Lisp execute"))
  #+END_SRC
***** hydra-javascript
  #+BEGIN_SRC emacs-lisp
  (defhydra hydra-javascript (:exit t :columns 4)
    "Javascript"
    ("," dumb-jump-back "Jump back")
    ("." dumb-jump-go "Jump to definition")
    ("l" flycheck-next-error "Next lint error")
    ("i" npm-mode-npm-init "Initialize NPM")
    ("f" prettier-js "Format code")
    ("v" flycheck-verify-setup "Verify linting"))
  #+END_SRC
***** hydra-rjsx
  #+BEGIN_SRC emacs-lisp
  (defhydra hydra-rjsx (:exit t :columns 4)
    "Javascript"
    ("," dumb-jump-back "Jump back")
    ("." dumb-jump-go "Jump to definition")
    ("l" flycheck-next-error "Next lint error")
    ("i" npm-mode-npm-init "Initialize NPM")
    ("f" prettier-js "Format code")
    ("r" indium-connect "REPL")
    ("h" html-to-react "HTML to react")
    ("v" flycheck-verify-setup "Verify linting"))

  #+END_SRC

***** hydra-css
   #+BEGIN_SRC emacs-lisp
  (defhydra hydra-css (:exit t :columns 4)
    "Css"
    ("," dumb-jump-back "Jump back")
    ("." dumb-jump-go "Jump to definition")
    ("f" web-beautify-css "Format css"))
   #+END_SRC
***** hydra-scss
   #+BEGIN_SRC emacs-lisp
  (defhydra hydra-scss (:exit t :columns 4)
    "Scss"
    ("," dumb-jump-back "Jump back")
    ("." dumb-jump-go "Jump to definition")
    ("f" web-beautify-css "Format css"))
   #+END_SRC
***** hydra-web
   #+BEGIN_SRC emacs-lisp
  (defhydra hydra-web (:exit t :columns 4)
    "Web"
    ("f" web-beautify-html "Format buffer")
    ("o" browser-url-of-buffer "Open in browser"))
  #+END_SRC
***** hydra-html
   #+BEGIN_SRC emacs-lisp
  (defhydra hydra-html (:exit t :columns 4)
    "Html"
    ("f" web-beautify-html "Format buffer")
    ("o" browser-url-of-buffer "Open in browser"))
    #+END_SRC

***** hydra-c
    #+BEGIN_SRC emacs-lisp
  (defhydra hydra-c (:exit t :columns 4)
    "C"
    ("." dumb-jump-go "Jump to definition")
    ("," dumb-jump-back "Jump back")
    ("i" dumb-jump-quick-look "Definition Info")
    ("f" clang-format-buffer "Format buffer"))
    #+END_SRC
***** hydra-json
  #+BEGIN_SRC emacs-lisp
  (with-no-warnings
  (defhydra hydra-json (:exit t :columns 4)
    "CSV"
    (";" yafolding-toggle-all "Fold")
    ("f" csv-align-fields "Format visually")))
  #+END_SRC
***** hydra-exwm
    #+BEGIN_SRC emacs-lisp
  (defhydra hydra-exwm (:exit t
                        :columns 4
                        :color blue
                        :inherit (hydra-common/heads)
                        :pre (progn
                               (exwm-input-line-mode))
                        :post (progn
                                (exwm-input-char-mode)))

    "EXWM"
    ("b" my-counsel-ibuffer-by-exwm-class-name "buffer")

)
    #+END_SRC
**** buffers
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-buffers (
                         :color red
                         :hint  nil
                         :inherit (hydra-common/heads)
                         :pre (progn
                                (exwm-input-line-mode))
                         :post (progn
                                 (exwm-input-char-mode))
                         )
  "
                                                                     ╭─────────┐
  Window           Switch                    Do                      │ Buffers │
╭────────────────────────────────────────────────────────────────────┴─────────╯
     ↑          [_ss_] buffer         [_dw_] delete window
     _i_          [_sp_] projectile     [_do_] delete other windows
 ← _k_   _l_ →      [_se_] exwm           [_ds_] swap
     _o_          [_sb_] bookmarks      [_w_] grid
     ↓          [_st_] torus

   ^ ^
--------------------------------------------------------------------------------
    "
  ("i" windmove-up)
  ("o" windmove-down)
  ("k" windmove-left)
  ("l" windmove-right)

  ("I" buf-move-up)
  ("O" buf-move-down)
  ("K" buf-move-left)
  ("L" buf-move-right)

  ("s-l" split-window-right)
  ("s-k" split-window-left)
  ("s-o" split-window-below)
  ("s-i" split-window-up)

  ("dw" delete-window)
  ("do" delete-other-windows)
  ("ds" ace-swap-window)

  ("ss" my/switch-to-last-buffer)
  ("sp" counsel-projectile-switch-to-buffer)
  ("sb" hydra-bookmarks/body :color blue)
  ("st" hydra-torus/body :color blue)
  ("se" my-counsel-ibuffer-by-exwm-class-name)

  ("w" hycontrol-windows-grid)
  )
   #+END_SRC
***** torus
    #+BEGIN_SRC emacs-lisp
(defhydra hydra-torus (
                       :color red
                       :hint nil
                       :inherit (hydra-common/heads)
                       :pre (progn
                              (exwm-input-line-mode))
                       :post (progn
                               (exwm-input-char-mode)))
  "
                                                                                           ╭─────────┐
    Switch                    Move                        Do                               │  Torus  │
╭──────────────────────────────────────────────────────────────────────────────────────────┴─────────╯
  [_sc_] circle          [_<up>_]  prev-location         [_#_]  layout            [_ss_] search
  [_sl_] location       [_<down>_] next-location         [_ac_] add-circle        [_sh_] search-history
  [_st_] torus                                         [_al_] add-location
                     [_<left>_]  prev-circle
  [_!_] alt-circle     [_<right>_] next-circle          [_dc_] delete-circle
  [_<_] alt-circles                                   [_dl_] delete-location
  [_>_] alt-torus      [_<prior>_] newer-history
                     [_<next>_]  older-history
   ^ ^
-------------------------------------------------------------------------------------------------------
    "

("#" torus-layout-menu)

("sc" torus-switch-circle)
("sl" torus-switch-location)
("st" torus-switch-torus)

("ac" torus-add-circle)
("al" torus-add-location)

("dl" torus-delete-location)
("dc" torus-delete-circle)

("<up>"   torus-previous-location)
("<down>" torus-next-location)
("<left>" torus-previous-circle)
("<right>" torus-next-circle)


("ss" torus-search)
("sh" torus-search-history)

("<prior>" torus-history-newer)
("<next>" torus-history-older)

("!" torus-alternate-in-same-torus)
("<" torus-alternate-circles)
(">" torus-alternate-in-same-circle)
)

    #+END_SRC
***** bookmarks
    #+BEGIN_SRC emacs-lisp
(defhydra hydra-bookmarks (
                           :color red
                           :hint nil
                           :inherit (hydra-common/heads)
                           :pre (progn
                                  (exwm-input-line-mode))
                           :post (progn
                                   (exwm-input-char-mode)))

  "
                                                                   ╭───────────┐
       List                          Do                            │ Bookmarks │
╭──────────────────────────────────────────────────────────────────┴───────────╯
  [_l_] list bookmarks            [_j_] jump to a bookmark
   ^ ^                            [_m_] set bookmark at point
   ^ ^                            [_s_] save bookmarks
--------------------------------------------------------------------------------
    "
  ("l" counsel-bookmark)
  ("j" bookmark-jump)
  ("m" bookmark-set)
  ("s" bookmark-save))
    #+END_SRC
**** jump
    #+BEGIN_SRC emacs-lisp
(defhydra hydra-jump (:color blue :hint nil :inherit (hydra-common/heads)
                             :pre (progn
                                    (exwm-input-line-mode))
                             :post (progn
                                     (exwm-input-char-mode)))
  "
                                                                        ╭──────┐
  Window          WordChar        Line         iSearch                  │ Jump │
╭───────────────────────────────────────────────────────────────────────┴──────╯
  [_w_] jump        [_j_] word         [_l_] jump     [_i_] jump
  [_d_] close       [_p_] all words    [_y_] copy
  [_z_] maximize    [_b_] subword      [_m_] move
  [_s_] swap        [_c_] char         [_v_] copy region
   ^ ^              [_a_] two chars
--------------------------------------------------------------------------------
      "
  ("w" ace-window)
  ("d" ace-delete-window)
  ("z" ace-maximize-window)
  ("s" ace-swap-window)
  ("j" avy-goto-word-1)
  ("p" avy-goto-word-0)
  ("b" avy-goto-subword-0)
  ("c" avy-goto-char)
  ("a" avy-goto-char-2)
  ("l" avy-goto-line)
  ("y" avy-copy-line)
  ("m" avy-move-line)
  ("v" avy-copy-region)
  ("i" avy-isearch)
)
    #+END_SRC
***** register
    #+BEGIN_SRC emacs-lisp
(defhydra hydra-register (:color blue :hint nil :inherit (hydra-common/heads)
                                 :pre (progn
                                        (exwm-input-line-mode))
                                 :post (progn
                                         (exwm-input-char-mode)))

  "
                                                                        ╭──────────┐
       Logs                        Registers                Undo        │ Register │
    ╭───────────────────────────────────────────────────────────────────┴──────────╯
      [_c_] commands history       [^e^] emacs registers    [_u_] undo tree
      [_o_] messages               [_r_] evil registers
      [_l_] lossage (keystrokes)   [_m_] evil marks
      [_d_] diff buffer with file  [_k_] kill ring
    --------------------------------------------------------------------------------
          "
  ("d" joe-diff-buffer-with-file)
  ("k" counsel-yank-pop)
  ("l" view-lossage)
  ("c" counsel-command-history)
  ("m" evil-show-marks)
  ("o" view-echo-area-messages)
  ("r" evil-show-registers)
  ("u" undo-tree-visualize))
    #+END_SRC

**** search
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-search (:color blue :hint nil :inherit (hydra-common/heads)
                               :pre (progn
                                      (exwm-input-line-mode))
                               :post (progn
                                       (exwm-input-char-mode)))
  "
                                                                          ╭────────┐
       Files                             Buffer                           │ Search │
    ╭─────────────────────────────────────────────────────────────────────┴────────╯
      [_a_] regex search (Ag)           [_b_] by word
      [_r_] regex search (rg)           [_o_] by word (opened buffers)
      [_p_] regex search (pt)           [_w_] by word (multi)
      [_g_] regex search (grep)         [_h_] by word (grep or swiper)
      [^f^] find                        [_t_] tags & titles
      [_l_] locate                      [_s_] semantic
    --------------------------------------------------------------------------------
          "
  ("a" (let ((current-prefix-arg "-."))
         (call-interactively 'counsel-ag)))
  ("r" (let ((current-prefix-arg "-."))
         (call-interactively 'counsel-rg)))
  ("p" (let ((current-prefix-arg "-."))
         (call-interactively 'counsel-pt)))
  ("g" rgrep)
  ("l" counsel-locate)
  ("b" swiper)
  ("o" swiper-all)
  ("h" counsel-grep-or-swiper)
  ("t" counsel-imenu)
  ("s" counsel-semantic)
  ("w" swiper-multi))

   #+END_SRC
*** master
**** setup
  #+BEGIN_SRC emacs-lisp
(defhydra hydra-master (
                        :color blue
                        :pre (progn
                               (exwm-input-line-mode))
                        :post (progn
                                (exwm-input-char-mode))
                        :inherit (hydra-common/heads))
"
                                                                         ╭───────┐
                                                                         │ Home  │
╭────────────────────────────────────────────────────────────────────────┴───────╯
  [_p_] Projects   [_o_] Organization   [_f_] Files   [_e_] Emacs

-----------------------------------------------------------------------------------
      "

      ("p" hydra-projects/body nil)
      ("o" hydra-organization/body nil)
      ("f" hydra-file/body nil)
      ("e" hydra-emacs/body nil)
)
    #+END_SRC
**** projects
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-projects (:color blue :columns 4 :hint nil
                                :pre (progn
                                       (exwm-input-line-mode))
                                :post (progn
                                        (exwm-input-char-mode))
                                :inherit (hydra-common/heads))
  "
                                                                     ╭────────────┐
     Files             Search          Buffer             Do         │ Projectile │
   ╭─────────────────────────────────────────────────────────────────┴────────────╯
     [_f_] file          [_a_] ag          [_b_] switch         [_g_] magit
     [_l_] file dwim     [_r_] rg          [_v_] show all       [_p_] switch
     [_r_] recent file   [_s_] occur       [_V_] ibuffer        [_P_] commander
     [_d_] dir           [_S_] replace     [_K_] kill all       [_i_] info
     [_o_] other         [_t_] find tag
     [_u_] test file     [_T_] make tags
                                                                         ╭────────┐
     Other Window      Run             Cache              Do             │ Fixmee │
   ╭──────────────────────────────────────────────────╯ ╭────────────────┴────────╯
     [_F_] file          [_U_] test        [_kc_] clear         [_x_] TODO & FIXME
     [_L_] dwim          [_m_] compile     [_kk_] add current   [_X_] toggle
     [_D_] dir           [_c_] shell       [_ks_] cleanup
     [_O_] other         [_C_] command     [_kd_] remove
     [_B_] buffer
   --------------------------------------------------------------------------------
         "

  ("p"   projectile-switch-project)
  ("a"   counsel-projectile-ag)
  ("r"   counsel-projectile-rg)
  ("b"   counsel-projectile-switch-to-buffer)
  ("B"   counsel-projectile-switch-to-buffer-other-window)
  ("d"   counsel-projectile-find-dir)
  ("D"   counsel-projectile-find-dir-other-window)
  ("f"   counsel-projectile-find-file)
  ("F"   counsel-projectile-find-file-other-window)
  ("l"   counsel-projectile-find-file-dwim)
  ("L"   counsel-projectile-find-file-dwim-other-window)

  ("c"   projectile-run-async-shell-command-in-root)
  ("C"   projectile-run-command-in-root)
  ("g"   projectile-vc)
  ("i"   projectile-project-info)
  ("kc"  projectile-invalidate-cache)
  ("kd"  projectile-remove-known-project)
  ("kk"  projectile-cache-current-file)
  ("K"   projectile-kill-buffers)
  ("ks"  projectile-cleanup-known-projects)
  ("m"   projectile-compile-project)
  ("o"   projectile-find-other-file)
  ("O"   projectile-find-other-file-other-window)
  ("P"   projectile-commander)
  ("<tab>"   projectile-recentf)
  ("s"   projectile-multi-occur)
  ("S"   projectile-replace)
  ("t"   projectile-find-tag)
  ("T"   projectile-regenerate-tags)
  ("u"   projectile-find-test-file)
  ("U"   projectile-test-project)
  ("v"   projectile-display-buffer)
  ("V"   projectile-ibuffer)

  ("X"   fixmee-mode)
  ("x"   fixmee-view-listing))

(define-key projectile-mode-map (kbd "C-c o") #'hydra-project/body)

   #+END_SRC
**** organization
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-organization (
                              :color blue
                              :hint nil
                              :inherit (hydra-common/heads)
                              :pre (progn
                                     (exwm-input-line-mode))
                              :post (progn
                                      (exwm-input-char-mode)))

     "
                                                                 ╭──────────────┐
      Tasks            Org mode               Comms      Others  │ Organization │
 ╭───────────────────────────────────────────────────────────────┴──────────────╯
   [_a_] agenda      [_c_] capture             [_m_] mail      [_x_] speed type
   [_l_] agenda list [_p_] pomodoro            [_t_] contacts
   [_d_] calendar    [_s_] search headings     [_h_] add location
    ^ ^              [_g_] open location gmaps
    ^ ^              [_f_] archive subtree
 --------------------------------------------------------------------------------
       "
     ("a" org-agenda)
     ("c" org-capture)
     ("s" counsel-org-agenda-headlines)
     ("d" cfw:open-org-calendar)
     ("g" org-location-google-maps)
     ("h" org-address-google-geocode-set)
     ("l" org-agenda-list)
     ("f" org-archive-subtree)
     ("m" mu4e)
     ("p" org-pomodoro)
     ("t" org-contacts)
     ("x" speed-type-text))
   #+END_SRC
**** emacs
    #+BEGIN_SRC emacs-lisp
(defhydra hydra-emacs (:color blue :hint nil :inherit (hydra-common/heads)
                              :pre (progn
                                     (exwm-input-line-mode))
                              :post (progn
                                      (exwm-input-char-mode)))

  "
                                                                       ╭───────┐
   Execute       Packages         Help                     Misc        │ Emacs │
╭──────────────────────────────────────────────────────────────────────┴───────╯
  [_x_] counsel M-x [_p_] list      [_f_] describe function [_t_] change theme
  [_e_] exit        [_i_] install   [_v_] describe variable [_l_] list emacs process
  [_s_] system      [_u_] upgrade   [_m_] info manual       [_c_] init time
   ^ ^               ^ ^            [_k_] bindings          [_o_] unbound commands
   ^ ^               ^ ^            [_b_] personal bindings [_y_] emacs colors
   ^ ^               ^ ^             ^ ^                    [_z_] list faces
   ^ ^               ^ ^             ^ ^
--------------------------------------------------------------------------------
      "
  ("C-h b" counsel-descbinds "bindings")
  ("f" counsel-describe-function)
  ("v" counsel-describe-variable)
  ("b" describe-personal-keybindings)
  ("c" emacs-init-time)
  ("i" package-install)
  ("k" counsel-descbinds)
  ("l" list-processes)
  ("m" info-display-manual)
  ("p" paradox-list-packages)
  ("t" counsel-load-theme)
  ("u" paradox-upgrade-packages)
  ("o" smex-show-unbound-commands)
  ("y" counsel-colors-emacs)
  ("z" counsel-faces)
  ("x" counsel-M-x)
  ("e" save-buffers-kill-emacs)
  ("s" hydra-system/body nil)
)
    #+END_SRC

***** system
    #+BEGIN_SRC emacs-lisp
  (defhydra hydra-system (:color blue :hint nil :inherit (hydra-common/heads)
                                 :pre (progn
                                        (exwm-input-line-mode))
                                 :post (progn
                                         (exwm-input-char-mode)))

      "
                                                                      ╭────────┐
   Terminals                     System                               │ System │
╭─────────────────────────────────────────────────────────────────────┴────────╯
  [_s_] new multi-term           [_c_] shell command
  [_n_] next multi-term          [_a_] aync shell command
  [_p_] previous multi-term      [_m_] man page
  [_d_] dedicated multi-term     [_l_] list system process
  [_e_] eshell
--------------------------------------------------------------------------------
      "
      ("a" async-shell-command)
      ("c" shell-command)
      ("e" eshell)
      ("m" man)
      ("l" proced)
      ("s" multi-term)
      ("n" multi-term-next)
      ("p" multi-term-previous)
      ("d" multi-term-dedicated-toggle))

    #+END_SRC

**** file
    #+BEGIN_SRC emacs-lisp
(defhydra hydra-file (:color blue :hint nil :inherit (hydra-common/heads)
                             :pre (progn
                                    (exwm-input-line-mode))
                             :post (progn
                                     (exwm-input-char-mode)))
  "
                                                                        ╭──────┐
     Ivy                    Dired            Hydras                     │ File │
╭───────────────────────────────────────────────────────────────────────┴──────╯
  [_f_] open file            [_d_] dired     [_t_] text
  [_e_] open file extern                   [_s_] spell
                                         [_n_] narrow
                                         [_g_] git
--------------------------------------------------------------------------------
      "
  ("f" counsel-find-file)
  ("e" counsel-find-file-extern)
  ("d" dired)
  ("n" hydra-narrow/body nil :color blue)
  ("s" hydra-spell/body nil  :color blue)
  ("t" hydra-text/body nil   :color blue)
  ("g" hydra-git/body nil   :color blue)
)
    #+END_SRC
***** narrow
    #+BEGIN_SRC emacs-lisp
(defhydra hydra-narrow (:color blue :hint nil :inherit (hydra-common/heads)
                               :pre (progn
                                      (exwm-input-line-mode))
                               :post (progn
                                       (exwm-input-char-mode)))
      "
                                                                      ╭────────┐
    Narrow                                                            │ Narrow │
╭─────────────────────────────────────────────────────────────────────┴────────╯
  [_f_] narrow to defun
  [_p_] narrow to page
  [_r_] narrow to region
  [_w_] widen
--------------------------------------------------------------------------------
      "
      ("f" narrow-to-defun)
      ("p" narrow-to-page)
      ("r" narrow-to-region)
      ("w" widen))
    #+END_SRC

***** spell
     #+BEGIN_SRC emacs-lisp
(defhydra hydra-spell (:color blue :hint nil :inherit (hydra-common/heads)
                              :pre (progn
                                     (exwm-input-line-mode))
                              :post (progn
                                      (exwm-input-char-mode)))
  "
                                                                       ╭───────┐
    Flyspell               Ispell                      Gtranslate      │ Spell │
╭──────────────────────────────────────────────────────────────────────┴───────╯
  [_k_] correct word       [_w_] check word            [_g_] en ⇆ es
  [_n_] next error                                     [_G_] any lang
  [_f_] toggle flyspell
  [_p_] toggle prog mode
--------------------------------------------------------------------------------
      "
  ("w" ispell-word)
  ("d" ispell-change-dictionary)
  ("g" google-translate-smooth-translate)
  ("G" google-translate-query-translate)
  ("f" flyspell-mode)
  ("p" flyspell-prog-mode)
  ("k" flyspell-correct-word-generic)
  ("n" flyspell-goto-next-error))
     #+END_SRC

***** text
    #+BEGIN_SRC emacs-lisp
(defhydra hydra-text (:color blue :hint nil :inherit (hydra-common/heads)
                             :pre (progn
                                    (exwm-input-line-mode))
                             :post (progn
                                     (exwm-input-char-mode)))

  "
                                                                             ╭──────┐
      Size  Toggle              Unicode                        Do            │ Text │
     ╭───────────────────────────────────────────────────────────────────────┴──────╯
       _k_  [_f_] fill column     [_d_] unicode character           [_a_] align with regex
       ^↑^  [_h_] hidden chars    [_e_] evil digraphs table         [_w_] remove trailing ' '
       ^ ^  [_l_] line numbers    [_s_] specific code block         [_n_] count words
       ^↓^  [_t_] trailing ' '    [_u_] unicode character           [_i_] lorem ipsum
       _j_  [_v_] font space      [_p_] character code              [_x_] comment box
       ^ ^  [_c_] comment          ^ ^                              [_q_] boxquote
       ^ ^  [_b_] multibyte chars  ^ ^                              [_m_] iedit (multiple)
       ^ ^   ^ ^                   ^ ^                              [_r_] expand region
       ^ ^   ^ ^                   ^ ^                              [_U_] tabs to spaces
     --------------------------------------------------------------------------------
           "
  ("a" align-regexp)
  ("b" toggle-enable-multibyte-characters)
  ("c" comment-line)
  ("d" insert-char)
  ("e" evil-ex-show-digraphs)
  ("f" fci-mode)
  ("h" whitespace-mode)
  ("i" lorem-ipsum-insert-paragraphs)
  ("k" text-scale-increase :color red)
  ("j" text-scale-decrease :color red)
  ("l" linum-mode)
  ("n" count-words)
  ("m" iedit)
  ("p" describe-char)
  ("r" er/expand-region)
  ("s" charmap)
  ("t" joe-toggle-show-trailing-whitespace)
  ("u" counsel-unicode-char)
  ("v" variable-pitch-mode)
  ("w" whitespace-cleanup)
  ("U" untabify)
  ("q" hydra-boxquote/body)
  ("x" comment-box))
    #+END_SRC

***** git
     #+BEGIN_SRC emacs-lisp
(defhydra hydra-git (:color blue :hint nil :inherit (hydra-common/heads)
                            :pre (progn
                                   (exwm-input-line-mode))
                            :post (progn
                                    (exwm-input-char-mode)))
  "
                                                                         ╭─────┐
   Magit                          VC                    Timemachine      │ Git │
╭────────────────────────────────────────────────────────────────────────┴─────╯
  [_s_] status              [_d_] diffs between revisions  [_t_] timemachine
  [_B_] blame mode          [_b_] edition history
  [_l_] file log
--------------------------------------------------------------------------------
      "
  ("B" magit-blame)
  ("b" vc-annotate)
  ("d" vc-diff)
  ("l" magit-log-buffer-file)
  ("s" magit-status)
  ("t" git-timemachine))
     #+END_SRC

* Activities
** GTD
#+BEGIN_SRC emacs-lisp
 (defvar org-default-projects-dir   "~/org/projects"                     "Primary GTD directory")
 (defvar org-default-zettelkasten-dir "~/org/notes"                     "Directory of notes modeled after Zettelkasten includes an Archive, and Notes")
 (defvar org-default-completed-dir  "~/org/projects/completed"            "Directory of completed project files")
 (defvar org-default-inbox-file     "~/org/agenda/inbox.org"         "New stuff collects in this file")
 (defvar org-default-tasks-file     "~/org/agenda/tasks.org"           "Tasks, TODOs and little projects")
 (defvar org-default-incubate-file  "~/org/agenda/incubate.org"        "Ideas simmering on back burner")
 (defvar org-default-calendar-file  "~/org/agenda/calendar.org"        "Ideas simmering on back burner")
 (defvar org-default-delegate-file  "~/org/agenda/delegate.org"        "Ideas simmering on back burner")
 (defvar org-default-waiting-file  "~/org/agenda/waiting.org"        "Ideas simmering on back burner")
 (defvar org-default-completed-file nil                              "Ideas simmering on back burner")
 (defvar org-default-notes-file     "~/org/agenda/inbox.org"   "Non-actionable, personal notes")

 (defhydra hydra-org-refiler (org-mode-map "C-c s" :hint nil)
     "
   ^Refile^       ^Calendar^            ^Ref^           ^Move^         ^Update^           ^Go To^
   ^^^^^^^^^^------------------------------------------------------------------------------------------
   _t_: tasks      _c c_: calendar  _z d_: web      _m p_: projects   _T_: todo       _g t_: tasks
   _i_: incubate   _c t_: tickler   _z w_: docs     _m n_: notes      _S_: schedule   _g i_: incubate
   _w_: waiting    _c d_: delegate  _z i_: images                   _D_: deadline   _g x_: inbox
   _r_: refile                                                  _R_: rename     _g w_: waiting
                                                                            _g p_: projects
                                                                            _g c_: completed
   "
     ("<up>" org-previous-visible-heading)
     ("<down>" org-next-visible-heading)
     ("k" org-previous-visible-heading)
     ("j" org-next-visible-heading)

     ("t" org-refile-to-task)
     ("i" org-refile-to-incubate)
    ("r" org-refile)
    ("w" org-refile-to-waiting)
    ("c c" refile-to-calendar)
    ("c t" refile-to-tickler)
    ("c d" org-refile-to-delegate)

    ("z d" note-to-documents)
    ("z w" note-to-websites)
    ("z i" note-to-images)

     ("m p" org-refile-to-projects-dir)
     ("m n" my/refile-to-zettelkasten)
     ("T" org-todo)
     ("S" org-schedule)
     ("D" org-deadline)
     ("R" org-rename-header)
     ("g t" (find-file org-default-tasks-file))
     ("g i" (find-file org-default-incubate-file))
     ("g w" (find-file org-default-waiting-file))
     ("g x" (find-file org-default-inbox-file))
     ("g c" (find-file org-default-completed-file))
     ("g p" (dired org-default-projects-dir))
     ("g c" (dired org-default-completed-dir))
     ("[\t]" (org-cycle))



     ("s" (org-save-all-org-buffers) "save")

     ("a" org-archive-subtree-as-completed "archive")
     ("d" org-cut-subtree "delete")
     ("q" (switch-to-buffer "*dashboard*") "dashboard" :color blue))



 (setq org-refile-use-outline-path 'file
       org-outline-path-complete-in-steps nil)


 (defun org-subtree-region ()
   "Return a list of the start and end of a subtree."
   (save-excursion
     (list (progn (org-back-to-heading) (point))
           (progn (org-end-of-subtree)  (point)))))

 (defvar org-refile-directly-show-after nil
   "When refiling directly (using the `org-refile-directly'
 function), show the destination buffer afterwards if this is set
 to `t', otherwise, just do everything in the background.")

 (defun org-refile-directly (file-dest)
   "Move the current subtree to the end of FILE-DEST.
 If SHOW-AFTER is non-nil, show the destination window,
 otherwise, this destination buffer is not shown."
   (interactive "fDestination: ")

   (defun dump-it (file contents)
     (find-file-other-window file-dest)
     (goto-char (point-max))
     (insert "\n" contents))

   (save-excursion
     (let* ((region (org-subtree-region))
            (contents (buffer-substring (first region) (second region))))
       (apply 'kill-region region)
       (if org-refile-directly-show-after
           (save-current-buffer (dump-it file-dest contents))
         (save-window-excursion (dump-it file-dest contents))))))

 (defun org-refile-to-incubate ()
   "Refile (move) the current Org subtree to `org-default-incubate-file'."
   (interactive)
   (org-todo "HOLD")
   (org-refile-directly org-default-incubate-file)
   (kill-line)
   )

 (defun org-refile-to-waiting ()
   "Refile (move) the current Org subtree to `org-default-incubate-file'."
   (interactive)
   (org-todo "WAITING")

   (org-refile-directly org-default-waiting-file)
   (kill-line)
 )

 (defun org-refile-to-calendar ()
   "Refile (move) the current Org subtree to `org-default-incubate-file'."
   (interactive)
   (org-todo "TODO")

   (org-refile-directly org-default-calendar-file)
   (kill-line)

 )



 (defun org-refile-to-task ()
   "Refile (move) the current Org subtree to `org-default-tasks-file'."
   (interactive)
   (org-todo "TODO")

   (org-refile-directly org-default-tasks-file)
   (kill-line)
 )

 (defun org-refile-to-personal-notes ()
   "Refile (move) the current Org subtree to `org-default-notes-file'."
   (interactive)

   (org-refile-directly org-default-notes-file))

 (defun org-refile-to-completed ()
   "Refile (move) the current Org subtree to `org-default-completed-file',
 unless it doesn't exist, in which case, refile to today's journal entry."
   (interactive)
   (if (and org-default-completed-file (file-exists-p org-default-completed-file))
       (org-refile-directly org-default-completed-file)
     (org-refile-directly (get-journal-file-today))))

 (defun org-rename-header (label)
   "Rename the current section's header to LABEL, and moves the
 point to the end of the line."
   (interactive (list
                 (read-string "Header: "
                              (substring-no-properties (org-get-heading t t t t)))))
   (org-back-to-heading)
   (replace-string (org-get-heading t t t t) label))

 (defun org-archive-subtree-as-completed ()
   "Archives the current subtree to today's current journal entry."
   (interactive)
   (ignore-errors
     ;; According to the docs for `org-archive-subtree', the state should be
     ;; automatically marked as DONE, but I don't notice that:
     (when (not (equal "DONE" (org-get-todo-state)))
       (org-todo "DONE")))

   (let* ((org-archive-file (or org-default-completed-file
				(todays-journal-entry)))
          (org-archive-location (format "%s::" org-archive-file)))
      (org-archive-subtree)))

 (defun todays-journal-entry ()
   "Return the full pathname to the day's journal entry file.
 Granted, this assumes each journal's file entry to be formatted
 with year/month/day, as in `20190104' for January 4th.

 Note: `org-journal-dir' variable must be set to the directory
 where all good journal entries live, e.g. ~/journal."
   (let* ((daily-name   (format-time-string "%Y-%m-%d"))
          (file-name    (concat org-journal-dir daily-name)))
     (expand-file-name file-name)))

 ;; Attempt to load the extra library functions tangled from a different essay:
 (condition-case nil
     (load-library "boxes-extras")
   (error
    (defun org-refile-to-projects-dir ()
      (interactive)
      (message "Need to load the 'boxes-extra project first."))
    (defun org-refile-to-personal-dir ()
      (interactive)
      (message "Need to load the 'boxes-extra project first."))))

 (defun org-boxes-workflow ()
   "Load the default tasks file and start our hydra on the first task shown."
   (interactive)
   (find-file org-default-inbox-file)
     ;(delete-other-windows)
     (goto-char (point-min))
     (org-next-visible-heading 2)
     (hydra-org-refiler/body))

 (defun org-agenda-workflow ()
   "Load the default tasks file and start our hydra on the first task shown."
   (interactive)
   (let ((org-startup-folded nil))
     (delete-other-windows)
     (ignore-errors
       (ha/org-agenda))
     (delete-other-windows)
     (hydra-org-agenda/body)))


 (defun ha/org-agenda ()
   "Displays my favorite agenda perspective."
   (interactive)
   (org-agenda nil "a"))

 (defun org-subtree-metadata ()
   "Return a list of key aspects of an org-subtree. Includes the
 following: header text, body contents, list of tags, region list
 of the start and end of the subtree."
   (save-excursion
     ;; Jump to the parent header if not already on a header
     (when (not (org-at-heading-p))
       (org-previous-visible-heading 1))

     (let* ((context (org-element-context))
            (attrs   (second context))
            (props   (org-entry-properties)))

       (list :region     (list (plist-get attrs :begin) (plist-get attrs :end))
             :header     (plist-get attrs :title)
             :tags       (org-get-subtree-tags props)
             :properties (org-get-subtree-properties attrs)
             :body       (org-get-subtree-content attrs)))))

 (defun org-get-subtree-tags (&optional props)
   "Given the properties, PROPS, from a call to
 `org-entry-properties', return a list of tags."
   (unless props
      (setq props (org-entry-properties)))
   (let ((tag-label (if org-get-subtree-tags-inherited "ALLTAGS" "TAGS")))
     (-some->> props
          (assoc tag-label)
          cdr
          substring-no-properties
          (s-split ":")
          (--filter (not (equalp "" it))))))

 (defvar org-get-subtree-tags-inherited t
   "Returns a subtree's tags, and all tags inherited (from tags
   specified in parents headlines or on the file itself). Defaults
   to true.")

 (defun org-get-subtree-properties (attributes)
   "Return a list of tuples of a subtrees properties where the keys are strings."

   (defun symbol-upcase? (sym)
     (let ((case-fold-search nil))
       (string-match-p "^:[A-Z]+$" (symbol-name sym))))

   (defun convert-tuple (tup)
     (let ((key (first tup))
           (val (second tup)))
       (list (substring (symbol-name key) 1) val)))

   (->> attributes
	(-partition 2)                         ; Convert plist to list of tuples
	(--filter (symbol-upcase? (first it))) ; Remove lowercase tuples
	(-map 'convert-tuple)))

 (defun org-get-subtree-content (attributes)
   "Return the contents of the current subtree as a string."
   (let ((header-components '(clock diary-sexp drawer headline inlinetask
                              node-property planning property-drawer section)))

       (goto-char (plist-get attributes :contents-begin))

       ;; Walk down past the properties, etc.
       (while
           (let* ((cntx (org-element-context))
                  (elem (first cntx))
                  (props (second cntx)))
             (when (member elem header-components)
               (goto-char (plist-get props :end)))))

       ;; At this point, we are at the beginning of what we consider
       ;; the contents of the subtree, so we can return part of the buffer:
       (buffer-substring-no-properties (point) (org-end-of-subtree))))

(defun org-refile-subtree-to-file (dir)
  "Archive the org-mode subtree and create an entry in the
directory folder specified by DIR. It attempts to move as many of
the subtree's properties and other features to the new file."
  (interactive "DDestination: ")
  (let* ((props      (org-subtree-metadata))
         (head       (plist-get props :header))
         (body       (plist-get props :body))
         (tags       (plist-get props :tags))
         (properties (plist-get props :properties))
         (area       (plist-get props :region))
         (filename   (org-filename-from-title head))
         (filepath   (format "%s/%s.org" dir filename)))
    (apply #'delete-region area)
    (org-create-org-file filepath head body tags properties)))

 (defun org-refile-notes-to-file (dir)
   "Archive the org-mode subtree and create an entry in the
 directory folder specified by DIR. It attempts to move as many of
 the subtree's properties and other features to the new file."
   (interactive "DDestination: ")
   (let* ((props      (org-subtree-metadata))
          (head       (plist-get props :header))
          (body       (plist-get props :body))
          (tags       (plist-get props :tags))
;          (properties (plist-get props :properties))
          (area       (plist-get props :region))
          (filename   (concat (format-time-string "%Y-%m-%dT%H.%M.%S")))
          (filepath   (format "%s/%s.org" dir filename)))
     (apply #'delete-region area)
     (org-create-notes-file filepath head body tags)))



(defun org-create-notes-file (filepath header body tags)
   "Create a new Org file by FILEPATH. The contents of the file is
 pre-populated with the HEADER, BODY and any associated TAGS."
   (find-file filepath)
   (org-set-file-property "TITLE" header t)
   (org-set-file-property "DATE" (format-time-string "[%Y-%m-%d %H:%M]"))
   (org-set-file-property "KEYWORDS" (s-join "" tags))
  (goto-char (point-min))
   (when (re-search-forward "REFILE" nil t)
    (replace-match ""))


   (delete-blank-lines)
   (goto-char (point-max))

   (insert "\n\n")
   (insert body)
   (goto-char (point-min))
   (save-buffer))



(defun org-create-org-file (filepath header body tags properties)
  "Create a new Org file by FILEPATH. The contents of the file is
pre-populated with the HEADER, BODY and any associated TAGS."
  (find-file-other-window filepath)
  (org-set-file-property "TITLE" header t)
  (org-set-file-property "CATEGORY" "project")
  (when tags
    (org-set-file-property "FILETAGS" (s-join " " tags)))

 ;;  Insert any drawer properties as #+PROPERTY entries:
    (when properties
    (goto-char (point-min))
    (or (re-search-forward "^\s*_\s$" nil t) (point-max))
    (--map (insert (format "#+PROPERTY: %s %s\n" (first it) (second it))) properties))

  ;; My auto-insert often adds an initial headline for a subtree, and in this
  ;; case, I don't want that... Yeah, this isn't really globally applicable,
  ;; but it shouldn't cause a problem for others.
  (when (re-search-forward "^\\* [0-9]$" nil t)
    (replace-match ""))

  (delete-blank-lines)
  (goto-char (point-max))
  (insert "\n")
  (insert "\n")
  (insert "* " header)
  (insert body))


 (defun org-filename-from-title (title)
   "Creates a useful filename based on a header string, TITLE.
 For instance, given the string:    What's all this then?
      This function will return:    whats-all-this-then"
   (let* ((no-letters (rx (one-or-more (not alphanumeric))))
          (init-try (->> title
                         downcase
                         (replace-regexp-in-string "'" "")
                         (replace-regexp-in-string no-letters "-"))))
     (string-trim init-try "-+" "-+")))

 (defun org-set-file-property (key value &optional spot)
   "Make sure file contains a top-level, file-wide property.
 KEY is something like `TITLE' or `FILETAGS'. This function makes
 sure that the property contains the contents of VALUE, and if the
 file doesn't have the property, it is inserted at either SPOT, or
 if nil,the top of the file."
   (save-excursion
     (goto-char (point-min))
     (let ((case-fold-search t))
       (if (re-search-forward (format "^#\\+%s:\s*\\(.*\\)" key) nil t)
           (replace-match value nil nil nil 1)

         (cond
          ;; if SPOT is a number, go to it:
          ((numberp spot) (goto-char spot))
          ;; If SPOT is not given, jump to first blank line:
          ((null spot) (progn (goto-char (point-min))
                              (re-search-forward "^\s*$" nil t)))
          (t (goto-char (point-min))))

         (insert (format "#+%s: %s\n" (upcase key) value))))))



 (defun org-refile-to-projects-dir ()
   "Move the current subtree to a file in the `projects' directory."
   (interactive)
   (org-refile-subtree-to-file org-default-projects-dir))

 (defun org-refile-to-technical-dir ()
   "Move the current subtree to a file in the `technical' directory."
   (interactive)
   (org-refile-subtree-to-file org-default-technical-dir))

 (defun org-refile-to-personal-dir ()
   "Move the current subtree to a file in the `personal' directory."
   (interactive)
   (org-refile-subtree-to-file org-default-personal-dir))

 (defun org-refile-to-zettelkasten-dir ()
   "Move the current subtree to a file in the `zettelkasten' directory."
   (interactive)
   (org-refile-notes-to-file org-default-zettelkasten-dir))

 ;; (defun org-refile-to-zettelkasten-dir ()
 ;;   "Move the current subtree to a file in the `zettelkasten' directory."
 ;;   (interactive)
 ;;   (org-refile-subtree-to-file org-default-zettelkasten-dir))




(defun org-refile-to-headline (file headline)
  (let ((pos (save-excursion
               (find-file file)
               (org-find-exact-headline-in-buffer headline))))
    (org-refile nil nil (list headline file nil pos))
    (switch-to-buffer (current-buffer))))


(defun org-refile-to-process ()
   "Refile (move) the current Org subtree to `org-default-incubate-file'."
   (interactive)

   (org-refile-directly "~/org/notes/process.org")
   (kill-line)
 )

(defun org-refile-to-cross-ref ()
   "Refile (move) the current Org subtree to `org-default-incubate-file'."
   (interactive)

   (org-refile-directly "~/org/notes/cross-reference.org")
   (kill-line)
 )


(defun note-to-websites ()
(interactive)
(org-refile-to-headline org-file-reference "Websites"))

(defun note-to-images ()
(interactive)
(org-refile-to-headline org-file-reference "Images"))

(defun note-to-videos ()
(interactive)
(org-refile-to-headline org-file-reference "Videos"))

(defun note-to-audio ()
(interactive)
(org-refile-to-headline org-file-reference "Audio"))

(defun note-to-documents ()
(interactive)
(org-refile-to-headline org-file-reference "Documents"))

(defun refile-to-tickler ()
(interactive)
(org-refile-to-headline org-file-calendar "Tickler"))

(defun refile-to-calendar ()
(interactive)
(org-refile-to-headline org-file-calendar "Calendar"))

(defun org-refile-to-delegate ()
   "Refile (move) the current Org subtree to `org-default-incubate-file'."
   (interactive)
   (org-todo "DELEGATE")

   (org-refile-directly org-default-delegate-file)
   (kill-line))

(provide 'gtd)
#+END_SRC

** Journal
#+BEGIN_SRC emacs-lisp
(setq journal-author "Alexander Soto")

;; This is the base folder where all your "books"
;; will be stored.
(setq journal-base-dir "~/org/notes")


;; These are your "books" (folders), add as many as you like.
;; Note: "sub volumes" are acheivable with sub folders.
(setq journal-books
      '("projects"
       "personal"))

;; Functions for journal
(defun get-journal-file-today (book)
  "Return today's filename for a books journal file."
  (interactive (list (completing-read "Book: " journal-books) ))
(cond

((string-match "personal" book)
(expand-file-name
(concat journal-base-dir book "/"
(format-time-string "%Y-%m-%dT%H.%M.%S") ".org.gpg" )))

((unless (equal book '("personal"))
(expand-file-name
(concat journal-base-dir book "/"
(format-time-string "%Y-%m-%dT%H.%M.%S") ".org" ))))))


;  (expand-file-name
;   (concat journal-base-dir book "/" (format-time-string "%Y%m%d") ".org" )) )



(defun journal-today ()
  "Load todays journal entry for book"
  (interactive)
  (auto-insert-mode)
  (find-file (call-interactively 'get-journal-file-today)) )

(defun journal-entry-date ()
  "Inserts the journal heading based on the file's name."
  (when (string-match
   "\\(20[0-9][0-9]\\)\\([0-9][0-9]\\)\\([0-9][0-9]\\)\\(.org\\)"
   (buffer-name))
    (let ((year  (string-to-number (match-string 2 (buffer-name))))
          (month (string-to-number (match-string 3 (buffer-name))))
          (day   (string-to-number (match-string 4 (buffer-name))))
          (datim nil))
      (setq datim (encode-time 0 0 0 day month year))
      (format-time-string "%Y-%m-%d (%A)" datim))))

;; Auto-insert journal header

(eval-after-load 'autoinsert
  '(define-auto-insert
     '("\\(20[0-9][0-9]\\)\\(-\\)\\([0-9][0-9]\\)\\(-\\)\\([0-9][0-9]\\)\\(-\\)\\([0-9][0-9][0-9][0-9][0-9][0-9]\\)\\(.*\\)" . "Journal Header")
     '("Short description: "
       "#+TITLE: "
       (read-string "Title: ") \n
       "#+DATE: " (format-time-string "[%Y-%m-%d %H:%M]") \n
       "#+KEYWORDS: "
       (read-string "Keyword: ") \n \n

       > _ \n \n \n \n \n
"
---
,*Related:*


---
,*References:*
"

       )))

;; Journal Key bindings


(provide 'journal)

#+END_SRC
** Org-agenda
*** variables
 #+BEGIN_SRC emacs-lisp
(setq org-agenda-auto-exclude-function 'bh/org-auto-exclude-function)

(setq org-agenda-clock-consistency-checks
      (quote (:max-duration "4:00"
                            :min-duration 0
                            :max-gap 0
                            :gap-ok-around ("4:00"))))

;; Agenda clock report parameters
(setq org-agenda-clockreport-parameter-plist
      (quote (:link t :maxlevel 5 :fileskip0 t :compact t :narrow 80)))

;; Agenda log mode items to display (closed and state changes by default)
(setq org-agenda-log-mode-items (quote (closed clock state)))

;; For tag searches ignore tasks with scheduled and deadline dates
(setq org-agenda-tags-todo-honor-ignore-options t)

(setq org-show-entry-below (quote ((default))))

;; Limit restriction lock highlighting to the headline only
(setq org-agenda-restriction-lock-highlight-subtree nil)

;; Always hilight the current agenda line
(add-hook 'org-agenda-mode-hook
          '(lambda () (hl-line-mode 1))
          'append)

;; Keep tasks with dates on the global todo lists
(setq org-agenda-todo-ignore-with-date nil)

;; Keep tasks with deadlines on the global todo lists
(setq org-agenda-todo-ignore-deadlines nil)

;; Keep tasks with scheduled dates on the global todo lists
(setq org-agenda-todo-ignore-scheduled nil)

;; Keep tasks with timestamps on the global todo lists
(setq org-agenda-todo-ignore-timestamp nil)

;; Remove completed deadline tasks from the agenda view
(setq org-agenda-skip-deadline-if-done nil)

;; Remove completed scheduled tasks from the agenda view
(setq org-agenda-skip-scheduled-if-done nil)

;; Remove completed items from search results
(setq org-agenda-skip-timestamp-if-done nil)

;; Skip scheduled items if they are repeated beyond the current deadline.
(setq org-agenda-skip-scheduled-if-deadline-is-shown  (quote repeated-after-deadline))

(setq org-agenda-include-diary nil)
(setq org-agenda-insert-diary-extract-time t)

(setq org-default-notes-file "~/org/notes/inbox.org")

;; =TODO= state keywords and colour settings:
(setq org-todo-keywords
      (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
              (sequence "WAITING(w)" "HOLD(h)" "DELEGATE(D)" "|" "CANCELLED(c@/!)" "MEETING" "SCHEDULED"))))

;; ;; TODO Other todo keywords doesn't have appropriate faces yet. They should
;; ;; have faces similar to spacemacs defaults.
(setq org-todo-keyword-faces
      (quote (("TODO" :foreground "red" :weight bold)
              ("NEXT" :foreground "#007cee" :weight bold)
              ("DONE" :foreground "forest green" :weight bold)
              ("WAITING" :foreground "orange" :weight bold)
              ("DELEGATE" :foreground "purple" :weight bold)
              ("HOLD" :foreground "magenta" :weight bold)
              ("CANCELLED" :foreground "red" :weight bold)
              ("MEETING" :foreground "forest green" :weight bold)
              ("SCHEDULED" :foreground "forest green" :weight bold))))

(setq org-use-fast-todo-selection t)

;; This cycles through the todo states but skips setting timestamps and
;; entering notes which is very convenient when all you want to do is fix
;; up the status of an entry.
(setq org-treat-S-cursor-todo-selection-as-state-change nil)

(setq org-todo-state-tags-triggers
      (quote (("CANCELLED" ("CANCELLED" . t))
              ("WAITING" ("WAITING" . t))
              ("HOLD" ("WAITING") ("HOLD" . t))
              (done ("WAITING") ("HOLD"))
              ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
              ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
              ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))

(setq org-refile-targets (quote ((nil :maxlevel . 9)
                                 (org-agenda-files :maxlevel . 9)
                                 )))

(setq org-refile-use-outline-path 'file
      org-indent-indentation-per-level nil
      org-outline-path-complete-in-steps nil)


;; Allow refile to create parent tasks with confirmation
(setq org-refile-allow-creating-parent-nodes (quote confirm))

(setq org-refile-target-verify-function 'bh/verify-refile-target)

;; Show lot of clocking history so it's easy to pick items off the C-F11 list
(setq org-clock-history-length 23)
;; Resume clocking task on clock-in if the clock is open
(setq org-clock-in-resume t)
;; Change tasks to NEXT when clocking in
(setq org-clock-in-switch-to-state 'bh/clock-in-to-next)
;; Separate drawers for clocking and logs
(setq org-drawers (quote ("PROPERTIES" "LOGBOOK")))
;; Save clock data and state changes and notes in the LOGBOOK drawer
(setq org-clock-into-drawer t)

(setq org-log-into-drawer t)
;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
(setq org-clock-out-remove-zero-time-clocks t)
;; Clock out when moving task to a done state
(setq org-clock-out-when-done t)
;; Save the running clock and all clock history when exiting Emacs, load it on startup
(setq org-clock-persist t)
;; Do not prompt to resume an active clock
(setq org-clock-persist-query-resume nil)
;; Enable auto clock resolution for finding open clocks
                                        ;(setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
(setq org-clock-auto-clock-resolution nil)
;; Include current clocking task in clock reports
(setq org-clock-report-include-clocking-task t)
;; Resolve open clocks if the user is idle for more than 10 minutes.
(setq org-clock-idle-time 10)
;;
;; Resume clocking task when emacs is restarted
(org-clock-persistence-insinuate)

(setq bh/keep-clock-running nil)


(setq org-time-stamp-rounding-minutes (quote (1 1)))
;; ;; Sometimes I change tasks I'm clocking quickly - this removes clocked
;; ;; tasks with 0:00 duration
;; (setq org-clock-out-remove-zero-time-clocks t)

;; Set default column view headings: Task Effort Clock_Summary
(setq org-columns-default-format
      "%1PRIORITY %50ITEM %13AREA %10DEADLINE %50OUTCOME %10Effort(Effort){:} %10CLOCKSUM")
;; global Effort estimate values
;; global STYLE property values for completion
(setq org-global-properties (quote (("Effort_ALL" . "0:15 0:30 0:45 1:00 2:00 3:00 4:00 5:00 6:00 0:00")
                                    ("STYLE_ALL" . "habit"))))
;; Tags with fast selection keys
(setq org-tag-alist (quote ((:startgroup)
                            (:endgroup)
                            ("WAITING" . ?w)
                            ("HOLD" . ?h)
                            ("NOTE" . ?n)
                            ("CANCELLED" . ?c)
                            ("FLAGGED" . ??))))

(setq org-agenda-hide-tags-regexp "noexport\\|HOLD\\|REFILE\\|ARCHIVE\\|NOW\\|ignore\\|WAITING\\|nobrain\\|connect\\|clarify\\|capture\\|ATTACH")

;; Allow setting single tags without the menu
(setq org-fast-tag-selection-single-key (quote expert))
;; Disable the default org-mode stuck projects agenda view
(setq org-stuck-projects (quote ("" nil nil "")))

(setq org-archive-mark-done nil)

(setq org-archive-location "~/org/agenda/archive/%s_archive::/datetree/* Archived Tasks")

(setq org-list-allow-alphabetical t)

(setq org-ditaa-jar-path "~/.emacs.d/ditaa0_9/ditaa0_9.jar")

(add-hook 'org-babel-after-execute-hook 'bh/display-inline-images 'append)

(setq org-babel-results-keyword "results")

(defun bh/display-inline-images ()
  (condition-case nil
      (org-display-inline-images)
    (error nil)))

(defadvice org-babel-execute-src-block (around load-language nil activate)
  "Load language if needed"
  (let ((language (org-element-property :language (org-element-at-point))))
    (unless (cdr (assoc (intern language) org-babel-load-languages))
      (add-to-list 'org-babel-load-languages (cons (intern language) t))
      (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
    ad-do-it))

(org-babel-do-load-languages
 (quote org-babel-load-languages)
 (quote ((emacs-lisp . t)
         (dot . t)
         (ditaa . t)
         (python . t)
         (gnuplot . t)
         (shell . t)
         (ledger . t)
         (org . t)
         (plantuml . t)
         (latex . t))))

(setq org-confirm-babel-evaluate nil)

(add-to-list 'org-src-lang-modes (quote ("plantuml" . fundamental)))

(setq org-startup-with-inline-images t)
(setq org-startup-folded t)
(setq org-agenda-sticky t)

(setq org-fast-tag-selection-include-todo t)

(defun my/org-goto-current-datetree-entry ()
  "Open current day in log.org datetree in indirect buffer.  With prefix, open in real buffer."
  (interactive)
  (let* ((filename org-file-journal)
         (buffer (or (org-find-base-buffer-visiting filename)
                     (find-file-noselect filename)
                     (error "Unable to find buffer for file: %s" filename))))
    (switch-to-buffer buffer)
    (org-set-startup-visibility)
    (org-datetree-find-date-create (list (string-to-number (format-time-string "%m"))
                                         (string-to-number (format-time-string "%d"))
                                         (string-to-number (format-time-string "%Y"))))
    (org-cycle)
    (unless current-prefix-arg
      (org-narrow-to-subtree))))



(provide 'org-agenda)
 #+END_SRC
*** org-directory
#+BEGIN_SRC emacs-lisp
(setq org-directory "~/org/agenda/")
(setq org-file-inbox (concat org-directory "inbox.org"))
(setq org-file-brain (concat org-directory "notes/inbox.org"))
(setq org-file-journal (concat org-directory "/archive/journal/journal.org"))
(setq org-file-reference (concat org-directory "reference.org"))
(setq org-file-calendar (concat org-directory "calendar.org"))
#+END_SRC
*** org-capture templates
#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      (quote (("t" "Task" entry (file+headline org-file-inbox "Inbox") "* TODO %? \n:PROPERTIES:\n:CREATED: %T\n:END:" :clock-in t :clock-resume t)
              ("n" "Note" entry (file+headline org-file-inbox "Inbox") (file "~/.emacs.d/templates/zettel.tmplt")  :clock-in t :clock-resume t)
              ("e" "Event" entry (file+headline org-file-calendar "Calendar")
"* %^{Event}
%^{When?}t
   :PROPERTIES:
   :CREATED: %T
   :LOCATION: %^{Where?}
   :END:
 %? " :clock-in t :clock-resume t)



              )))


;; Disable when refiled from org-capture
(define-advice org-capture-refile (:around (oldfunc &rest args) org-disable-log-refile)
"Set `org-log-refile' to nil while capturing."
(let ((org-log-refile nil))
(apply oldfunc args)))

(add-hook 'org-capture-prepare-finalize-hook 'org-id-store-link)

#+END_SRC
*** org-agenda-custom-commands and vars
#+BEGIN_SRC emacs-lisp
(setq my/org-agenda-today-view
'("T" "Today" ((tags "+today"
                      ((org-agenda-overriding-header "Today")
                       (org-tags-match-list-sublevels nil))))))

(add-to-list 'org-agenda-custom-commands `,my/org-agenda-today-view)


(setq org-agenda-timegrid-use-ampm t)
(setq org-agenda-inhibit-startup t)
(setq org-agenda-use-tag-inheritance nil)

(setq org-agenda-span 'day)

(setq org-agenda-files (apply 'append
			      (mapcar
			       (lambda (directory)
				 (directory-files-recursively
				  directory org-agenda-file-regexp))
			       '("~/org/agenda" "~/org/projects" "~/org/meta/"))))

(setq org-agenda-follow-indirect t)

(setq org-agenda-dim-blocked-tasks nil)

(setq org-agenda-compact-blocks t)

(setq org-agenda-window-setup 'current-window)

(defvar org-timeline-files nil
  "The files to be included in `org-timeline-all-files'. Follows
  the same rules as `org-agenda-files'")

(setq org-timeline-files '("~/org/agenda/archive"))


(setq
 org-agenda-custom-commands
 (quote
  (("S" "Scheduled"
    ((agenda ""
             ((org-agenda-start-day "+0")
              (org-agenda-span 14)
              (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo '("DONE" "CANCELLED" "HOLD")))
              ))))

   ("n" "Next Tasks" tags-todo "-CANCELLED/!NEXT"
    ((org-agenda-overriding-header
      (concat "Next Tasks"
              (if bh/hide-scheduled-and-waiting-next-tasks
                  ""
                " (including WAITING and SCHEDULED tasks)")))
     (org-tags-match-list-sublevels t)
     (org-agenda-todo-ignore-scheduled
      bh/hide-scheduled-and-waiting-next-tasks)
     (org-agenda-todo-ignore-deadlines
      bh/hide-scheduled-and-waiting-next-tasks)
     (org-agenda-sorting-strategy
      '(priority-down todo-state-down effort-up category-keep))))

   ("p" "Projects" ((tags-todo "-HOLD-CANCELLED/!"
                               ((org-agenda-overriding-header "Projects")
                                (org-agenda-skip-function 'bh/skip-non-projects)
                                (org-tags-match-list-sublevels 'indented)
                                (org-agenda-sorting-strategy
                                 '(priority-down category-keep))))

                    (tags-todo "-CANCELLED/!NEXT"
                               ((org-agenda-overriding-header
                                 (concat "Project Next Tasks"
                                         (if bh/hide-scheduled-and-waiting-next-tasks
                                             ""
                                           " (including WAITING and SCHEDULED tasks)")))
                                (org-agenda-skip-function
                                 'bh/skip-projects-and-habits-and-single-tasks)
                                (org-tags-match-list-sublevels t)
                                (org-agenda-todo-ignore-scheduled
                                 bh/hide-scheduled-and-waiting-next-tasks)
                                (org-agenda-todo-ignore-deadlines
                                 bh/hide-scheduled-and-waiting-next-tasks)
                                        ;                 (org-agenda-todo-ignore-with-date
                                        ;                  bh/hide-scheduled-and-waiting-next-tasks)
                                (org-agenda-sorting-strategy
                                 '(todo-state-down effort-up category-keep))))

                    (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                               ((org-agenda-overriding-header
                                 (concat "Project Subtasks"
                                         (if bh/hide-scheduled-and-waiting-next-tasks
                                             ""
                                           " (including WAITING and SCHEDULED tasks)")))
                                (org-agenda-skip-function 'bh/skip-non-project-tasks)
                                (org-agenda-todo-ignore-scheduled
                                 bh/hide-scheduled-and-waiting-next-tasks)
                                (org-agenda-todo-ignore-deadlines
                                 bh/hide-scheduled-and-waiting-next-tasks)
                                (org-agenda-sorting-strategy
                                 '(priority-down category-keep))))


                    (tags-todo "-CANCELLED/!" ((org-agenda-overriding-header "Stuck Projects")
                                               (org-agenda-skip-function 'bh/skip-non-stuck-projects)
                                               (org-agenda-sorting-strategy
                                                '(priority-down))))


                    nil))

   ("t" "Tasks" ((tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!-NEXT"
                            ((org-agenda-overriding-header
                              (concat "Actions"
                                      (if bh/hide-scheduled-and-waiting-next-tasks
                                          ""
                                        " (including WAITING and SCHEDULED tasks)")))
                             (org-agenda-skip-function 'bh/skip-project-tasks)
                             (org-agenda-todo-ignore-scheduled
                              bh/hide-scheduled-and-waiting-next-tasks)
                             (org-agenda-todo-ignore-deadlines
                              bh/hide-scheduled-and-waiting-next-tasks)
                             (org-agenda-sorting-strategy
                              '(priority-down category-keep))))))

   ("s" "Someday/Maybe" ((tags-todo "-CANCELLED-WAITING/+HOLD"
                                    ((org-agenda-overriding-header
                                      (concat "Someday/Maybe"
                                              (if bh/hide-scheduled-and-waiting-next-tasks
                                                  ""
                                                " (including WAITING and SCHEDULED tasks)")))
                                     (org-agenda-skip-function 'bh/skip-non-tasks)
                                     (org-tags-match-list-sublevels nil)
                                     (org-agenda-todo-ignore-scheduled
                                      bh/hide-scheduled-and-waiting-next-tasks)
                                     (org-agenda-todo-ignore-deadlines
                                      bh/hide-scheduled-and-waiting-next-tasks)
                                     (org-agenda-sorting-strategy '(priority-down todo-state-down category-keep))))))

   ("w" "Waiting" ((tags "-REFILE/+WAITING"
                         ((org-agenda-overriding-header "Waiting for")
                          (org-tags-match-list-sublevels nil)))))

   ("d" "Delegated" ((tags "-REFILE/+DELEGATE"
                           ((org-agenda-overriding-header "Delegated")
                            (org-tags-match-list-sublevels nil)))))


   ("c" "Completed" ((tags "-REFILE/+DONE"
                           ((org-agenda-overriding-header "Done")
                            (org-tags-match-list-sublevels nil)))))

   )))


(defun bh/is-project-p ()
  "Any task with a todo keyword subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task has-subtask))))

(defun bh/is-project-subtree-p ()
  "Any task with a todo keyword that is in a project subtree.
Callers of this function already widen the buffer view."
  (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                              (point))))
    (save-excursion
      (bh/find-project-task)
      (if (equal (point) task)
          nil
        t))))

(defun bh/is-task-p ()
  "Any task with a todo keyword and no subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task (not has-subtask)))))


(defvar bh/hide-scheduled-and-waiting-next-tasks t)

(defun bh/skip-non-stuck-projects ()
  "Skip trees that are not stuck projects"
  ;; (bh/list-sublevels-for-projects-indented)
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (bh/is-project-p)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (has-next ))
            (save-excursion
              (forward-line 1)
              (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                (unless (member "WAITING" (org-get-tags))
                  (setq has-next t))))
            (if has-next
                next-headline
              nil)) ; a stuck project, has subtasks but no next task
        next-headline))))

(defun bh/skip-non-projects ()
  "Skip trees that are not projects"
  ;; (bh/list-sublevels-for-projects-indented)
  (if (save-excursion (bh/skip-non-stuck-projects))
      (save-restriction
        (widen)
        (let ((subtree-end (save-excursion (org-end-of-subtree t))))
          (cond
           ((bh/is-project-p)
            nil)
           ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
            nil)
           (t
            subtree-end))))
    (save-excursion (org-end-of-subtree t))))

(defun bh/skip-projects-and-habits-and-single-tasks ()
  "Skip trees that are projects, tasks that are habits, single non-project tasks"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((org-is-habit-p)
        next-headline)
       ((and bh/hide-scheduled-and-waiting-next-tasks
             (member "WAITING" (org-get-tags)))
        next-headline)
       ((bh/is-project-p)
        next-headline)
       ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
        next-headline)
       (t
        nil)))))

(defun bh/skip-project-tasks ()
  "Show non-project tasks.
		Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       ((bh/is-project-subtree-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-non-project-tasks ()
  "Show project tasks.
		Skip project and sub-project tasks, habits, and loose non-project tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
           (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((bh/is-project-p)
        next-headline)
       ((org-is-habit-p)
        subtree-end)
       ((and (bh/is-project-subtree-p)
             (member (org-get-todo-state) (list "NEXT")))
        subtree-end)
       ((not (bh/is-project-subtree-p))
        subtree-end)
       (t
        nil)))))


(defun bh/clock-in-to-next (kw)
  "Switch a task from TODO to NEXT when clocking in.
		Skips capture tasks, projects, and subprojects.
		Switch projects and subprojects from NEXT back to TODO"
  (when (not (and (boundp 'org-capture-mode) org-capture-mode))
    (cond
     ((and (member (org-get-todo-state) (list "TODO"))
           (bh/is-task-p))
      "NEXT")
     ((and (member (org-get-todo-state) (list "NEXT"))
           (bh/is-project-p))
      "TODO"))))

(defun bh/find-project-task ()
  "Move point to the parent (project) task if any"
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
      (while (org-up-heading-safe)
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq parent-task (point))))
      (goto-char parent-task)
      parent-task)))

(defun bh/verify-refile-target ()
  "Exclude todo keywords with a done state from refile targets"
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))


#+END_SRC
*** org-export-backends
#+BEGIN_SRC emacs-lisp
(setq org-export-backends '(ascii html icalendar latex org odt))
#+END_SRC
*** org-agenda functions
#+BEGIN_SRC emacs-lisp
(defun my/org-agenda-switch-to()
  "Jumps to a specific task."
  (interactive)
  (call-interactively 'org-agenda-switch-to)
  (org-cycle)
  (org-narrow-to-subtree)
  (outline-show-branches))

(defun my/org-agenda-goto-narrow ()
  "Jumps to a specific task."
  (interactive)
  (call-interactively 'org-agenda-goto)
  (org-narrow-to-subtree)
  (outline-show-branches)
  )

;; Record time and note when the scheduled date of a task is modified
(setq org-log-reschedule 'note)

;; Record time and note when the deadline of a task is modified
(setq org-log-redeadline 'note)

;; Record time and note when clocking out of a task
(setq org-log-clock-out 'note)

;; Record time and note when a task is refiled
(defvar org-blocks-hidden nil)

#+END_SRC

*** org-habit
#+BEGIN_SRC emacs-lisp
(require 'org-habit)

(add-to-list 'org-modules 'org-habit)

(setq org-modules '(org-habit
                    org-timer
                    org-collector))

(setq org-habit-show-habits-only-for-today t)
(setq org-agenda-tags-column -100
      org-habit-graph-column 45
      org-habit-preceding-days 28
      org-agenda-start-with-log-mode nil)

(setq org-habit-show-habits nil)

(setq org-hide-leading-stars t)

(setq org-hide-emphasis-markers t)
#+END_SRC
*** org-attach
#+BEGIN_SRC emacs-lisp
(setq org-attach-auto-tag nil)
(setq org-attach-method 'mv)

(defun org-insert-file (fiename)
"Insert Elisp code block recreating file named FILENAME."
(interactive "f")
(let ((base64-string
(with-temp-buffer
(insert-file-contents-literally filename)
(base64-encode-region (point-min) (point-max))
(buffer-string))))
(insert (format "#+BEGIN_SRC emacs-lisp :results output silent\n  (with-temp-file %S\n    (insert (base64-decode-string\n      %S)))\n#+END_SRC" filename base64-string))))

(defun my/org-attach-download (url)
  "Download file at URL and attach with `org-attach'.
Interactively, look for URL at point, in X clipboard, and in
kill-ring, prompting if not found.  With prefix, prompt for URL."
  (interactive (list (if current-prefix-arg
                         (read-string "URL: ")
		       (or (org-element-property :raw-link (org-element-context))
                           (org-web-tools--get-first-url)
                           (read-string "URL: ")))))
  (when (yes-or-no-p (concat "Attach file at URL: " url))
    (let* ((temp-dir (make-temp-file "org-attach-download-" 'dir))
           (basename (file-name-nondirectory (directory-file-name url)))
           (local-path (expand-file-name basename temp-dir))
           size)
      (unwind-protect
          (progn
            (url-copy-file url local-path 'ok-if-exists 'keep-time)
            (setq size (file-size-human-readable
                        (file-attribute-size
                         (file-attributes local-path))))
            (org-attach-attach local-path nil 'mv)
            (message "Attached %s (%s)" url size))
        (delete-directory temp-dir)))))


#+END_SRC
*** org-babel
#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil
      org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-src-preserve-indentation t
      org-src-window-setup 'current-window)
#+END_SRC
*** org-export
#+BEGIN_SRC emacs-lisp
(setq org-agenda-exporter-settings
      '((ps-number-of-columns 2)
        (ps-landscape-mode t)
        (org-agenda-add-entry-text-maxlines 5)
        (htmlize-output-type 'css)))


#+END_SRC
* Helpers
** helper variables
#+BEGIN_SRC emacs-lisp
(setq desktop-environment-screenshot-partial-command "scrot -s screenshot.png")
(setq desktop-environment-screenshot-directory "~/Pictures")


(setq imenu-max-items 100)
(setq org-imenu-depth 9)

(defalias 'insert-string 'insert)

(setq lpr-command "gtklp")

(setq org-expiry-created-property-name "CREATED")

(setq org-return-follows-link t)

(setq org-attach-directory "~/org/notes/data/")

(setq org-show-context-detail
      '((agenda . lineage) ;; instead of "local"
        (bookmark-jump . lineage)
        (isearch . lineage)
        (default . ancestors))
      )

(setq org-catch-invisible-edits "smart")

(defvar my-cpp-other-file-alist
  '(("\\.org\\'" (".org_archive"))
    ))
(setq-default ff-other-file-alist 'my-cpp-other-file-alist)

(setq org-agenda-inhibit-startup t) ;; ~50x speedup

(setq org-agenda-use-tag-inheritance nil) ;; 3-4x speedup

(setq load-dirs (concat user-emacs-directory "extra/"))

(setq grep-command "rg")

#+END_SRC
** appointments and notifications
 #+BEGIN_SRC emacs-lisp
(setq appt-display-diary nil)
(appt-activate t)
(setq appt-display-interval 5)
(setq appt-message-warning-time 15)
(setq appt-display-mode-line t)
(display-time)
(setq appt-display-format 'window)
(setq appt-disp-window-function #'ora-appt-display)
(run-at-time "1 hour" 3600 #'ora-org-agenda-to-appt)
(remove-hook 'org-finalize-agenda-hook #'ora-org-agenda-to-appt)
(add-hook 'org-finalize-agenda-hook #'ora-org-agenda-to-appt)

(defun ora-appt-display (min-to-app new-time msg)
  "our little façade-function for ora-org-popup"
  (ora-org-popup (format "Appointment in %s minute(s)" min-to-app) msg
                 "~/Pictures/Icons/Gnome-appointment-soon.png") )

(defun ora-org-agenda-to-appt ()
  "Erase all reminders and rebuild reminders for today from the agenda"
  (interactive)
  ;; (setq appt-time-msg-list nil)
  (org-agenda-to-appt))


(defun ora-start-process (cmd)
  (start-process
   cmd nil shell-file-name
   shell-command-switch
   (format "nohup 1>/dev/null 2>/dev/null %s" cmd)))

(defun ora-org-popup (title msg &optional icon sound)
  "Show a popup if we're on X, or echo it otherwise; TITLE is the title
           of the message, MSG is the context. Optionally, you can provide an ICON and
           a sound to be played"
  (interactive)
  (if (eq window-system 'x)
      (progn
        (notifications-notify
         :title title
         :body msg
         :app-icon icon
         :urgency 'low)
        (ora-start-process
         (concat "mplayer -really-quiet " sound " 2> /dev/null")))
    ;; text only version
    (message (concat title ": " msg))))

(defun bh/org-agenda-to-appt ()
  (interactive)
  (setq appt-time-msg-list nil)
  (org-agenda-to-appt))

;; Rebuild the reminders everytime the agenda is displayed
(add-hook 'org-finalize-agenda-hook 'bh/org-agenda-to-appt 'append)

;; Activate appointments so we get notifications,
;; but only run this when emacs is idle for 15 seconds
(run-with-idle-timer 15 nil (lambda () (appt-activate t)))

;; If we leave Emacs running overnight - reset the appointments one minute after midnight
(run-at-time "24:01" nil 'bh/org-agenda-to-appt)

 #+END_SRC
** window-snapshots
#+BEGIN_SRC emacs-lisp
 (defvar window-snapshots '())

 (defun save-window-snapshot ()
   "Save the current window configuration into `window-snapshots` alist."
   (interactive)
   (let ((key (read-string "Enter a name for the snapshot: ")))
     (setf (alist-get key window-snapshots) (current-window-configuration))
     (message "%s window snapshot saved!" key)))

 (defun get-window-snapshot (key)
   "Given a KEY return the saved value in `window-snapshots` alist."
   (let ((value (assoc key window-snapshots)))
     (cdr value)))

 (defun restore-window-snapshot ()
   "Restore a window snapshot from the window-snapshots alist."
   (interactive)
   (let* ((snapshot-name (completing-read "Choose snapshot: " (mapcar 'car window-snapshots)))
          (snapshot (get-window-snapshot snapshot-name)))
     (if snapshot
         (set-window-configuration snapshot)
       (message "Snapshot %s not found" snapshot-name))))


#+END_SRC
** buffer
#+BEGIN_SRC emacs-lisp
 (defun save-buffer-always ()
   "Save the buffer even if it is not modified."
   (interactive)
   (set-buffer-modified-p t)
   (save-buffer))


 (defun switch-to-scratch-buffer ()
   "Switch to the `*scratch*' buffer. Create it first if needed."
   (interactive)
   (let ((exists (get-buffer "*scratch*")))
     (switch-to-buffer (get-buffer-create "*scratch*"))
     (when (and (not exists)
                (not (eq major-mode 'fundamental-mode))
                (fboundp 'fundamental-mode))
       (funcall 'fundamental-mode))))

 (defun safe-erase-buffer ()
   "Prompt before erasing the content of the file."
   (interactive)
   (if (y-or-n-p (format "Erase content of buffer %s ? " (current-buffer)))
       (erase-buffer)))

 (defun copy-whole-buffer-to-clipboard ()
   "Copy entire buffer to clipboard"
   (interactive)
   (clipboard-kill-ring-save (point-min) (point-max)))

(defun kill-all-buffers()
  "Kill all buffers except current one and toolkit (*Messages*, *scratch*). Close other windows."
  (interactive)
  (mapc 'kill-buffer (remove-if
                       (lambda (x)
                         (or
                           (string-equal (buffer-name) (buffer-name x))
                           (string-equal "*Messages*" (buffer-name x))
                           (string-equal "*dashboard*" (buffer-name x))
                           (string-equal "*scratch*" (buffer-name x))))
                       (buffer-list)))
  (delete-other-windows))

#+END_SRC
** window
#+BEGIN_SRC emacs-lisp
(defun delete-window-balance ()
  "Delete window and rebalance the remaining ones."
  (interactive)
  (delete-window)
  (balance-windows))
(defun split-window-below-focus ()
  "Split window horizontally and move focus to other window."
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))

(defun split-window-right-focus ()
  "Split window vertically and move focus to other window."
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))



(defun my/toggle-maximize ()
  "Toggle maximization of current window."
  (interactive)
  (let ((register ?2))

    (if (eq (get-register register) nil)
      (progn
        (set-register register (current-window-configuration))
        (delete-other-windows))
      (progn
        (set-window-configuration (get-register register))
        (set-register register nil)))))

#+END_SRC
** editing
#+BEGIN_SRC emacs-lisp
 (defun copy-line ()
  (interactive)
  (save-excursion
    (back-to-indentation)
    (kill-ring-save
     (point)
     (line-end-position)))
     (message "1 line copied"))


(defun goto-line-show ()
  "Show line numbers temporarily, while prompting for the line number input."
  (interactive)
  (unwind-protect
      (progn
        (linum-mode 1)
        (call-interactively #'goto-line))
    (linum-mode -1)))

#+END_SRC
** flycheck
#+BEGIN_SRC emacs-lisp
(defun toggle-flycheck-error-list ()
    "Toggle flycheck's error list window.
If the error list is visible, hide it.  Otherwise, show it."
    (interactive)
    (-if-let (window (flycheck-get-error-list-window))
        (quit-window nil window)
      (flycheck-list-errors)))

  (defun goto-flycheck-error-list ()
    "Open and go to the error list buffer."
    (interactive)
    (unless (get-buffer-window (get-buffer flycheck-error-list-buffer))
      (flycheck-list-errors)
      (switch-to-buffer-other-window flycheck-error-list-buffer)))

(defun disable-fylcheck-in-org-src-block ()
  (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
#+END_SRC
** test-emacs
#+BEGIN_SRC emacs-lisp
(defun test-emacs ()
  "Test if emacs starts correctly."
  (interactive)
  (if (eq last-command this-command)
      (save-buffers-kill-terminal)
    (require 'async)
    (async-start
     (lambda () (shell-command-to-string
                 "emacs --batch --eval \"
(condition-case e
    (progn
      (load \\\"~/.emacs.d/init.el\\\")
      (message \\\"-OK-\\\"))
  (error
   (message \\\"ERROR!\\\")
   (signal (car e) (cdr e))))\""))
     `(lambda (output)
        (if (string-match "-OK-" output)
            (when ,(called-interactively-p 'any)
              (message "All is well"))
          (switch-to-buffer-other-window "*startup error*")
          (delete-region (point-min) (point-max))
          (insert output)
          (search-backward "ERROR!"))))))

#+END_SRC

** time
#+BEGIN_SRC emacs-lisp
(defun my/insert-created-timestamp()
   "Insert a CREATED property using org-expiry.el for TODO entries"
   (org-entry-put nil "CREATED" (format-time-string "<%Y-%m-%d %a %H:%M>"))
   (org-expiry-insert-created)
   (org-back-to-heading)
   (org-end-of-line)
   (insert " "))

#+END_SRC
** archive
#+BEGIN_SRC emacs-lisp
(defun org-archive-done-tasks ()
   (interactive)
   (org-map-entries 'org-archive-subtree "/DONE" 'file))

#+END_SRC
** org-insert-link
#+BEGIN_SRC emacs-lisp
(defun org-insert-link-with-default-description (file-name)
  (interactive (list (read-file-name "File: ")))
  (org-insert-link file-name file-name (file-name-nondirectory file-name)))

#+END_SRC
** expansion
#+BEGIN_SRC emacs-lisp
(defun check-expansion ()
  (save-excursion
    (if (looking-at "\\_>") t
      (backward-char 1)
      (if (looking-at "\\.") t
        (backward-char 1)
        (if (looking-at "->") t nil)))))

(defun do-yas-expand ()
  (let ((yas/fallback-behavior 'return-nil))
    (yas/expand)))
#+END_SRC
** export-headlines
#+BEGIN_SRC emacs-lisp
(defun my/org-export-headlines-to-org ()
  "Export all subtrees that are *not* tagged with :noexport: to
separate files.

Subtrees that do not have the :EXPORT_FILE_NAME: property set
are exported to a filename derived from the headline text."
  (interactive)
;  (save-buffer)
  (let ((modifiedp (buffer-modified-p)))
    (save-excursion
      (goto-char (point-min))
      (goto-char (re-search-forward "^*"))
      (set-mark (line-beginning-position))
      (goto-char (point-max))
      (org-map-entries
       (lambda ()
         (let ((export-file (org-entry-get (point) "EXPORT_FILE_NAME")))
           (unless export-file
             (org-set-property
              "EXPORT_FILE_NAME"
              (replace-regexp-in-string " " "_" (nth 4 (org-heading-components)))))
           (deactivate-mark)
           (org-org-export-to-org nil t)
           (unless export-file (org-delete-property "EXPORT_FILE_NAME"))
           (set-buffer-modified-p modifiedp)))
       "-noexport" 'region-start-level))))

#+END_SRC
** org-id
#+BEGIN_SRC emacs-lisp
(defun my/org-add-ids-to-headlines-in-file ()
  "Add CUSTOM_ID properties to all headlines in the
   current file which do not already have one."
  (interactive)
  (org-map-entries (lambda () (my/org-custom-id-get (point) 'create))))

(defun my/org-custom-id-get (&optional pom create prefix)
  "Get the CUSTOM_ID property of the entry at point-or-marker POM.
   If POM is nil, refer to the entry at point. If the entry does
   not have an CUSTOM_ID, the function returns nil. However, when
   CREATE is non nil, create a CUSTOM_ID if none is present
   already. PREFIX will be passed through to `org-id-new'. In any
   case, the CUSTOM_ID of the entry is returned."
  (interactive)
  (org-with-point-at pom
    (let ((id (org-entry-get nil "EXPORT_FILE_NAME")))
      (cond
       ((and id (stringp id) (string-match "\\S-" id))
        id)
       (create
        (setq id (org-id-new (concat prefix "h")))
        (org-entry-put pom "EXPORT_FILENAME" id)
        (org-id-add-location id (buffer-file-name (buffer-base-buffer)))
        id)))))
#+END_SRC
** nov
#+BEGIN_SRC emacs-lisp
(defun my-nov-font-setup ()
  (face-remap-add-relative 'variable-pitch :family "Liberation Serif"
                           :height 1.0))
#+END_SRC
** org-mode-hooks
#+BEGIN_SRC emacs-lisp
(defun my-org-mode-hooks ()
  (visual-line-mode)
  (turn-on-auto-fill)
  (turn-on-flyspell)
  (outline-minor-mode))
#+END_SRC
** misc
#+BEGIN_SRC emacs-lisp
(defun my/trim-non-chrome ()
    (delete-if-not (apply-partially 'string-match "- Google Chrome$")
                   ido-temp-list))

  (add-hook 'exwm-manage-finish-hook
            (defun my/exwm-manage-hook ()
              (when (string-match "Google-chrome" exwm-class-name)
                (exwm-workspace-move-window 3)
;                (exwm-layout-hide-mode-line)
                (setq ido-make-buffer-list-hook 'my/trim-non-chrome))))

  (add-hook 'exwm-update-title-hook
            (defun my/exwm-title-hook ()
              (when (string-match "Google-chrome" exwm-class-name)
                (exwm-workspace-rename-buffer exwm-title))))

  (setq browse-url-chrome-arguments '("--new-window"))


          (defun tab-indent-or-complete ()
            (interactive)
            (if (minibufferp)
                (minibuffer-complete)
              (if (or (not yas/minor-mode)
                      (null (do-yas-expand)))
                  (if (check-expansion)
                      (company-complete-common)
                    (indent-for-tab-command)))))


          (defun isearch-yank-symbol ()
            (interactive)
            (isearch-yank-internal (lambda () (forward-symbol 1) (point))))

#+END_SRC
** save-hist
#+BEGIN_SRC emacs-lisp

(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring
        last-kbd-macro
        kmacro-ring
        shell-command-history
        Info-history-list
))

(savehist-mode 1)

#+END_SRC

** xref
#+BEGIN_SRC emacs-lisp
(custom-set-variables '(xref-show-xrefs-function #'ivy-xref-show-xrefs))

(defun my-xref-show-pos-in-buf--same-window (func &rest args)
  "Display xref location in the same window. See
`display-buffer-same-window'."
  (let ((display-buffer-overriding-action '(display-buffer-same-window)))
    (apply func args)))

(advice-add 'xref--show-pos-in-buf
            :around #'my-xref-show-pos-in-buf--same-window)

#+END_SRC
** unbound Keybindings
 #+BEGIN_SRC emacs-lisp
 (define-key winner-mode-map (kbd "C-c <left>") nil)
 (define-key winner-mode-map (kbd "C-c <right>") nil)
 (define-key global-map (kbd "C-c <tab>") nil)
 (define-key yas-minor-mode-map (kbd "C-c &") nil)
 (define-key global-map (kbd "C-c ,") nil)
 (define-key global-map (kbd "C-c C-j") nil)
 (define-key flyspell-mode-map (kbd "C-c $") nil)
 #+END_SRC

* Commands to bind
** rg-dwim-current-file
* Disabled
** DISABLED old-code
#+BEGIN_SRC emacs-lisp
;; (define-key org-agenda-mode-map (kbd "TAB") #'my/org-agenda-goto-narrow)
;; (define-key org-agenda-mode-map (kbd "RET") #'my/org-agenda-switch-to)
(define-key org-agenda-mode-map (kbd ";") #'org-agenda-workflow)
(define-key org-agenda-mode-map (kbd "i") #'org-agenda-clock-in)
(define-key org-agenda-mode-map (kbd "I") #'org-pomodoro)
(define-key org-agenda-mode-map (kbd "o") #'org-agenda-clock-out)
(define-key org-agenda-mode-map (kbd "k") #'org-capture)

(define-key org-brain-visualize-mode-map (kbd "SPC") #'link-hint-open-link)
(define-key org-brain-visualize-mode-map (kbd "TAB") 'my/org-brain-goto-current)

(define-key org-brain-visualize-mode-map (kbd "s") 'org-brain-save-and-update)

(define-key org-brain-visualize-mode-map "c" 'my/org-brain-add-child)
(define-key org-brain-visualize-mode-map "C" 'org-brain-add-child)


 (define-key global-map (kbd "C-1") 'bjm/org-capture-todo)
 (define-key global-map (kbd "C-2") 'bjm/org-capture-zettel)
 (define-key global-map (kbd "C-3") 'bjm/org-capture-event)
 (define-key global-map (kbd "C-4") 'howm-create)
 (define-key global-map (kbd "<f1>") 'my/org-brain-visualize-current)


(define-key global-map (kbd "C-2") 'bjm/org-capture-zettel)
(define-key global-map (kbd "C-4") 'bjm/org-capture-journal)

(define-prefix-command 'my-digit-map)
(global-set-key (kbd "C-2") 'my-digit-map)
(define-key 'my-digit-map (kbd "p") 'howm-parent-to)
(define-key 'my-digit-map (kbd "c") 'howm-child-to)
(define-key 'my-digit-map (kbd "f") 'howm-friendship-to)
(define-key 'my-digit-map (kbd "C") 'howm-create)
(define-key 'my-digit-map (kbd "2") 'bjm/org-capture-zettel)

#+END_SRC
** DISABLED notdeft
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/lisp/notdeft-0.6.20190210")
 (load "notdeft-example")

(load-file (expand-file-name
		      "~/.emacs.d/lisp/notdeft-0.6.20190210/notdeft.el"
		      user-emacs-directory))


(setq notdeft-directories '("~/org/notes"))
(setq notdeft-extension "org")

 (defun toggle-window-dedicated ()
        "Toggle whether the current active window is dedicated or not.
 Code founded by peterfoldi
 https://stackoverflow.com/questions/29332242/is-there-a-way-to-fix-window-buffer-in-emacs-for-cider-error-repl/33082302#33082302"
   (interactive)
   (message
    (if (let (window (get-buffer-window (current-buffer)))
      (set-window-dedicated-p window
                      (not (window-dedicated-p window))))
        "Window '%s' is dedicated"
      "Window '%s' is normal")
    (current-buffer)))

(defun notdeft-new-file-named (pfx title &optional data)
  "Create a new file, prompting for a title.
The prefix argument PFX is as for `notdeft-new-file'.
Query for a TITLE when invoked as a command.
Initialize the file with DATA, or TITLE if not given.
Return the filename of the created file."
  (interactive "P\nsNew title: ")
  (let ((notename (concat (format-time-string "%Y-%m-%dT%H.%M.%S") (notdeft-title-to-notename title))))
    (notdeft-sub-new-file (or data title) notename pfx)))


#+END_SRC
** DISABLED deft
#+BEGIN_SRC emacs-lisp
(use-package deft
:commands (deft)
:init
(setq deft-directory "~/org/notes/"
                deft-extensions '("org" "md" "txt")
                deft-default-extension "org"
                deft-use-filename-as-title t))

(defun notdeft-new-file (pfx)
  "Create a new file quickly.
Create it with an automatically generated name, one based
on the `notdeft-filter-string' filter string if it is non-nil.
With a prefix argument PFX, offer a choice of NotDeft
directories, when there is more than one of them.
With two prefix arguments, also offer a choice of filename
extensions when `notdeft-secondary-extensions' is non-empty.
Return the filename of the created file."
  (interactive "P")
  (let ((data (and notdeft-filter-string
		   (concat notdeft-filter-string "\n\n")))
	(notename
	 (and notdeft-filter-string
	      (notdeft-title-to-notename notdeft-filter-string))))
    (notdeft-sub-new-file data (concat (format-time-string "%Y-%m-%d-%H%M ") notename)) pfx))


#+END_SRC
** DISABLED eyebrowse
#+BEGIN_SRC emacs-lisp :tangle no
(setq eyebrowse-keymap-prefix (kbd "C-SPC e"))
(use-package eyebrowse
  :config
  (setq eyebrowse-new-workspace t)
  (eyebrowse-mode t))

#+END_SRC
** DISABLED multiple-cursors
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :commands multiple-cursors-mode
  :config
  (bind-keys :map mc/keymap
             ("C-c m" . nil))
  :bind (
;         ("s-i" . mc/mark-next-like-this)
;	 ("s-I" . mc/mark-previous-like-this)
	 ("C-c m e" . mc/mark-more-like-this-extended)
	 ("C-c m m" . mc/mark-all-like-this-dwim)
	 ("C-c m c" . mc/edit-lines)))
#+END_SRC
** DISABLED demo-it
#+BEGIN_SRC emacs-lisp
(use-package demo-it)
#+END_SRC
** DISABLED tangle
#+BEGIN_SRC emacs-lisp
(defun tangle-on-save-org-mode-file()
  (when (equal major-mode 'org-mode)
    (org-babel-tangle)))

(defun my/org-toggle-tangle-on-save ()
  "Toggle tangling code blocks on save"
  (interactive)
  (if (get 'my/org-toggle-tangle-on-save 'state)
      (progn
	(message "%s" "Org tangle on save Disabled")
	(remove-hook 'after-save-hook 'tangle-on-save-org-mode-file)
	(put 'my/org-toggle-tangle-on-save 'state nil))
    (progn
      (message "%s" "Org tangle on save Enabled")
      (add-hook 'after-save-hook 'tangle-on-save-org-mode-file)
      (put 'my/org-toggle-tangle-on-save 'state t))))

#+END_SRC
** DISABLED persp-mode
#+BEGIN_SRC emacs-lisp
(use-package persp-mode :demand t
  :config
  (setq wg-morph-on nil
        persp-autokill-buffer-on-remove 'kill-weak
        persp-nil-name "nil"
        persp-nil-hidden t
        persp-auto-save-fname "autosave"
        persp-auto-resume-time 1
        persp-auto-save-opt 1
        persp-save-dir (concat dotfiles-etc-dir "workspaces/"))

  (defun +workspaces*track-last-persp (switch-fun &rest args)
    (let ((before-persp (safe-persp-name (get-current-persp)))
          (after-persp (apply switch-fun args)))
      (when (not (string= before-persp after-persp))
        (setq +workspaces-last-persp before-persp))))
  (advice-add #'persp-switch :around #'+workspaces*track-last-persp)
  (add-hook 'my/post-init-hook #'(lambda () (persp-mode 1))))


(defvar +workspaces-last-persp nil
  "A variable that contains the last accessed perspective")

(defun +workspace-exists-p (name)
  "Returns t if NAME is the name of an existing workspace."
  (when (symbolp name)
    (setq name (symbol-name name)))
  (unless (stringp name)
    (error "Expected a string, got a %s" (type-of name)))
  (member name (persp-names-current-frame-fast-ordered)))

(defun +workspace-switch-last ()
  "Switches to the last workspace"
  (interactive)
  (if (+workspace-exists-p +workspaces-last-persp)
      (persp-switch +workspaces-last-persp)
    (error "No previous workspace.")))

(defun +workspace-switch-project ()
  (interactive)
  (ivy-read "Switch to Project Perspective: "
            (if (projectile-project-p)
                (cons (abbreviate-file-name (projectile-project-root))
                      (projectile-relevant-known-projects))
              projectile-known-projects)
            :action (lambda (project)
                      (persp-switch project)
                      (let ((projectile-completion-system 'ivy))
                        (projectile-switch-project-by-name project)))))


#+END_SRC
** DISABLED hideshow
#+BEGIN_SRC emacs-lisp
(use-package hideshow :demand t ; built-in
  :commands (hs-minor-mode hs-toggle-hiding hs-already-hidden-p hs-hide-level hs-show-all)
  :config
  (add-hook 'prog-mode-hook #'hs-minor-mode)
  (setq hs-hide-comments-when-hiding-all nil))
#+END_SRC
** DISABLED neotree
#+BEGIN_SRC emacs-lisp
(use-package neotree
  :ensure t
  :config
  (global-set-key "\M-n" 'neotree-toggle)
  (setq neo-theme 'icons))
#+END_SRC
** DISABLED desktop
 #+BEGIN_SRC emacs-lisp :tangle no
  (require 'desktop)

  (setq desktop-save 1
        desktop-load-locked-desktop t
        desktop-dirname user-emacs-directory
        desktop-restore-frames t
        desktop-restore-eager 4
        ;; Don't save remote files and/or *gpg files.
        desktop-files-not-to-save "\\(^/[^/:]*:\\|(ftp)$\\)\\|\\(\\.gpg$\\)")
  (desktop-save-mode 1)


 #+END_SRC
** DISABLED dashboard
#+BEGIN_SRC emacs-lisp
(defun dashboard-setup-startup-hook ()
  "Setup post initialization hooks.
If a command line argument is provided,
assume a filename and skip displaying Dashboard."
  (if (< (length command-line-args) 2 )
      (progn
        (add-hook 'after-init-hook (lambda ()
                                     ;; Display useful lists of items
                                     (dashboard-insert-startupify-lists))))))

(defun dashboard-insert-custom (list-size)
  (let ((all-the-icons-scale-factor 2.00)
        (all-the-icons-default-adjust -0.00))
    (mapc (lambda (btn)
            (when btn
              (cl-destructuring-bind (label icon fn) btn
                (insert
                 (with-temp-buffer
                   (insert-text-button
                    (concat (all-the-icons-faicon  icon :face 'font-lock-keyword-face)
                            (propertize (concat " " label) 'face 'font-lock-keyword-face))
                    'action `(lambda (_) ,fn)
                    'follow-link t)
                   (dashboard-center (- dashboard--width 2) (buffer-string)))
                 "\n\n"))))
          `(

            ("Collect Thoughts" "inbox"
             (call-interactively (or (command-remapping #'counsel-org-capture)
                                     #'counsel-org-capture)))

            ("Process Thoughts" "long-arrow-right"
             (call-interactively (or (command-remapping #'org-boxes-workflow)
                                     #'org-boxes-workflow)))

            ("Projects" "tasks"
             (call-interactively (or (command-remapping #'my/projects)
                                     #'my/projects)))
            ("Actions" "check-square"
             (call-interactively (or (command-remapping #'my/actions)
                                     #'my/actions)))
            ("Next Tasks" "clipboard"
             (call-interactively (or (command-remapping #'my/next-tasks)
                                     #'my/next-tasks)))
            ("Delegated" "user"
             (call-interactively (or (command-remapping #'my/delegated)
                                     #'my/delegated)))
            ("Waiting" "hourglass-end"
             (call-interactively (or (command-remapping #'my/waiting)
                                     #'my/waiting)))
            ("Someday/Maybe" "question-circle"
             (call-interactively (or (command-remapping #'my/someday)
                                     #'my/someday)))
            ("Scheduled" "calendar"
             (call-interactively (or (command-remapping #'my/scheduled)
                                     #'my/scheduled)))
            ("Done" "check"
             (call-interactively (or (command-remapping #'my/completed)
                                     #'my/completed)))
            ("Reference" "archive"
             (call-interactively (or (command-remapping #'howm-list-all)
                                     #'howm-list-all)))


            ))))

(defun go-to-dashboard ()
  (interactive)
  (switch-to-buffer "*dashboard*"))

  (global-set-key (kbd "<f12>") 'go-to-dashboard)

;  (define-key dashboard-mode-map "/" #'hui-search-web)


(defun my/scheduled ()
  (interactive)
  (org-agenda nil "S")
  (setq org-agenda-follow-mode 1))

(defun my/next-tasks ()
  (interactive)
  (org-agenda nil "n")
  (setq org-agenda-follow-mode 1))

(defun my/projects ()
  (interactive)
  (org-agenda nil "p")
  (setq org-agenda-follow-mode 1))

(defun my/actions ()
  (interactive)
  (org-agenda nil "t")
  (setq org-agenda-follow-mode 1))

(defun my/someday ()
  (interactive)
  (org-agenda nil "s")
  (setq org-agenda-follow-mode 1))


(defun my/waiting ()
  (interactive)
  (org-agenda nil "w")
  (setq org-agenda-follow-mode 1))


(defun my/delegated ()
  (interactive)
  (org-agenda nil "d")
  (setq org-agenda-follow-mode 1))


(defun my/completed ()
  (interactive)
  (org-agenda nil "c")
  (setq org-agenda-follow-mode 1))


#+END_SRC
** DISABLED elisp-demos
#+BEGIN_SRC emacs-lisp
(use-package elisp-demos
:config
(advice-add 'describe-function-1 :after #'elisp-demos-advice-describe-function-1)
(advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update)
)
#+END_SRC
** DISABLED org-noter
#+BEGIN_SRC emacs-lisp
(setq org-noter-notes-search-path '("~/org/notes"))
(setq org-noter-always-create-frame nil)
(setq org-noter-notes-window-location nil)
(setq org-noter-default-notes-file-names '("Notes.org"))
#+END_SRC

** DISABLED org-brain
#+BEGIN_SRC emacs-lisp
(use-package org-brain
  :ensure t
  :config
  (setq org-brain-path "~/org/notes"
        org-id-track-globally t
        org-id-locations-file "~/.emacs.d/.org-id-locations"
        org-brain-visualize-default-choices 'root
        org-brain-wander-interval 6
        org-brain-data-file "/home/alexander/org/notes/.org-brain-data.el")

  (defun my/brain ()
    (interactive)
    (org-brain-visualize "zettelkasten")
    (delete-other-windows))

  (defun my/org-add-ids-to-headlines-in-file ()
    "Add ID properties to all headlines in the current file which
     do not already have one."
    (interactive)
    (org-map-entries 'org-id-get-create))

  (defun org-brain-entry-at-pt ()
    "Get current org-brain entry.
    In `org-mode' this is the current headline, or the file.
    In `org-brain-visualize' just return `org-brain--vis-entry'."
    (cond ((eq major-mode 'org-mode)
           (if (ignore-errors (org-get-heading))
               (if-let ((id (org-entry-get nil "ID")))
                   (org-brain-entry-from-id id)
                 (error "Current headline have no ID"))
             (org-brain-path-entry-name (buffer-file-name))))
          ((eq major-mode 'org-brain-visualize-mode)
           org-brain--vis-entry)
          (t
           (error "Not in org-mode or org-brain-visualize"))))

  (defun my/refile-to-zettelkasten (entry)
    "Convert headline ENTRY to a file entry.
    Prompt for name of the new file.
    If interactive, also prompt for ENTRY."
    (interactive (list (org-brain-entry-at-pt)))
    (let* (level
           (title (org-brain-title entry))
           (new-entry (concat (format-time-string "%Y-%m-%dT%H.%M.%S")))
           (path (org-brain-entry-path new-entry)))
      (when (file-exists-p path)
        (error "That file already exists"))
      (let ((parents (org-brain-parents entry))
            (external-parents (org-brain--linked-property-entries entry "PARENTS"))
            (children (org-brain--linked-property-entries entry "CHILDREN"))
            (friends (org-brain-friends entry))
            (hl-text (org-with-point-at (org-brain-entry-marker entry)
                       (setq level (org-outline-level))
                       (org-get-entry))))
        (dolist (parent external-parents)
          (org-brain-remove-relationship parent entry))
        (dolist (child children)
          (org-brain-remove-relationship entry child))
        (dolist (friend friends)
          (org-brain-remove-friendship entry friend))
        (org-with-point-at (org-brain-entry-marker entry)
          (org-cut-subtree)
          (pop kill-ring)
          (save-buffer))
        (make-directory (file-name-directory path) t)
        (with-temp-file path
          (insert ":HIDDEN:\n")
          (insert "#+PARENTS: \n")
          (insert "#+CHILDREN: \n")
          (insert "#+FRIENDS: \n")
          (insert ":END: \n")
          (insert (format "#+TITLE: %s\n" title))
          (insert (concat "#+DATE: " (format-time-string "[%Y-%m-%d %H:%M]\n")))
          (delay-mode-hooks
            (org-mode)
            (goto-char (point-min))
            (forward-line 8)
            (insert (format "#+KEYWORDS: \n\n"))
            (forward-line 9)
            (insert (format "%s\n" hl-text))
            (insert "\n")
            (goto-char (point-min))
            (re-search-forward org-property-drawer-re)
            (replace-match "")
            (goto-char (point-max))
            (let ((level-regex "^"))
              (dotimes (_i (1+ level))
                (setq level-regex (concat level-regex "\\*")))
              (setq level-regex (concat level-regex " "))
              (while (re-search-backward level-regex nil t)
                (dotimes (_i level) (org-promote-subtree))))))
        (when (equal entry org-brain--vis-entry)
          (setq org-brain--vis-entry new-entry))
        (when (member entry org-brain-pins)
          (org-brain-pin entry -1)
          (org-brain-pin new-entry 1)))))

  (defun my/headline-to-file (entry)
    "Convert headline ENTRY to a file entry.
     Prompt for name of the new file.
     If interactive, also prompt for ENTRY."
    (interactive (list (org-brain-entry-at-pt)))
    (let* (level
           (title (org-brain-title entry))
           (new-entry (concat (format-time-string "%Y-%m-%dT%H.%M.%S")))
           (path (org-brain-entry-path new-entry)))
      (when (file-exists-p path)
        (error "That file already exists"))
      (let ((parents (org-brain-parents entry))
            (external-parents (org-brain--linked-property-entries entry "PARENTS"))
            (children (org-brain--linked-property-entries entry "CHILDREN"))
            (friends (org-brain-friends entry))
            (hl-text (org-with-point-at (org-brain-entry-marker entry)
                       (setq level (org-outline-level))
                       (org-get-entry))))
        (dolist (parent external-parents)
          (org-brain-remove-relationship parent entry))
        (dolist (child children)
          (org-brain-remove-relationship entry child))
        (dolist (friend friends)
          (org-brain-remove-friendship entry friend))
        (org-with-point-at (org-brain-entry-marker entry)
          (org-cut-subtree)
          (pop kill-ring)
          (save-buffer))
        (make-directory (file-name-directory path) t)
        (with-temp-file path
          (insert (format "#+TITLE: %s\n" title))
          (insert (concat "#+DATE: " (format-time-string "[%Y-%m-%d %H:%M]\n")))
          (delay-mode-hooks
            (org-mode)
            (goto-char (point-min))
            (forward-line 3)
            (insert (format "#+KEYWORDS: \n\n"))
            (forward-line 4)
            (insert (format "%s\n" hl-text))
            (insert "\n")
            (goto-char (point-min))
            (re-search-forward org-property-drawer-re)
            (replace-match "")
            (goto-char (point-max))
            (let ((level-regex "^"))
              (dotimes (_i (1+ level))
                (setq level-regex (concat level-regex "\\*")))
              (setq level-regex (concat level-regex " "))
              (while (re-search-backward level-regex nil t)
                (dotimes (_i level) (org-promote-subtree))))))
        (dolist (parent parents)
          (org-brain-add-relationship parent new-entry))
        (dolist (child children)
          (org-brain-add-relationship new-entry child))
        (dolist (friend friends)
          (org-brain--internal-add-friendship new-entry friend))
        (when (equal entry org-brain--vis-entry)
          (setq org-brain--vis-entry new-entry))
        (when (member entry org-brain-pins)
          (org-brain-pin entry -1)
          (org-brain-pin new-entry 1)))
      ))

  (defun my/org-add-ids-to-headlines-in-file ()
    "Add ID properties to all headlines in the current file which
     do not already have one."
    (interactive)
    (org-map-entries 'org-id-get-create))

(defun my/org-brain-visualize-current ()
(interactive)
(org-brain-visualize (org-brain-entry-at-pt))
(delete-other-windows))


  (setq org-brain-visualize-default-choices 'all)
  (setq org-brain-title-max-length 100)

  (defun my/org-brain-goto-current ()
    "Jumps to a specific task."
    (interactive)
    (call-interactively 'org-brain-goto-current)
    (org-narrow-to-subtree)
    (forward-line 5))


  (defun org-brain-save-and-update ()
    (interactive)
    (org-brain-update-id-locations)
    (org-save-all-org-buffers)
    (org-brain--revert-if-visualizing))

  (defun org-brain-cliplink-resource ()
    "Add a URL from the clipboard as an org-brain resource.
     Suggest the URL title as a description for resource."
    (interactive)
    (let ((url (org-cliplink-clipboard-content)))
      (org-brain-add-resource
       url
       (org-cliplink-retrieve-title-synchronously url)
       t)))

  (defun my/org-brain-add-child-headline ()
    "Create a new internal child headline to entry at point.
    Several children can be created, by using `org-brain-entry-separator'."
    (interactive)
    (let ((entry (org-brain-entry-at-pt))
          (child-name-string (read-string "Add child headline: ")))
      (dolist (child-name (split-string child-name-string org-brain-entry-separator))
        (when (equal (length child-name) 0)
          (error "Child name must be at least 1 character"))
        (if (org-brain-filep entry)
            ;; File entry
            (with-current-buffer (find-file-noselect (org-brain-entry-path entry))
              (goto-char (point-min))
              (if (re-search-forward (concat "^\\(" org-outline-regexp "\\)") nil t)
                  (progn
                    (beginning-of-line)
                    (open-line 1))
                (goto-char (point-max)))
              (insert (concat "* " child-name))
              (insert (concat "\n"))
              (org-id-get-create)
              (insert (concat "\n\n"))
              (insert (concat "Related Notes:\n\n"))
              (insert (concat "\n\n\n"))
              (insert (concat "Reference:\n\n"))
              (run-hooks 'org-brain-new-entry-hook)
              (save-buffer))
          ;; Headline entry
          (org-with-point-at (org-brain-entry-marker entry)
            (if (org-goto-first-child)
                (open-line 1)
              (org-end-of-subtree t))
            (org-insert-heading nil t)
            (org-do-demote)
            (insert child-name)
            (org-id-get-create)
            (run-hooks 'org-brain-new-entry-hook)
            (save-buffer)))))
    (org-brain--revert-if-visualizing))


  (setq org-brain-visualize-mode-hook #'delete-other-windows)


  (defun org-brain-open-org-noter (entry)
    "Open `org-noter' on the ENTRY.
     If run interactively, get ENTRY from context."
    (interactive (list (org-brain-entry-at-pt)))
    (org-with-point-at (org-brain-entry-marker entry)
      (org-noter)))

  (defun org-brain-set-tags (entry)
    "Modify the ENTRY tags.
    Use `org-set-tags' on headline ENTRY.
    Instead sets #+KEYWORDS on file ENTRY.
    If run interactively, get ENTRY from context."
    (interactive (list (org-brain-entry-at-pt)))
    (if (org-brain-filep entry)
        (with-current-buffer (find-file-noselect (org-brain-entry-path entry))
          (let ((tag-str (read-string "KEYWORDS: "
                                      (mapconcat #'identity org-file-tags ":"))))
            (goto-char (point-min))
            (when (assoc "KEYWORDS" (org-brain-keywords entry))
              (re-search-forward "^#\\+KEYWORDS:")
              (kill-whole-line))
            (insert (format "#+KEYWORDS: %s\n" tag-str)))
          ;; From org.el
          (let ((org-inhibit-startup-visibility-stuff t)
                (org-startup-align-all-tables nil))
            (when (boundp 'org-table-coordinate-overlays)
              (mapc #'delete-overlay org-table-coordinate-overlays)
              (setq org-table-coordinate-overlays nil))
            (org-save-outline-visibility 'use-markers (org-mode-restart)))
          (save-buffer))
      (org-with-point-at (org-brain-entry-marker entry)
        (org-set-tags)
        (save-buffer)))
    (org-brain--revert-if-visualizing))

  (defun my/org-brain-add-child ()
    "Add external child to entry at point.
    If chosen child entry doesn't exist, create it as a new file.
    Several children can be added, by using `org-brain-entry-separator'."
    (interactive)
    (let ((entry (org-brain-entry-at-pt))
          (header (read-string "Add child: "))
          (file (format-time-string "%Y-%m-%dT%H.%M.%S"))
          (date (format-time-string "%Y-%m-%dT%H.%M.%S")))
      (my/org-brain-add-relationship entry file header date))
    (org-brain--revert-if-visualizing))

  (defun my/org-brain-add-relationship (parent child title date)
    "Add external relationship between PARENT and CHILD."
    (when (equal parent child)
      (error "An entry can't be a parent/child to itself"))
    (unless (member child (org-brain-children parent))
      (if (org-brain-filep parent)
          ;; Parent = File
          (with-current-buffer (find-file-noselect (org-brain-entry-path parent))
            (goto-char (point-min))
            (if (re-search-forward "^#\\+CHILDREN:.*$" nil t)
                (insert (concat " " (org-brain-entry-identifier child)))
              (insert (concat "#+CHILDREN: "
                              (org-brain-entry-identifier child)
                              "\n\n")))
            (save-buffer))
        ;; Parent = Headline
        (org-entry-add-to-multivalued-property (org-brain-entry-marker parent)
                                               "CHILDREN"
                                               (org-brain-entry-identifier child)))
      (if (org-brain-filep child)
          ;; Child = File
          (with-current-buffer (find-file-noselect (org-brain-entry-path child))
            (goto-char (point-min))
            (if (re-search-forward "^#\\+PARENTS:.*$" nil t)
                (insert (concat " " (org-brain-entry-identifier parent)))
              (insert (concat "#+PARENTS: "
                              (org-brain-entry-identifier parent)
                              "\n\n"))

              (insert (concat"#+TITLE: " title ))
              (insert "\n")
              (insert (concat ">>>" (file-name-base buffer-file-name)))
              (insert "\n")
              (insert (concat "#+DATE: " (format-time-string "[%Y-%m-%d %H:%M]\n")))
              (insert "#+KEYWORDS: ")
              (insert "\n\n\n\n\n\n")
              (insert "Related:")
              (insert "\n\n\n\n")
              (insert "References:")
              )
            (save-buffer))
        ;; Child = Headline
        (org-entry-add-to-multivalued-property (org-brain-entry-marker child)
                                               "PARENTS"
                                               (org-brain-entry-identifier parent)))))

  (defun my/org-brain-visualize-current ()
    (interactive)
    (org-brain-visualize (org-brain-entry-at-pt))
    (delete-other-windows))

  (defun my/org-brain-goto-current-main ()
    (interactive)
    (org-brain-goto-current (org-brain-entry-at-pt))
    (delete-other-windows))

  )
#+END_SRC
** DISABLED memacs
#+BEGIN_SRC emacs-lisp
(defun memacs-chrome ()
(interactive)
(shell-command "~/bin/memacs-chrome.sh"))

(defun my/memacs-org-agenda ()
   "Opens an org-agenda with activated archive"
   (interactive)
   (memacs-chrome)
   (setq org-agenda-files "~/org/meta/web.org")
   (org-agenda-list)
   ;;(call-interactively 'org-agenda-log-mode)
   (org-agenda-log-mode '(4))
   (call-interactively 'org-agenda-archives-mode)
   (org-agenda-archives-mode 'files)
   )


#+END_SRC
** DISABLED google-translate
#+BEGIN_SRC emacs-lisp
(use-package google-translate)
#+END_SRC
** DISABLED writeroom-mode
#+BEGIN_SRC emacs-lisp
(use-package writeroom-mode :ensure t)
#+END_SRC

** DISABLED themes
#+BEGIN_SRC emacs-lisp
(use-package base16-theme
  :ensure t)

#+END_SRC
** DISABLED annotate
#+BEGIN_SRC emacs-lisp
(use-package annotate)
#+END_SRC
** DISABLED htmlize
#+BEGIN_SRC emacs-lisp
(use-package htmlize)
#+END_SRC
** DISABLED ripgrep
#+BEGIN_SRC emacs-lisp
  (use-package rg
    :ensure t
    :init
    (rg-enable-default-bindings))

  (use-package dumb-jump
    :config
    (setq dumb-jump-selector 'ivy)
    (setq dumb-jump-prefer-searcher 'rg))

#+END_SRC
** DISABLED ace-link
#+BEGIN_SRC emacs-lisp
(use-package ace-link
  :demand t
  :config (ace-link-setup-default))
#+END_SRC

** DISABLED link-hint
#+BEGIN_SRC emacs-lisp
(use-package link-hint :ensure t)
#+END_SRC
** DISABLED use-package-hydra
#+BEGIN_SRC emacs-lisp
(use-package use-package-hydra
  :ensure t)
#+END_SRC

** DISABLED major-mode-hydra
#+BEGIN_SRC emacs-lisp
(use-package major-mode-hydra
  :bind
  ("C-M-m" . major-mode-hydra))

(setq major-mode-hydra-title-generator
      '(lambda (mode)
         (s-concat "n"
                   (s-repeat 10 " ")
                   (all-the-icons-icon-for-mode mode :v-adjust 0.05)
                   " "
                   (symbol-name mode)
                   " commands")))


#+END_SRC
** DISABLED crux
#+BEGIN_SRC emacs-lisp
(use-package crux)
#+END_SRC
** DISABLED General
*** DISABLED package
#+BEGIN_SRC emacs-lisp
  (use-package general
    :after which-key)
#+END_SRC
*** DISABLED configuration
  #+BEGIN_SRC emacs-lisp
    (general-create-definer tyrant-def
      :prefix "C-SPC"
      :global-prefix "SPC"
      :keymaps 'boon-moves-map)

    (general-create-definer despot-def
      :prefix "C-SPC"
      :global-prefix "SPC"
      :keymaps 'boon-moves-map)

    (general-define-key
      :keymaps 'key-translation-map
      "ESC" (kbd "C-g"))

    (tyrant-def

      ""     nil
      "SPC" 'counsel-M-x
      "RET" 'counsel-linux-app
      "@"  'hycontrol-windows-grid
      "0"  'delete-window
      "1"  'delete-other-windows
      "2"  'split-window-below
      "3"  'split-window-right

      ;; Buffer operations
      "b"   '(:ignore t :which-key "buffer")
      "bb"  'counsel-switch-buffer
      "bB"  'counsel-switch-buffer-other-window
      "bk"  'kill-this-buffer
      "bn"  'next-buffer
      "bp"  'previous-buffer
      "bi"  'ibuffer

      ;; Window operations
      "w"   '(:ignore t :which-key "window")
      "wu"  'winner-undo
      "wr"  'winner-redo


      ;; File operations
      "f"  '(:ignore t :which-key "files")
      "fj"  'dired-jump
      "fl"  'find-file-literally
      "fr"  'crux-rename-file-and-buffer
      "fw"  'write-file
      "fs"  'save-buffer

      ;; Applications
      "a"   '(:ignore t :which-key "applications")
      "ad"  'dired
      "ac"  'calendar
      "ag" 'deadgrep

      "ap" '(:keymap projectile-command-map :wk "projectile")

      )
  #+END_SRC
** DISABLED boxquote
#+BEGIN_SRC emacs-lisp
(use-package boxquote
  :ensure t
  :defer t
  :config
  (setq-default  boxquote-bottom-corner "╰"      ; U+2570
                 boxquote-side          "│ "     ; U+2572 + space
                 boxquote-top-and-tail  "────"   ; U+2500 (×4)
                 boxquote-top-corner    "╭")     ; U+256F
  (when (package-installed-p 'hydra)
    (eval-and-compile
      (defhydra hydra-boxquote (:color blue :hint nil)
       "
                                                                    ╭──────────┐
  Text           External           Apropos         Do              │ Boxquote │
╭───────────────────────────────────────────────────────────────────┴──────────╯
  [_r_] region        [_f_] file      [_K_] describe-key        [_t_] title
  [_p_] paragraph     [_b_] buffer    [_F_] describe-function   [_u_] unbox
  [_a_] buffer        [_s_] shell     [_V_] describe-variable   [_w_] fill-paragraph
  [_e_] text           ^ ^            [_W_] where-is            [_n_] narrow
  [_d_] defun         [_y_] yank       ^ ^                      [_c_] narrow to content
  [_q_] boxquote      [_Y_] yanked     ^ ^                      [_x_] kill
--------------------------------------------------------------------------------
       "
      ("<esc>" nil "quit")
      ("x" boxquote-kill)
      ("Y" boxquote-yank)
      ("e" boxquote-text)
      ("u" boxquote-unbox)
      ("d" boxquote-defun)
      ("t" boxquote-title)
      ("r" boxquote-region)
      ("a" boxquote-buffer)
      ("q" boxquote-boxquote)
      ("W" boxquote-where-is)
      ("p" boxquote-paragraph)
      ("f" boxquote-insert-file)
      ("K" boxquote-describe-key)
      ("s" boxquote-shell-command)
      ("b" boxquote-insert-buffer)
      ("y" boxquote-kill-ring-save)
      ("w" boxquote-fill-paragraph)
      ("F" boxquote-describe-function)
      ("V" boxquote-describe-variable)
      ("n" boxquote-narrow-to-boxquote)
      ("c" boxquote-narrow-to-boxquote-content)))))

#+END_SRC
** DISABLED spray
#+BEGIN_SRC emacs-lisp
  (use-package spray :ensure t)
#+END_SRC
** DISABLED flycheck
 #+BEGIN_SRC emacs-lisp
(defhydra hydra-flycheck (:color blue :hint nil :inherit (hydra-common/heads)
                                 :pre (progn
                                        (exwm-input-line-mode))
                                 :post (progn
                                         (exwm-input-char-mode)))


  "
                                                                    ╭──────────┐
   Navigate          Show Errors                  Do                │ Flycheck │
╭───────────────────────────────────────────────────────────────────┴──────────╯
   ^_p_^revious     [_l_] list errors           [_t_] toggle Flycheck
      ^^↑^^         [_d_] clear all errors      [_c_] select checker
    ^_f_^irst        ^ ^                        [_r_] run via compile
      ^^↓^^          ^ ^                        [_h_] describe checker
    ^_n_^ext
--------------------------------------------------------------------------------
      "
  ("c" flycheck-select-checker)
  ("h" flycheck-describe-checker)
  ("d" flycheck-clear)
  ("f" flycheck-first-error)
  ("l" flycheck-list-errors)
  ("n" flycheck-next-error :color red)
  ("p" flycheck-previous-error :color red)
  ("r" flycheck-compile)
  ("t" flycheck-mode))
 #+END_SRC
