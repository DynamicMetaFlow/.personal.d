:HIDDEN:
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <link href="css/style.css" rel="stylesheet" type="text/css" />
#+HTML_HEAD_EXTRA: <style>div#content { max-width: 2000px; }</style>

#+EXPORT_FILE_NAME: index.html
#+EXPORT_EXCLUDE_TAGS: noexport
:END:
#+TITLE: Personal Configuration
#+PROPERTY: header-args :results silent :tangle personal-config.el

* Modules
** Window Manager
*** EXWM
**** setup
   #+BEGIN_SRC emacs-lisp
(use-package exwm
  :config
  (require 'exwm)
  (require 'exwm-systemtray)
  (require 'exwm-randr)

  (display-time-mode t)
  (display-battery-mode nil)

  (setq use-dialog-box nil)
  (setq exwm-workspace-show-all-buffers t)
  (setq exwm-layout-show-all-buffers t)

  (setq exwm-workspace-number 9)

  (defun exwm-workspace-number-to-string (number)
    (number-to-string (1+ number)))

  (setq exwm-workspace-index-map #'exwm-workspace-number-to-string)


  (dotimes (i 9)
    (exwm-input-set-key (kbd (format "s-%d" i))
                        `(lambda ()
                           (interactive)
                           (exwm-workspace-switch-create (1- ,i)))))

  (ido-mode 0)

  (setq display-time-default-load-average nil)

  (setq window-divider-default-bottom-width 2
        window-divider-default-right-width 2)

  (setq exwm-manage-configurations '((t char-mode t)))

  (defvar exwm-toggle-workspace 0
    "Previously selected workspace. Used with `exwm-jump-to-last-exwm'.")

  (defun exwm-jump-to-last-exwm ()
    (interactive)
    (exwm-workspace-switch exwm-toggle-workspace))

  (defadvice exwm-workspace-switch (before save-toggle-workspace activate)
    (setq exwm-toggle-workspace exwm-workspace-current-index))

  (defun my/exwm-rename-buffer-to-title () (exwm-workspace-rename-buffer exwm-title))

  (add-hook 'exwm-update-title-hook 'my/exwm-rename-buffer-to-title)

  (add-hook 'exwm-floating-setup-hook 'exwm-layout-hide-mode-line)
  (add-hook 'exwm-floating-exit-hook 'exwm-layout-show-mode-line)

  (defun my-exwm-workspace-display-current ()
    "Display current workspace index."
    (interactive)
    (let ((message-log-max))
      (message (elt exwm-workspace--switch-history
                    exwm-workspace-current-index))))

  (defvar exwm-workspace-switch-wrap t
    "Whether `exwm-workspace-next' and `exwm-workspace-prev' should wrap.")

  (defun exwm-workspace-next ()
    "Switch to next exwm-workspaceective (to the right)."
    (interactive)
    (let* ((only-workspace? (equal exwm-workspace-number 1))
           (overflow? (= exwm-workspace-current-index
                         (1- exwm-workspace-number))))
      (cond
       (only-workspace? nil)
       (overflow?
        (when exwm-workspace-switch-wrap
          (exwm-workspace-switch 0)))
       (t (exwm-workspace-switch  (1+ exwm-workspace-current-index))))))

  (defun exwm-counsel-yank-pop ()
    "Same as `counsel-yank-pop' and paste into exwm buffer."
    (interactive)
    (let ((inhibit-read-only t)
          ;; Make sure we send selected yank-pop candidate to
          ;; clipboard:
          (yank-pop-change-selection t))
      (call-interactively #'counsel-yank-pop))
    (when (derived-mode-p 'exwm-mode)
      (exwm-input--set-focus (exwm--buffer->id (window-buffer (selected-window))))
      (exwm-input--fake-key ?\C-v)))


  (defun exwm-workspace-prev ()
    "Switch to next exwm-workspaceective (to the right)."
    (interactive)
    (let* ((only-workspace? (equal exwm-workspace-number 1))
           (overflow? (= exwm-workspace-current-index 0)))
      (cond
       (only-workspace? nil)
       (overflow?
        (when exwm-workspace-switch-wrap
          (exwm-workspace-switch (1- exwm-workspace-number))))
       (t (exwm-workspace-switch  (1- exwm-workspace-current-index))))))

  ;; Quick swtiching between workspaces
  (defvar exwm-toggle-workspace 0
    "Previously selected workspace. Used with `exwm-jump-to-last-exwm'.")
  (defun exwm-jump-to-last-exwm ()
    (interactive)
    (exwm-workspace-switch exwm-toggle-workspace))

  (defadvice exwm-workspace-switch (before save-toggle-workspace activate)
    (setq exwm-toggle-workspace exwm-workspace-current-index))

  (defun my-exwm-define-key-chords ()
    "Define local key chords for Exwm buffer."
    (map-keymap
     (lambda (event-type key-chord-map)
       (when (eq event-type 'key-chord)
         (map-keymap
          (lambda (key _)
            (define-key exwm-mode-map (string key)
              (lambda ()
                (interactive)
                (exwm-input--fake-key key))))
          key-chord-map)))
     (current-global-map)))

                                        ;   (key-chord-define-local "JJ" #'my-counsel-ibuffer-by-exwm-class-name)
                                        ;   (add-hook 'exwm-mode-hook #'my-exwm-define-key-chords)

  (add-hook 'exwm-workspace-switch-hook #'my-exwm-workspace-display-current)
  (advice-add 'exwm-workspace-add :after #'my-exwm-workspace-display-current)
  (advice-add 'exwm-workspace-delete :after #'my-exwm-workspace-display-current)


  (window-divider-mode))
     #+END_SRC

     #+results:
     : t

**** packages
***** xelb
   #+BEGIN_SRC emacs-lisp
(use-package xelb)
   #+END_SRC
***** exwm-edit
   #+BEGIN_SRC emacs-lisp
(use-package exwm-edit)
   #+END_SRC
**** keybindings
   #+BEGIN_SRC emacs-lisp
(setq exwm-input-line-mode-passthrough t)

(defun exwm-input-line-mode ()
  "Set exwm window to line-mode and show mode line"
  (call-interactively #'exwm-input-grab-keyboard)
  (exwm-layout-show-mode-line))

(defun exwm-input-char-mode ()
  "Set exwm window to char-mode and hide mode line"
  (call-interactively #'exwm-input-release-keyboard)
  (exwm-layout-hide-mode-line))

(defun exwm-input-toggle-mode ()
  "Toggle between line- and char-mode"
  (with-current-buffer (window-buffer)
    (when (eq major-mode 'exwm-mode)
      (if (equal (second (second mode-line-process)) "line")
          (exwm-input-char-mode)
        (exwm-input-line-mode)))))

(defun exwm-input-set-global-key (key function)
  "Add KEY to `exwm-input-prefix-keys' and bind FUNCTION to KEY
        in exwm keymap"
  (cl-pushnew (elt key 0) exwm-input-prefix-keys)
  (exwm-input-set-key key function))

(defun my/switch-to-last-buffer ()
  "Switch to last open buffer in current window."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))

(define-key minibuffer-inactive-mode-map [mouse-1] #'ignore)

(push ?\s-  exwm-input-prefix-keys)

(defvar exwm-input-prefix-keys-extra nil)

                                        ;(define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)
                                        ;(define-key exwm-mode-map [?\C-c C-f] 'exwm-layout-set-fullscreen)
                                        ;(define-key exwm-mode-map [?\C-c C-h] 'exwm-floating-hide)
                                        ;(define-key exwm-mode-map [?\C-c C-k] 'exwm-input-release-keyboard)
                                        ;(define-key exwm-mode-map [?\C-c C-t C-f] 'exwm-floating-toggle-floating)
                                        ;(define-key exwm-mode-map [?\C-c C-t C-m] 'exwm-layout-toggle-mode-line)


(setq exwm-input-simulation-keys
      '(
        ;; movement
        ([?\C-b] . [left])
        ([?\C-f] . [right])
        ([?\C-p] . [up])
        ([?\C-n] . [down])
        ([?\C-a] . [home])
        ([?\C-e] . [end])
        ([?\M-v] . [prior])
        ([?\C-v] . [next])
        ([?\C-d] . [delete])
        ([?\C-k] . [S-end delete])

        ;; cut/paste
        ([?\C-w] . [?\C-x])
        ([?\M-w] . [?\C-c])
        ([?\C-y] . [?\C-v])
        ;; search
        ([?\C-s] . [?\C-f])))

(defun my-exwm-keybindings ()
  "Add the key bindings for exwm."
  (exwm-input-set-key (kbd "<print>") #'desktop-environment-screenshot)

  ;; (exwm-input-set-key (kbd "C-SPC")
  ;;                     (lambda ()
  ;;                       (interactive)
  ;;                       (exwm-input-line-mode)
  ;;                       (hydra-master/body)))

  (exwm-input-set-key (kbd "\\")
                      (lambda ()
                        (interactive)
                        (exwm-input-line-mode)
                        (boon-mode-hydra)))


  (exwm-input-set-key (kbd "s-p")   'my/switch-to-last-buffer)
  (exwm-input-set-key (kbd "s-SPC") 'exwm-jump-to-last-exwm)
  (exwm-input-set-key (kbd "s-<tab>") 'ivy-switch-buffer-exwm)


  (exwm-input-set-key (kbd "s-f")   'my/toggle-maximize)

  (exwm-input-set-key (kbd "s-f")   'my/toggle-maximize)

  (exwm-input-set-key (kbd "s-,")   'winner-undo)
  (exwm-input-set-key (kbd "s-.")   'winner-redo)

  (exwm-input-set-key (kbd "s-r") 'exwm-reset)
  (exwm-input-set-key (kbd "s-w") 'exwm-workspace-switch)

  (exwm-input-set-key (kbd "s-l") 'windmove-right)
  (exwm-input-set-key (kbd "s-k") 'windmove-left)
  (exwm-input-set-key (kbd "s-i") 'windmove-up)
  (exwm-input-set-key (kbd "s-o") 'windmove-down)


  (exwm-input-set-key (kbd "s-L") 'buf-move-right)
  (exwm-input-set-key (kbd "s-K") 'buf-move-left)
  (exwm-input-set-key (kbd "s-I") 'buf-move-up)
  (exwm-input-set-key (kbd "s-O") 'buf-move-down)

  (exwm-input-set-key (kbd "s-x") 'exwm-input-toggle-keyboard))


   #+END_SRC

   #+results:
   : my-exwm-keybindings

**** ibuffer
   #+BEGIN_SRC emacs-lisp
(setq ibuffer-saved-filter-groups
      (quote (("default"
               ("EXWM" (mode . exwm-mode))))))
                                        ;       ("org-mode" (mode . org-mode))
                                        ;       ("git" (mode . magit-status-mode))
                                        ;       ("dired" (mode . dired-mode))
                                        ;       ("emacs" (or
                                        ;                (name . "^\\*scratch\\*$")
                                        ;                (name . "^\\*Messages\\*$")
                                        ;                (name . "^\\*Bookmark List\\*$")
                                        ;                (name . "^\\*GNU Emacs\\*$")))))))

(add-hook 'ibuffer-mode-hook
          (lambda ()
            (ibuffer-switch-to-saved-filter-groups "default")))


(define-ibuffer-column size-h
  (:name "Size")
  (cond
   ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
   ((> (buffer-size) 100000) (format "%7.0fk" (/ (buffer-size) 1000.0)))
   ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
   (t (format "%8d" (buffer-size)))))

(define-ibuffer-column exwm-class
  (:name "Class")
  (cond
   (exwm-class-name (format "%s" exwm-class-name))
   (t (format "%s" ""))))

;; Needs work to look good, major-mode is not equal to ibuffer-formats mode
(define-ibuffer-column exwm-mode
  (:name "EXWM-Mode")
  (cond
   ((string-equal major-mode "exwm-mode") (format "%s" exwm-class-name))
   (t (format "%s" mode-name))))

(setq ibuffer-formats
      '((mark modified read-only locked " "
              (name 50 50 :left :elide)
              " "
              (size-h 16 16 :right)
              " "
              (exwm-mode 18 18 :left :elide)
              " " filename-and-process)
        (mark modified read-only locked " "
              (name 50 50 :left :elide)
              " "
              (size-h 16 16 :right)
              " "
              (mode 18 18 :left :elide)
              (exwm-class 18 18 :left :elide)
              " " filename-and-process)
        (mark " "
              (name 16 -1)
              " " filename)))

(defun my-counsel-ibuffer-by-exwm-class-name ()
  "`counsel-ibuffer' limited to Exwm buffers of same X class."
  (interactive)
  (require 'ibuffer)
  (cl-letf*
      ((class-name exwm-class-name)
       (get-buffers-function
        (symbol-function 'counsel-ibuffer--get-buffers))
       ((symbol-function 'counsel-ibuffer--get-buffers)
        (lambda ()
          (--filter (with-current-buffer (cdr it)
                      (and (eq major-mode 'exwm-mode)
                           (string-equal exwm-class-name class-name)))
                    (funcall get-buffers-function)))))
    (counsel-ibuffer)))

   #+END_SRC
**** randr
   #+BEGIN_SRC emacs-lisp
;; ;; Enable two xrandr outputs one named 'default' and another named 'other'.
;; (defun my-exwm-xrandr-two-outputs (default other)
;;   (shell-command
;;    (concat "xrandr --output " other " --left-of " default " --auto")))

;; ;; Enable only one xrandr output named 'default'.
;; (defun my-exwm-xrandr-one-output (default)
;;   (shell-command (concat "xrandr --output " default " --auto")))

;; ;; Disable xrandr output named 'output'.
;; (defun my-exwm-xrandr-off (output)
;;   (if output (shell-command (concat "xrandr --output " output " --off"))))

;; ;; Update exwm-randr-workspace-output-plist with two outputs named
;; ;; 'default' and 'other'.  If the 'other' output is same as 'default'
;; ;; then all workspaces will be redirected to the 'default' output.
;; (defun my-exwm-xrandr-config (default other)
;;   (setq exwm-randr-workspace-output-plist
;; 	(progn
;; 	  (setq result (list 0 default))
;; 	  (setq index 1)
;; 	  (while (< index exwm-workspace-number)
;; 	    (setq result (append result (list index other)))
;; 	    (setq index (1+ index)))
;; 	  result)))

;; ;; Dynamically find the active xrandr outputs and update exwm
;; ;; workspace configuration and enable xrandr outputs appropriately.
;; (defun my-exwm-xrandr-hook (default)
;;   (let* ((connected-cmd "xrandr -q|awk '/ connected/ {print $1}'")
;; 	 (connected (process-lines "bash" "-lc" connected-cmd))
;; 	 (previous (delete-dups (seq-remove
;; 				 'integerp
;; 				 exwm-randr-workspace-output-plist))))
;;     (cond ((member "VGA1" connected)
;; 	   (progn (my-exwm-xrandr-config default "VGA1")
;; 		  (my-exwm-xrandr-two-outputs default "VGA1")))

;;           ((member "HDMI1" connected)
;; 	   (progn(my-exwm-xrandr-config default "HDMI1")
;; 		  (my-exwm-xrandr-two-outputs default "HDMI1")))

;;           ((member "HDMI2" connected)
;; 	   (progn(my-exwm-xrandr-config default "HDMI2")
;; 		  (my-exwm-xrandr-two-outputs default "HDMI2")))

;;           (t (progn (my-exwm-xrandr-config default default)
;; 		    (mapcar 'my-exwm-xrandr-off
;; 			    (delete default previous)))))))

;; (setq exwm-randr-screen-change-hook
;;       (lambda () (my-exwm-xrandr-hook "eDP1")))

(defvar exwm-connected-displays 2
  "Number of connected displays.")

;; Update exwm-randr-workspace-output-plist with 2 or 3 outputs named
;; 'primary' and 'other-1'/'other-2'.
;; With 3 outputs connected the first workspace will be primary,
;; second workspace goes to 'other-2' and all others to 'other-1'.
;; With 2 outputs, first workspace is 'primary' display and rest 'other-1'.
;; And with only one connected output, primary has all workspaces.
(defun my/exwm-randr-screen-change ()
  (let* ((connected-cmd "xrandr -q|awk '/ connected/ {print $1}'")
         (connected (process-lines "bash" "-lc" connected-cmd))
         (primary (car connected))  ; Primary display is always first in list
         (other-1 (cadr connected))
         (other-2 (caddr connected)))
    (setq exwm-connected-displays (length connected))
    (setq exwm-randr-workspace-monitor-plist
          (append (list 0 primary)
                  (list 1 (or other-2 other-1 primary))
                  (mapcan (lambda (i) (list i (or other-1 other-2 primary)))
                          (number-sequence 2 exwm-workspace-number))))
    (exwm-randr-refresh)
    (message "Randr: %s monitors refreshed." (string-join connected ", "))))

(add-hook 'exwm-randr-screen-change-hook #'my/exwm-randr-screen-change)


   #+END_SRC

   #+results:
   | lambda | nil | (my-exwm-xrandr-hook eDP1) |

**** autostart
   #+BEGIN_SRC emacs-lisp
(defun app/autostart (application)
  "Add an application to autostart."
  (add-hook 'exwm-init-hook
            `(lambda ()
               (start-process-shell-command "autostart-process" nil ,application))))

(defun my-exwm-autostart ()
  "Add applications that will be loaded after exwm init is done."
  (mapcar (lambda (program) (app/autostart program)) exwm-autostart))


(setq exwm-autostart
      (list
       "thinkpad-dock"
                                        ;          "autorandr --change"
       "nm-applet"
       "compton -b"
       "volumeicon"
       "thinkpad-touchpad off"
       "/usr/bin/dunst"
       "/usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1"
       "/usr/lib/gpaste/gpaste-daemon &"
       "pamac-tray"
       "redshift-gtk"
       "kdeconnect-indicator"

       ))


(add-hook 'after-init-hook
          (lambda ()
            (exwm-randr-enable)
            (exwm-systemtray-enable)
            (exwm-input--update-global-prefix-keys)
            (my-exwm-keybindings)
            (my-exwm-autostart)
            (exwm-init)

            t))
   #+END_SRC

   #+results:
   | (lambda nil (exwm-randr-enable) (exwm-systemtray-enable) (exwm-input--update-global-prefix-keys) (my-exwm-keybindings) (my-exwm-autostart) (exwm-init) t) | ivy-mode | x-wm-set-size-hint | tramp-register-archive-file-name-handler | table--make-cell-map |
** Discoverability
*** Hydra
**** setup
   #+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t
  :defer 0.1
  :config

  (defun counsel-projectile-switch-to-buffer-other-window ()
    "Jump to a buffer in the current project."
    (interactive)
    (other-window 1)
    (counsel-projectile-switch-to-buffer))

  (defun counsel-projectile-find-dir-other-window ()
    "Jump to a buffer in the current project."
    (interactive)
    (other-window 1)
    (counsel-projectile-find-dir))

  (defun counsel-projectile-find-file-other-window ()
    "Jump to a buffer in the current project."
    (interactive)
    (other-window 1)
    (counsel-projectile-find-file))

  (defun counsel-projectile-find-file-dwim-other-window ()
    "Jump to a buffer in the current project."
    (interactive)
    (other-window 1)
    (counsel-projectile-find-file-dwim))

  (setq lv-use-separator t)
  (set-face-attribute 'hydra-face-blue nil :foreground "deep sky blue" :weight 'bold))
   #+END_SRC
**** common
   #+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defhydra hydra-common  (
                           :color blue
                           :hint nil
                           :pre (progn
                                  (exwm-input-line-mode))
                           :post (progn
                                   (exwm-input-char-mode)))
    ("RET"   counsel-linux-app nil)
    ("SPC" counsel-M-x nil)

    ("Q" kill-this-buffer nil)

    ("<tab>" ivy-switch-buffer-non-exwm)
    ("s-<tab>"  ivy-switch-buffer-exwm)

    ("q"   my/switch-to-last-buffer nil)
    ("@"   counsel-org-capture nil)
    ("W"   hydra-window/body nil)

    ("0" delete-window)
    ("1" delete-other-windows)
    ("2" split-window-below)
    ("3" split-window-right)
    ("4" split-window-up)
    ("5" split-window-left)

    (";" ace-swap-window)
    ("#" hycontrol-windows-grid)




    ))
   #+END_SRC

   #+results:
   : hydra-common/body

**** master
   #+BEGIN_SRC emacs-lisp
(eval-and-compile
  (defhydra hydra-master (
                          :color blue
                          :column 2
                          :pre (progn
                                 (exwm-input-line-mode))
                          :post (progn
                                  (exwm-input-char-mode))
                          :inherit (hydra-common/heads))
    "Master"
    ("a" hydra-applications/body "apps")
    ("b" hydra-bookmarks/body "bookmarks")
    ("c" quick-calc "calc")
    ("e" hydra-emacs/body "emacs")
    ("f" hydra-file/body "file")
    ("l" hydra-spell/body "spell")
    ("m" boon-mode-hydra "major")
    ("M" hydra-minor/body nil)
    ("o" hydra-agenda/body "org-agenda")
    ("p" hydra-projects/body "projects")
    ("s" hydra-search/body "search")
    ("t" hydra-terminal/body "term")
    ("x" hydra-text/body "text")



    ))
     #+END_SRC

     #+results:
     : hydra-master/body

**** projects
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-projects (:color blue :hint nil
                                 :pre (progn
                                        (exwm-input-line-mode))
                                 :post (progn
                                         (exwm-input-char-mode))
                                 :inherit (hydra-common/heads))
  "
                                                                     ╭────────────┐
     Files             Search          Buffer             Do         │ Projectile │
   ╭─────────────────────────────────────────────────────────────────┴────────────╯
     [_f_] file          [_sa_] ag          [_b_] switch         [_g_] magit
     [_l_] file dwim     [_sr_] rg          [_v_] show all       [_p_] switch
     [_r_] recent file   [_so_] occur       [_V_] ibuffer        [_P_] commander
     [_d_] dir           [_sR_] replace     [_K_] kill all       [_i_] info
     [_o_] other         [_st_] find tag
     [_u_] test file     [_sT_] make tags
                                                                         ╭────────┐
     Other Window      Run             Cache              Do             │ Fixmee │
   ╭──────────────────────────────────────────────────╯ ╭────────────────┴────────╯
     [_F_] file          [_U_] test        [_kc_] clear         [_x_] TODO & FIXME
     [_L_] dwim          [_m_] compile     [_kk_] add current   [_X_] toggle
     [_D_] dir           [_c_] shell       [_ks_] cleanup
     [_O_] other         [_C_] command     [_kd_] remove
     [_B_] buffer
   --------------------------------------------------------------------------------
         "

  ("p"   projectile-switch-project)
  ("sa"   counsel-projectile-ag)
  ("sr"   counsel-projectile-rg)
  ("b"   counsel-projectile-switch-to-buffer)
  ("B"   counsel-projectile-switch-to-buffer-other-window)
  ("d"   counsel-projectile-find-dir)
  ("D"   counsel-projectile-find-dir-other-window)
  ("f"   counsel-projectile-find-file)
  ("F"   counsel-projectile-find-file-other-window)
  ("l"   counsel-projectile-find-file-dwim)
  ("L"   counsel-projectile-find-file-dwim-other-window)

  ("c"   projectile-run-async-shell-command-in-root)
  ("C"   projectile-run-command-in-root)
  ("g"   hydra-git/body nil)
  ("i"   projectile-project-info)
  ("kc"  projectile-invalidate-cache)
  ("kd"  projectile-remove-known-project)
  ("kk"  projectile-cache-current-file)
  ("K"   projectile-kill-buffers)
  ("ks"  projectile-cleanup-known-projects)
  ("m"   projectile-compile-project)
  ("o"   projectile-find-other-file)
  ("O"   projectile-find-other-file-other-window)
  ("P"   projectile-commander)
  ("r"   projectile-recentf)
  ("so"   projectile-multi-occur)
  ("sR"   projectile-replace)
  ("st"   projectile-find-tag)
  ("sT"   projectile-regenerate-tags)
  ("u"   projectile-find-test-file)
  ("U"   projectile-test-project)
  ("v"   projectile-display-buffer)
  ("V"   projectile-ibuffer)

  ("X"   fixmee-mode)
  ("x"   fixmee-view-listing))

(define-key projectile-mode-map (kbd "C-c o") #'hydra-project/body)

   #+END_SRC
**** agenda
    #+BEGIN_SRC emacs-lisp
(defhydra hydra-agenda (
                        :color blue
                        :columns 4
                        :pre (progn
                               (exwm-input-line-mode))
                        :post (progn
                                (exwm-input-char-mode)))
  "Agenda"

  ("a" (org-agenda nil " ") "agenda")
  ("n" howm-list-all "notes")
  ("c" counsel-org-capture "capture")
  ("p" org-boxes-workflow "process inbox")






  )
    #+END_SRC
**** emacs
    #+BEGIN_SRC emacs-lisp
(defhydra hydra-emacs (:color blue :hint nil :inherit (hydra-common/heads)
                              :pre (progn
                                     (exwm-input-line-mode))
                              :post (progn
                                      (exwm-input-char-mode)))

  "
                                                                       ╭───────┐
   Execute       Packages         Help                     Misc        │ Emacs │
╭──────────────────────────────────────────────────────────────────────┴───────╯
  [_x_] counsel M-x [_p_] list      [_f_] describe function [_t_] change theme
  [_e_] exit        [_i_] install   [_v_] describe variable [_l_] list emacs process
  [_s_] system      [_u_] upgrade   [_m_] info manual       [_c_] init time
   ^ ^               ^ ^            [_k_] bindings          [_o_] unbound commands
   ^ ^               ^ ^            [_b_] personal bindings [_y_] emacs colors
   ^ ^               ^ ^             ^ ^                    [_z_] list faces
   ^ ^               ^ ^             ^ ^
--------------------------------------------------------------------------------
      "
  ("C-h b" counsel-descbinds "bindings")
  ("f" counsel-describe-function)
  ("v" counsel-describe-variable)
  ("b" describe-personal-keybindings)
  ("c" emacs-init-time)
  ("i" package-install)
  ("k" counsel-descbinds)
  ("l" list-processes)
  ("m" info-display-manual)
  ("p" paradox-list-packages)
  ("t" counsel-load-theme)
  ("u" paradox-upgrade-packages)
  ("o" smex-show-unbound-commands)
  ("y" counsel-colors-emacs)
  ("z" counsel-faces)
  ("x" counsel-M-x)
  ("e" save-buffers-kill-emacs)
  ("s" hydra-system/body nil)
  )
    #+END_SRC

**** terminal
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-terminal (:color blue :hint nil :inherit (hydra-common/heads)
                                 :pre (progn
                                        (exwm-input-line-mode))
                                 :post (progn
                                         (exwm-input-char-mode)))

  "
                                                                      ╭──────────┐
   Terminals                     System                               │ Terminal │
╭─────────────────────────────────────────────────────────────────────┴──────────╯
  [_s_] new multi-term           [_c_] shell command
  [_n_] next multi-term          [_a_] aync shell command
  [_p_] previous multi-term      [_m_] man page
  [_d_] dedicated multi-term     [_l_] list system process
  [_e_] eshell
--------------------------------------------------------------------------------
      "
  ("a" async-shell-command)
  ("c" shell-command)
  ("e" eshell)
  ("m" man)
  ("l" proced)
  ("s" multi-term)
  ("n" multi-term-next)
  ("p" multi-term-previous)
  ("d" multi-term-dedicated-toggle))

   #+END_SRC

**** file
    #+BEGIN_SRC emacs-lisp
(defhydra hydra-file (:color blue :hint nil :inherit (hydra-common/heads)
                             :pre (progn
                                    (exwm-input-line-mode))
                             :post (progn
                                     (exwm-input-char-mode)))
  "
                                                                        ╭──────┐
     Ivy                    Dired            Hydras                     │ File │
╭───────────────────────────────────────────────────────────────────────┴──────╯
  [_f_] open file            [_d_] dired     [_ht_] text
  [_e_] open file extern                   [_hs_] spell
  [_r_] open recentf                       [_hn_] narrow
                                         [_hg_] git
--------------------------------------------------------------------------------
      "
  ("f" counsel-find-file)
  ("e" counsel-find-file-extern)
  ("r" counsel-recentf "recent")
  ("d" dired)
  ("hn" hydra-narrow/body nil :color blue)
  ("hs" hydra-spell/body nil  :color blue)
  ("ht" hydra-text/body nil   :color blue)
  ("hg" hydra-git/body nil   :color blue)
  )
    #+END_SRC
**** narrow
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-narrow (:color blue :hint nil :inherit (hydra-common/heads)
                               :pre (progn
                                      (exwm-input-line-mode))
                               :post (progn
                                       (exwm-input-char-mode)))
  "
                                                                      ╭────────┐
    Narrow                                                            │ Narrow │
╭─────────────────────────────────────────────────────────────────────┴────────╯
  [_f_] narrow to defun
  [_p_] narrow to page
  [_s_] narrow to subtree
  [_r_] narrow to region

  [_w_] widen
--------------------------------------------------------------------------------
      "
  ("f" narrow-to-defun)
  ("p" narrow-to-page)
  ("s" org-narrow-to-subtree)
  ("c" org-narrow-to-block)
  ("r" narrow-to-region)
  ("w" widen))
   #+END_SRC

**** spell
    #+BEGIN_SRC emacs-lisp
(defhydra hydra-spell (:color blue :hint nil :inherit (hydra-common/heads)
                              :pre (progn
                                     (exwm-input-line-mode))
                              :post (progn
                                      (exwm-input-char-mode)))
  "
                                                                       ╭───────┐
    Flyspell               Ispell                      Gtranslate      │ Spell │
╭──────────────────────────────────────────────────────────────────────┴───────╯
  [_k_] correct word       [_w_] check word            [_g_] en ⇆ es
  [_n_] next error                                     [_G_] any lang
  [_f_] toggle flyspell
  [_p_] toggle prog mode
--------------------------------------------------------------------------------
      "
  ("w" ispell-word)
  ("d" ispell-change-dictionary)
  ("g" google-translate-smooth-translate)
  ("G" google-translate-query-translate)
  ("f" flyspell-mode)
  ("p" flyspell-prog-mode)
  ("k" flyspell-correct-word-generic)
  ("n" flyspell-goto-next-error))
    #+END_SRC

**** text
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-text (:color blue :hint nil :inherit (hydra-common/heads)
                             :pre (progn
                                    (exwm-input-line-mode))
                             :post (progn
                                     (exwm-input-char-mode)))

  "
                                                                             ╭──────┐
      Size  Toggle              Unicode                        Do            │ Text │
     ╭───────────────────────────────────────────────────────────────────────┴──────╯
       _k_  [_f_] fill column     [_d_] unicode character           [_a_] align with regex
       ^↑^  [_h_] hidden chars    [_e_] evil digraphs table         [_w_] remove trailing ' '
       ^ ^  [_l_] line numbers    [_s_] specific code block         [_n_] count words
       ^↓^  [_t_] trailing ' '    [_u_] unicode character           [_i_] lorem ipsum
       _j_  [_v_] font space      [_p_] character code              [_x_] comment box
       ^ ^  [_c_] comment          ^ ^                              [_q_] boxquote
       ^ ^  [_b_] multibyte chars  ^ ^                              [_m_] iedit (multiple)
       ^ ^   ^ ^                   ^ ^                              [_r_] expand region
       ^ ^   ^ ^                   ^ ^                              [_U_] tabs to spaces
     --------------------------------------------------------------------------------
           "
  ("a" align-regexp)
  ("b" toggle-enable-multibyte-characters)
  ("c" comment-line)
  ("d" insert-char)
  ("e" evil-ex-show-digraphs)
  ("f" fci-mode)
  ("h" whitespace-mode)
  ("i" lorem-ipsum-insert-paragraphs)
  ("k" text-scale-increase :color red)
  ("j" text-scale-decrease :color red)
  ("l" linum-mode)
  ("n" count-words)
  ("m" iedit)
  ("p" describe-char)
  ("r" er/expand-region)
  ("s" charmap)
  ("t" joe-toggle-show-trailing-whitespace)
  ("u" counsel-unicode-char)
  ("v" variable-pitch-mode)
  ("w" whitespace-cleanup)
  ("U" untabify)
  ("q" hydra-boxquote/body)
  ("x" comment-box))
   #+END_SRC

**** git
    #+BEGIN_SRC emacs-lisp
(defhydra hydra-git (:color blue :hint nil :inherit (hydra-common/heads)
                            :pre (progn
                                   (exwm-input-line-mode))
                            :post (progn
                                    (exwm-input-char-mode)))
  "
                                                                         ╭─────┐
   Magit                          VC                    Timemachine      │ Git │
╭────────────────────────────────────────────────────────────────────────┴─────╯
  [_s_] status              [_d_] diffs between revisions  [_t_] timemachine
  [_B_] blame mode          [_b_] edition history
  [_l_] file log
--------------------------------------------------------------------------------
      "
  ("B" magit-blame)
  ("b" vc-annotate)
  ("d" vc-diff)
  ("l" magit-log-buffer-file)
  ("s" magit-status)
  ("t" git-timemachine))
    #+END_SRC

**** select
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-select (:exit t :columns 4)
  "Select"
  ("v" set-mark-command "Start Cursor")
  ("b" mark-whole-buffer "Whole buffer")
  ("f" mark-defun "Function")
  ("-" em/set-mark-first-char "Start First char")
  ("_" em/set-mark-line-start "Start Line")
  ("l" em/set-mark-line "Current Line")
  ("p" er/mark-inside-pairs "Pairs / Parenthesis")
  ("t" (lambda () (interactive)(set-mark (point))(isearch-forward)) "Till")
  ("w" er/mark-word "Word / Symbol")
  ("s" mc--mark-symbol-at-point "Word / Symbol"))
   #+END_SRC
**** delete
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-delete (:exit t :columns 4)
  "Delete / Cut shortcuts"
  ("$" kill-line "Till line end")
  ("d" whole-line-or-region-kill-region "Whole line")
  ("w" kill-word "Current word")
  ("r" kill-region "Delete Region")
  ("s" sp-kill-symbol "Current symbol")
  ("c" delete-char "Current character")
  ("<SPC>" fixup-whitespace "Delete spaces")
  ("f" em-delete-function "Till charater")
  ("i" em-delete-inside "Inside")
  ("u" zop-up-to-char "Untill charater")
  ("\"" objed-kill-string "Kill String")
  ("U" (zop-up-to-char -1) "Untill backwards")
  ("a" zop-to-char "After character")
  ("A" (zop-to-char -1) "After character backwards"))
   #+END_SRC
**** paste
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-paste (:exit t :columns 4)
  "Paste"
  ("p" yank "Paste")
  ("s" (yank-pop -1) "Pop")
  ("l" my/exwm-counsel-yank-pop "History")
  )



   #+END_SRC
**** copy
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-copy (:exit t :columns 4)
  "Copy"
  ("c" whole-line-or-region-copy-region-as-kill "Line / Region")
  ("s" em/copy-symbol "Symbol")
  ("i" em-copy-inside "Inside")
  ("p" em-pop-paste "Paste Previous")
  ("w" sp-kill-word "Word")
  ("b" em-copy-all "Buffer")
  ("f" em-copy-function "Function")
  ("d" em-duplicate-line "Duplicate line"))

   #+END_SRC
**** help
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-help (:exit t :columns 4)
  "Help"
  ("f" counsel-apropos "Function search")
  ("k" view-lossage "View Keystrokes")
  ("c" find-function "Function code")
  ("P" esup "Profile")
  ("h" helpful-at-point "Help at point")
  ("p" find-function-at-point "Function at Point")
  ("l" find-library "Library source"))

   #+END_SRC
**** jump
    #+BEGIN_SRC emacs-lisp
(defhydra hydra-jump (:color blue :hint nil :inherit (hydra-common/heads)
                             :pre (progn
                                    (exwm-input-line-mode))
                             :post (progn
                                     (exwm-input-char-mode)))
  "
                                                                        ╭──────┐
  Window          WordChar        Line         iSearch                  │ Jump │
╭───────────────────────────────────────────────────────────────────────┴──────╯
  [_w_] jump        [_j_] word         [_l_] jump     [_i_] jump
  [_d_] close       [_p_] all words    [_y_] copy
  [_z_] maximize    [_b_] subword      [_m_] move
  [_s_] swap        [_c_] char         [_v_] copy region
   ^ ^              [_a_] two chars
--------------------------------------------------------------------------------
      "
  ("w" ace-window)
  ("d" ace-delete-window)
  ("z" ace-maximize-window)
  ("s" ace-swap-window)
  ("j" avy-goto-word-1)
  ("p" avy-goto-word-0)
  ("b" avy-goto-subword-0)
  ("c" avy-goto-char)
  ("a" avy-goto-char-2)
  ("l" avy-goto-line)
  ("y" avy-copy-line)
  ("m" avy-move-line)
  ("v" avy-copy-region)
  ("i" avy-isearch)
  )
    #+END_SRC
**** register
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-register (:color blue :hint nil :inherit (hydra-common/heads)
                                 :pre (progn
                                        (exwm-input-line-mode))
                                 :post (progn
                                         (exwm-input-char-mode)))

  "
                                                                        ╭──────────┐
       Logs                        Registers                Undo        │ Register │
    ╭───────────────────────────────────────────────────────────────────┴──────────╯
      [_c_] commands history       [^e^] emacs registers    [_u_] undo tree
      [_o_] messages               [_r_] evil registers
      [_l_] lossage (keystrokes)   [_m_] evil marks
      [_d_] diff buffer with file  [_k_] kill ring
    --------------------------------------------------------------------------------
          "
  ("d" joe-diff-buffer-with-file)
  ("k" counsel-yank-pop)
  ("l" view-lossage)
  ("c" counsel-command-history)
  ("m" evil-show-marks)
  ("o" view-echo-area-messages)
  ("r" evil-show-registers)
  ("u" undo-tree-visualize))
   #+END_SRC

**** search
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-search (:color blue :hint nil :inherit (hydra-common/heads)
                               :pre (progn
                                      (exwm-input-line-mode))
                               :post (progn
                                       (exwm-input-char-mode)))
  "
                                                                          ╭────────┐
       Files                             Buffer                           │ Search │
    ╭─────────────────────────────────────────────────────────────────────┴────────╯
      [_a_] regex search (Ag)           [_b_] by word
      [_r_] regex search (rg)           [_o_] by word (opened buffers)
      [_p_] regex search (pt)           [_w_] by word (multi)
      [_g_] regex search (grep)         [_h_] by word (grep or swiper)
      [^f^] find                        [_t_] tags & titles
      [_l_] locate                      [_s_] semantic
    --------------------------------------------------------------------------------
          "
  ("a" (let ((current-prefix-arg "-."))
         (call-interactively 'counsel-ag)))
  ("r" (let ((current-prefix-arg "-."))
         (call-interactively 'counsel-rg)))
  ("p" (let ((current-prefix-arg "-."))
         (call-interactively 'counsel-pt)))
  ("g" rgrep)
  ("l" counsel-locate)
  ("b" swiper)
  ("o" swiper-all)
  ("h" counsel-grep-or-swiper)
  ("t" counsel-imenu)
  ("s" counsel-semantic)
  ("w" swiper-multi))

   #+END_SRC

   #+results:
   : hydra-search/body

**** torus
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-torus (
                       :color red
                       :hint nil
                       :inherit (hydra-common/heads)
                       :pre (progn
                              (exwm-input-line-mode))
                       :post (progn
                               (exwm-input-char-mode)))
  "
                                                                                           ╭─────────┐
    Switch                    Move                        Do                               │  Torus  │
╭──────────────────────────────────────────────────────────────────────────────────────────┴─────────╯
  [_c_] circle          [_<up>_]  prev-location         [_#_]  layout            [_s_] search
  [_l_] location        [_<down>_] next-location        [_ac_] add-circle        [_h_] search-history
  [_t_] torus                                         [_al_] add-location      [_m_] meta-history
                      [_<left>_]  prev-circle         [_at_] add-torus
                      [_<right>_] next-circle
                                                    [_dc_] delete-circle
                                                    [_dl_] delete-location
                      [_<prior>_] newer-history       [_dt_] delete-torus
                      [_<next>_]  older-history
   ^ ^
-------------------------------------------------------------------------------------------------------
    "

  ("#" torus-layout-menu :color blue)

  ("c" torus-switch-circle :color blue)
  ("l" torus-switch-location :color blue)
  ("t" torus-switch-torus :color blue)

  ("ac" torus-add-circle :color blue)
  ("al" torus-add-location :color blue)
  ("at" torus-add-torus :color blue)

  ("dl" torus-delete-location :color blue)
  ("dc" torus-delete-circle :color blue)
  ("dt" torus-delete-torus :color blue)

  ("<up>"   torus-previous-location)
  ("<down>" torus-next-location)
  ("<left>" torus-previous-circle)
  ("<right>" torus-next-circle)


  ("s" torus-search :color blue)
  ("h" torus-search-history :color blue)
  ("m" torus-search-meta-history :color blue)

  ("<prior>" torus-history-newer)
  ("<next>" torus-history-older)

  )

   #+END_SRC

   #+results:
   : hydra-torus/body

**** bookmarks
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-bookmarks (
                           :color red
                           :hint nil
                           :inherit (hydra-common/heads)
                           :pre (progn
                                  (exwm-input-line-mode))
                           :post (progn
                                   (exwm-input-char-mode)))

  "
                                                                   ╭───────────┐
       List                          Do                            │ Bookmarks │
╭──────────────────────────────────────────────────────────────────┴───────────╯
  [_l_] list bookmarks            [_j_] jump to a bookmark
   ^ ^                            [_m_] set bookmark at point
   ^ ^                            [_s_] save bookmarks
--------------------------------------------------------------------------------
    "
  ("l" counsel-bookmark)
  ("j" bookmark-jump)
  ("m" bookmark-set)
  ("s" bookmark-save))
   #+END_SRC

**** applications
   #+BEGIN_SRC emacs-lisp
  (defhydra hydra-applications (:exit t :columns 4)
    "Applications"
    ("p" counsel-list-processes "Show Processes")
    ("r" elfeed "RSS Feeds"))

  (defhydra hydra-elfeed-search-mode (:exit t :columns 4)
    "Elfeed"
    ("f" elfeed-search-fetch "Fetch feed")
    ("u" elfeed-search-update "Update feed")
    ("o" elfeed-search-show-entry "Show entry"))


   #+END_SRC
**** window
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-window (
                        :color red
                        :hint  nil
                        :inherit (hydra-common/heads)
                        :pre (progn
                               (exwm-input-line-mode))
                        :post (progn
                                (exwm-input-char-mode))
                        )
  "
                                                                     ╭──────────┐
  Window         Switch           View                               │  Window  │
╭────────────────────────────────────────────────────────────────────┴──────────╯
     ↑          [_b_] ibuffer     [_s_] save
     _i_          [_p_] projectile  [_d_] delete
 ← _k_   _l_ →      [_e_] exwm        [_v_] view
     _o_
     ↓

   ^ ^
--------------------------------------------------------------------------------
    "
  ("i" windmove-up)
  ("o" windmove-down)
  ("k" windmove-left)
  ("l" windmove-right)

  ("I" buf-move-up)
  ("O" buf-move-down)
  ("K" buf-move-left)
  ("L" buf-move-right)

  ("b" ibuffer)
  ("p" counsel-projectile-switch-to-buffer)
  ("e" my-counsel-ibuffer-by-exwm-class-name)

                                        ;  ("s" exwm-workspace-switch)
                                        ;  ("m" exwm-workspace-move-window)

  ("s"  ivy-push-view)
  ("d"  ivy-pop-view)
  ("v"  ivy-switch-view)

  ("0" delete-window)
  ("1" delete-other-windows)
  ("2" split-window-below)
  ("3" split-window-right)
  ("4" split-window-up)
  ("5" split-window-left)

  (";" ace-swap-window "swap")
  ("@" hycontrol-windows-grid)




  )
   #+END_SRC

**** org-refiler
   #+BEGIN_SRC emacs-lisp
(defvar org-default-projects-dir   "~/org/projects/"                     "Primary GTD directory")
(defvar org-default-zettelkasten-dir "~/org/notes/"                     "Directory of notes modeled after Zettelkasten includes an Archive, and Notes")
(defvar org-default-completed-dir  "~/org/projects/completed"            "Directory of completed project files")
(defvar org-default-inbox-file     "~/org/agenda/inbox.org"         "New stuff collects in this file")
(defvar org-default-tasks-file     "~/org/agenda/tasks.org"           "Tasks, TODOs and little projects")
(defvar org-default-incubate-file  "~/org/agenda/incubate.org"        "Ideas simmering on back burner")
(defvar org-default-calendar-file  "~/org/agenda/calendar.org"        "Ideas simmering on back burner")
(defvar org-default-delegate-file  "~/org/agenda/delegate.org"        "Ideas simmering on back burner")
(defvar org-default-waiting-file  "~/org/agenda/waiting.org"        "Ideas simmering on back burner")
(defvar org-default-completed-file nil                              "Ideas simmering on back burner")
(defvar org-default-notes-file     "~/org/agenda/inbox.org"   "Non-actionable, personal notes")

(defhydra hydra-org-refiler (org-mode-map "C-c s" :hint nil)
  "
   ^Refile^       ^Calendar^            ^Ref^           ^Move^         ^Update^           ^Go To^
   ^^^^^^^^^^------------------------------------------------------------------------------------------
   _t_: tasks      _c c_: calendar  _z d_: web      _m p_: projects   _T_: todo       _g t_: tasks
   _i_: incubate   _c t_: tickler   _z w_: docs     _m n_: notes      _S_: schedule   _g i_: incubate
   _w_: waiting    _c d_: delegate  _z i_: images                   _D_: deadline   _g x_: inbox
   _r_: refile                                                  _R_: rename     _g w_: waiting
                                                                            _g p_: projects
                                                                            _g c_: completed
   "
  ("<up>" org-previous-visible-heading)
  ("<down>" org-next-visible-heading)
  ("k" org-previous-visible-heading)
  ("j" org-next-visible-heading)

  ("t" org-refile-to-task)
  ("i" org-refile-to-incubate)
  ("r"  org-refile)
  ("w" org-refile-to-waiting)
  ("c c" refile-to-calendar)
  ("c t" refile-to-tickler)
  ("c d" org-refile-to-delegate)

  ("z d" note-to-documents)
  ("z w" note-to-websites)
  ("z i" note-to-images)

  ("m p" org-refile-to-projects-dir)
  ("m n" org-refile-to-zettelkasten-dir)
  ("T" org-todo)
  ("S" org-schedule)
  ("D" org-deadline)
  ("R" org-rename-header)
  ("g t" (find-file org-default-tasks-file))
  ("g i" (find-file org-default-incubate-file))
  ("g w" (find-file org-default-waiting-file))
  ("g x" (find-file org-default-inbox-file))
  ("g c" (find-file org-default-completed-file))
  ("g p" (dired org-default-projects-dir))
  ("g c" (dired org-default-completed-dir))
  ("[\t]" (org-cycle))

  ("s" (org-save-all-org-buffers) "save")

  ("a" org-archive-subtree-as-completed "archive")
  ("d" org-cut-subtree "delete")
  ("q" (my/switch-to-last-buffer) "quit" :color blue))

   #+END_SRC

   #+results:
   : hydra-org-refiler/body
**** major-modes
***** org
   #+BEGIN_SRC emacs-lisp :results silent
(defhydra hydra-org (:exit t :columns 4
                           :inherit (hydra-common/heads))

  "Org mode"
  ("u" org-up-element "Up element")
  ("d" org-down-element "Down element")
  ("b" org-next-block "Next block")
  ("e" org-export-dispatch "Export")
  ("t" org-todo "Toggle todo states")
  ("T" org-babel-tangle "Tangle code")
  ("c" org-babel-execute-src-block "Run block")
  ("," outline-show-children "Show node children")
  ("." org-tree-to-indirect-buffer "Edit in buffer")
  ("'" org-edit-special "Code buffer"))
   #+END_SRC
***** python
   #+BEGIN_SRC emacs-lisp :results silent
(with-no-warnings
  (defhydra hydra-python (:exit t :columns 4
                                :inherit (hydra-common/heads))
    "Python"
    ("#" poporg-dwim "Edit Comment")
    ("," dumb-jump-back "Jump back")
    ("." dumb-jump-go "Jump to definition")
    ("D" hydra-python-django/body "Django")
    ("L" flycheck-prev-error "Prev lint error")
    ("T" pythonic-tests-all "Run pythonic test")
    ("a" pytest-all "Run all tests")
    ("b" python-shell-send-buffer "Send buffer to python")
    ("u" em-python-pur "Upgrade pip requirements")
    ;;("r" python-shell-send-buffer "Send line/region to python")
    ("r" run-python "REPL")
                                        ;    ("d" helm-dash-at-point "Docs")
    ("c" em-python-execute "Compile / Execute")
    ("i" dumb-jump-quick-look "Definition Info")
    ("l" flycheck-next-error "Next lint error")
    ("t" pythonic-tests-run "Run current test")
    ("V" flycheck-verify-setup "Verify linting")
    ("v" em-python-environment "Check environment")
    ("s" isortify-buffer "Sort imports")
    ;;("n" flyceck "Run all tests")
    ("f" blacken-buffer "Format buffer code")))
   #+END_SRC
***** lisp
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-lisp (:exit t :columns 4
                            :inherit (hydra-common/heads))
  "Lisp"
  ("r" ielm "Interactive REPL")
  ("." dumb-jump-go "Jump definition")
  ("v" flycheck-verify-setup "Verify linting")
  ("f" elisp-format-buffer "Format buffer")
  ("d" checkdoc "Lint doc strings")
  ("l" package-lint-current-buffer "Lint code")
  ("c" emacs-lisp-byte-compile-and-load "Lisp execute"))
   #+END_SRC
***** javascript
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-javascript (:exit t :columns 4
                                  :inherit (hydra-common/heads))
  "Javascript"
  ("," dumb-jump-back "Jump back")
  ("." dumb-jump-go "Jump to definition")
  ("l" flycheck-next-error "Next lint error")
  ("i" npm-mode-npm-init "Initialize NPM")
  ("f" prettier-js "Format code")
  ("v" flycheck-verify-setup "Verify linting"))
   #+END_SRC
***** rjsx
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-rjsx (:exit t :columns 4
                            :inherit (hydra-common/heads))
  "Javascript"
  ("," dumb-jump-back "Jump back")
  ("." dumb-jump-go "Jump to definition")
  ("l" flycheck-next-error "Next lint error")
  ("i" npm-mode-npm-init "Initialize NPM")
  ("f" prettier-js "Format code")
  ("r" indium-connect "REPL")
  ("h" html-to-react "HTML to react")
  ("v" flycheck-verify-setup "Verify linting"))

   #+END_SRC

***** css
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-css (:exit t :columns 4
                           :inherit (hydra-common/heads))
  "CSS"
  ("," dumb-jump-back "Jump back")
  ("." dumb-jump-go "Jump to definition")
  ("f" web-beautify-css "Format css"))
   #+END_SRC
***** scss
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-scss (:exit t :columns 4
                            :inherit (hydra-common/heads))
  "SCSS"
  ("," dumb-jump-back "Jump back")
  ("." dumb-jump-go "Jump to definition")
  ("f" web-beautify-css "Format css"))
   #+END_SRC
***** web
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-web (:exit t :columns 4
                           :inherit (hydra-common/heads))
  "Web"
  ("f" web-beautify-html "Format buffer")
  ("o" browser-url-of-buffer "Open in browser"))
   #+END_SRC
***** html
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-html (:exit t :columns 4
                            :inherit (hydra-common/heads))
  "Html"
  ("f" web-beautify-html "Format buffer")
  ("o" browser-url-of-buffer "Open in browser"))
   #+END_SRC

***** c
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-c (:exit t :columns 4
                         :inherit (hydra-common/heads))
  "C"
  ("." dumb-jump-go "Jump to definition")
  ("," dumb-jump-back "Jump back")
  ("i" dumb-jump-quick-look "Definition Info")
  ("f" clang-format-buffer "Format buffer"))
   #+END_SRC
***** json
   #+BEGIN_SRC emacs-lisp
(with-no-warnings
  (defhydra hydra-json (:exit t :columns 4
                              :inherit (hydra-common/heads))
    "CSV"
    (";" yafolding-toggle-all "Fold")
    ("f" csv-align-fields "Format visually")))
   #+END_SRC
***** exwm
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-exwm (:exit t
                            :columns 4
                            :color blue
                            :inherit (hydra-common/heads)
                            :pre (progn
                                   (exwm-input-line-mode))
                            :post (progn
                                    (exwm-input-char-mode)))


  "EXWM"
  ("s"  #'exwm-input-send-next-key "send key")
  ("f"  #'exwm-layout-set-fullscreen "fullscreen")
  ("t"  #'exwm-floating-toggle-floating "toggle floating")
  ("m"  #'exwm-workspace-move-window "move window")

  )
   #+END_SRC
**** minor-modes
   #+BEGIN_SRC emacs-lisp
(defhydra hydra-minor (:exit t :columns 4)
  "Minor modes"
  ("r" spray-mode "Speed read")
  ("n" em/narrow-or-widen-dwim "Narrow / Widen")
  ("i" iedit-mode "Iedit mode"))
   #+END_SRC
** Modal Editing
*** boon
**** setup
  #+BEGIN_SRC emacs-lisp
(use-package boon
  :config
  (require 'boon-qwerty)
  (boon-mode +1))

  #+END_SRC
**** boon-major-mode
  #+BEGIN_SRC emacs-lisp
(defvar-local boon-objed-state nil "Non-nil when boon objed mode is activated.")

(defun boon-select-major-mode (boon-mode-map)
  (let ((boon-mode-command (cdr (assoc major-mode boon-mode-map))))
    (if boon-mode-command (apply boon-mode-command))))

(defun boon-mode-hydra ()
  (interactive)
  (boon-select-major-mode boon-major-mode-hydra-list))

(setq boon-key-list '
      ((org-mode . (message "%s" "command from org mode"))
       (lisp-mode . (message "%s" "command from lisp mode"))
       (python-mode . (message "%s" "command from python mode"))))

(setq boon-major-mode-hydra-list '
      ((org-mode . (hydra-org/body))
       (emacs-lisp-mode . (hydra-lisp/body))
       (clojure-mode . (hydra-clojure/body))
       (clojurescript-mode . (hydra-clojurescript/body))
       (js2-mode . (hydra-javascript/body))
       (rjsx-mode . (hydra-rjsx/body))
       (json-mode . (hydra-json/body))
       (sql-mode . (hydra-sql/body))
       (css-mode . (hydra-css/body))
       (scss-mode . (hydra-scss/body))
       (javascript-mode . (hydra-javascript/body))
       (yaml-mode . (hydra-yaml/body))
       (php-mode . (hydra-php/body))
       (c++-mode . (hydra-c/body))
       (arduino-mode . (hydra-arduino/body))
       (web-mode . (hydra-web/body))
       (html-mode . (hydra-html/body))
       (mhtml-mode . (hydra-html/body))
       (exwm-mode . (hydra-exwm/body))
       (python-mode . (hydra-python/body))))

(custom-set-variables
 '(boon-special-mode-list
   (quote
    (
     ediff-mode
     magit-mode
     magit-popup-mode
     debugger-mode
     ediff-mode
     git-rebase-mode
     mu4e-headers-mode
     mu4e-view-mode
     help-mode
     org-agenda-mode
     emms-playlist-mode
     pdf-tools-modes
     ,*dashboard*
     ))))

  #+END_SRC
**** boon-objed
  #+BEGIN_SRC emacs-lisp
(defun boon-reset-all-mode-states ()
  (interactive)
  (mapcar (lambda (boon-mode)
            (setq boon-mode nil)) boon-mode-map-alist))

(defun boon-set-objed-state ()
  "Switch to objed state."
  (interactive)
  (boon-set-state 'boon-objed-state))

(defun boon-objed (&optional changes)
  "Switch to insert state.
When CHANGES are non-nil, replay those instead."
  (interactive)
  (boon-interactive-objed)
  (if changes ;; replay changes if we have them, otherwise switch to insert state normally
      (progn
        (mc/execute-command-for-all-fake-cursors (lambda () (interactive) (boon/replay-changes changes)))
        (boon/replay-changes changes))
    (boon-set-objed-state)
    (setq cursor-type 'bar)
    (objed-mode +1)
    (objed-activate)
    (message "Objed mode enabled")
    ))

(defun my/boon-set-command-state ()
  "Switch to command state."
  (interactive)
  (objed-mode -1)
  (boon-set-state 'boon-command-state)
  (message "Objed mode disabled")
  )

(defun boon-set-objed-like-state (&optional changes)
  "Switch to special or insert state, depending on mode.
When CHANGES are non-nil, replay those instead."
  (interactive)
  (setq boon-objed-state nil)
  (boon-interactive-objed)
  (if (boon-special-mode-p)
      (boon-set-special-state)
    (boon-objed changes)))

(defvar boon/objed-command-history nil "History of changes in this insertion round.")
(defvar boon/objed-command nil "History of changes in this insertion round.")

(defun boon-interactive-objed (&rest args)
  "Boon insert commands must call this function after `interactive'.
The effect of this function is to remember the current command
and ARGS so that it can be repeated later by
`boon-set-insert-like-state'.  The current command must take an
optional list of changes as its last argument."
  (unless boon/objed-command
    (setq boon/objed-command (cons this-command (-map (lambda (x) (list 'quote x)) args)))))

(defun boon-set-state (state)
  "Set the boon state (as STATE) for this buffer."
  (setq boon-command-state nil)
  (setq boon-insert-state nil)
  (setq boon-special-state nil)
  (setq boon-objed-state nil)
  (set state t)
  (cond (boon-command-state
         (when (and boon/insert-command boon/insert-command-history)
           (push `(,@boon/insert-command
                   (quote ,@(list (nreverse boon/insert-command-history))))
                 command-history))
         (setq boon/insert-command nil)
         (setq boon/insert-command-history nil)
         (setq cursor-type boon-command-cursor-type))

        (boon-objed-state
         (when (and boon/objed-command boon/objed-command-history)
           (push `(,@boon/insert-command
                   (quote ,@(list (nreverse boon/objed-command-history))))
                 command-history))
         (setq boon/objed-command nil)
         (setq boon/iobjed-command-history nil)
         (setq cursor-type boon-command-cursor-type))
        (boon-special-state)

        (boon-insert-state
         (deactivate-mark)
         (save-excursion
           (when (not (bolp))
             (let ((orig (point)))
               (skip-chars-forward " " (line-end-position))
               (when (eolp) (delete-region orig (point))))))
         (setq cursor-type boon-insert-cursor-type)
         (push-mark) ;; remember where the last edition was by pushing a mark
         (setq boon/insert-command-history nil)
         (setq boon/insert-origin (point)))

        (boon-off-state)
        (t (error "Boon: Unknown state!")))
  (force-mode-line-update))



  #+END_SRC
**** keybindings
  #+BEGIN_SRC emacs-lisp
(define-key boon-command-map (kbd "SPC") 'counsel-M-x)
(define-key boon-command-map (kbd "<return>") 'counsel-linux-app)
(define-key global-map [escape] 'my/boon-set-command-state)

(define-key boon-command-map (kbd "q")  'hydra-master/body)

(define-key boon-command-map (kbd "m")  'boon-mode-hydra)
(define-key boon-command-map (kbd "M")  'hydra-minor/body)

(define-key boon-command-map (kbd "=")  'boon-set-objed-like-state)

(define-key boon-command-map (kbd "/")  'hui-search-web)
(define-key boon-command-map (kbd "b")  'ivy-switch-buffer)

(define-key boon-command-map (kbd "g")  'magit-status)

(define-key boon-command-map (kbd "A")  'hydra-agenda/body)

(define-key boon-command-map (kbd "A")  'hydra-agenda/body)

(define-key boon-command-map (kbd "W")  'hydra-window/body)
(define-key boon-command-map (kbd "J")  'hydra-jump/body)
(define-key boon-command-map (kbd "t")  'hydra-torus/body)
(define-key boon-command-map (kbd "S")  'hydra-select/body)
(define-key boon-command-map (kbd "C")  'hydra-copy/body)
(define-key boon-command-map (kbd "Y")  'hydra-paste/body)
(define-key boon-command-map (kbd "K")  'hydra-delete/body)
(define-key boon-command-map (kbd "E")  'hydra-emacs/body)
(define-key boon-command-map (kbd "N")  'hydra-narrow/body)
                                        ;(define-key boon-command-map (kbd "R")  'hydra-register/body)
(define-key boon-command-map (kbd "G")  'hydra-git/body)
(define-key boon-command-map (kbd "H")  'hydra-help/body)
(define-key boon-command-map (kbd "F")  'hydra-file/body)

(define-key boon-command-map (kbd "T")  'torus-search)

(define-key boon-command-map (kbd "s-h")  'ivy-resume)

(define-key boon-command-map (kbd "q")  'counsel-org-capture)

  #+END_SRC
*** objed
  #+BEGIN_SRC emacs-lisp
(use-package objed
  :commands objed-mode
  :config
                                        ;(define-key objed-user-map "f" nil)
  (define-key objed-user-map "d" 'xref-find-definitions)
  (define-key objed-user-map "r" 'xref-find-references)

  (define-key objed-op-map "j" 'counsel-imenu)
  (define-key objed-op-map "f" 'counsel-find-file)
  (define-key objed-op-map "b" 'ivy-switch-buffer))

  #+END_SRC
** Information Management
*** Hyperbole
  #+BEGIN_SRC emacs-lisp
(use-package hyperbole
  :defer 0.1
  :config
  (add-to-list 'hyperbole-web-search-alist '("DuckDuckGo" . "https://duckduckgo.com/?q=%s")))
  #+END_SRC

*** howm
***** functions
    #+BEGIN_SRC emacs-lisp
(defvar howm-view-title-header "#+TITLE:")

(defvar howm-view-header-format
  "\n\n#+INCLUDE: %s\n")

(setq howm-template-rules
      '(("%title" . howm-template-title)
        ("%date" . howm-template-date)
        ("%file" . howm-template-previous-file)
        ("%parent" . howm-template-parent)
        ("%fname" . howm-template-filename)
        ("%cursor" . howm-template-cursor)))

(defun howm-template-title (arg)
  (insert (cdr (assoc 'title arg))))

(defun howm-template-filename (arg)
  (insert (concat ">>>" (file-name-base buffer-file-name))))

(defun howm-template-parent (arg)
  (insert (cdr (assoc 'parent arg))))

(defun howm-template-date (arg)
  (insert (cdr (assoc 'date arg))))

(defun howm-template-previous-file (arg)
  (insert (cdr (assoc 'file arg))))

(defun howm-template-cursor (arg))

(setq howm-file-name-format "%Y-%m-%dT%H.%M.%S.org")
(setq howm-template-date-format "#+DATE: [%Y-%m-%d %H:%M]")
(setq howm-directory "~/org/notes/")
(setq howm-view-preview-narrow nil)

(add-hook 'org-mode-hook 'howm-mode)
(add-to-list 'auto-mode-alist '("\\.howm$" . org-mode))



(setq howm-view-split-horizontally t)
(setq howm-view-keep-one-window t)

(setq howm-menu-refresh-after-save nil)
(setq howm-menu-expiry-hours 6)  ;; cache menu N hours
(setq howm-menu-file "0000-00-00-000000.txt")  ;; don't *search*

(setq howm-view-use-grep t)
(setq howm-view-grep-command "rg")
(setq howm-view-grep-option "-nH --no-heading --color never")
(setq howm-view-grep-extended-option nil)
(setq howm-view-grep-fixed-option "-F")
(setq howm-view-grep-expr-option nil)
(setq howm-view-grep-file-stdin-option nil)

;; howm-menu
(defun howm-menu-with-j1 (orig-fun &rest args)
  (setq howm-view-grep-option "-nH --no-heading -j1 --color never")
  (apply orig-fun args)
  (setq howm-view-grep-option "-nH --no-heading --color never"))

(advice-add 'howm-menu-refresh :around #'howm-menu-with-j1)

(setq howm-view-search-in-result-correctly t)

(setq howm-view-list-title-type 2)
(setq howm-view-summary-format "")

(defun howm-search-title (title)
  (interactive "sSearch title: ")
  (message title)
  (howm-search (format "^* +%s" (regexp-quote title)) nil))

(defun howm-list-grep-in-new-frame (&optional completion-p)
  (interactive "P")
  (select-frame (make-frame))
  (howm-list-grep completion-p))

(defvar *howm-new-frame* nil)

(defun howm-new-frame ()
  (when *howm-new-frame*
    (select-frame (make-frame))))
(add-hook 'howm-view-before-open-hook 'howm-new-frame)

(defun howm-open-new-frame (opener)
  ;; move cursor back from contents to summary in the original frame
  (let (new-frame)
    (save-window-excursion
      (let ((*howm-new-frame* t))
        (funcall opener))
      (setq new-frame (selected-frame)))
    (select-frame new-frame)))

(defun howm-open-new-frame-summary ()
  (interactive)
  (howm-open-new-frame #'howm-view-summary-open-sub))

(defun howm-open-new-frame-contents ()
  (interactive)
  (howm-open-new-frame #'howm-view-contents-open-sub))


(defun howm-create-and-link (&optional which-template)
  (interactive "p")
  (let ((b (current-buffer))
        (p (point)))
    (prog1
        (howm-create which-template)
      (let ((f (buffer-file-name)))
        (when (and f (buffer-file-name b))
          (with-current-buffer b
            (goto-char p)
            (insert (format howm-template-file-format
                            (abbreviate-file-name f))
                    "\n")))))))

(defun howm-open-from-calendar ()
  (interactive)
  (require 'howm-mode)
  (let* ((mdy (calendar-cursor-to-date t))
         (m (car mdy))
         (d (second mdy))
         (y (third mdy))
         (ti (encode-time 0 0 0 d m y))
         (pc (howm-folder-get-page-create howm-directory (howm-file-name ti)))
         (page (car pc))
         (createp (cdr pc)))
    (other-window 1)
    (howm-page-open page)
    (if createp
        (howm-create-here)
      (howm-set-mode))))
(require 'calendar)


(defun my-howm-switch-to-summary ()
  (interactive)
  (switch-to-buffer "*howmS*")
  (riffle-summary-check t))

(add-hook 'howm-view-contents-mode-hook
          (lambda ()
            (setq default-directory howm-directory)
            (howm-mode 1)))
(defadvice riffle-contents-show (around howm-mode (item-list) activate)
  ad-do-it
  (when howm-mode
    (howm-initialize-buffer)))


(defun howm-export-to-org ()
  "Remove formatting and export to plain text
  when in howmC view"
  (interactive)
  (copy-whole-buffer-to-clipboard)
  (find-file   (concat "~/notes_export_" (format-time-string "%m-%d-%H%M%S") ".org"))
  (yank)
  (goto-char(point-min))
  (replace-string  "#+TITLE: "  "* ")
  (goto-char(point-min))
  (replace-string "#+DATE: " "")
  (goto-char(point-min))
  (replace-string "#+KEYWORDS: " "")
  (goto-char(point-min))
  (replace-regexp "^==========================>>> .*$" ""))


(defun howm-insert-filename ()
  (interactive)
  (insert (concat ">>>" (file-name-base buffer-file-name))))


(defun howm-create (&optional which-template here)
  (interactive "p")
  (let* ((t-c (howm-create-default-title-content))
         (title (car t-c))
         (content (cdr t-c)))
    (howm-create-file-with-title title which-template nil here content)
    (org-cycle '(16))
    ))


(defun my/howm-view-summary-open ()
  (interactive)
  (howm-view-summary-open)
  (delete-other-windows))

(defun my/howm-view-summary-open ()
  (interactive)
  (howm-view-summary-open)
  (org-cycle '(16)))

(defun howm-org-include-file ()
  (interactive)
  (save-excursion
    (setq current-buffer buffer-file-name)
    (switch-to-buffer "*scratch*")
    (insert "\n\n")
    (insert "#+INCLUDE: \"" current-buffer "\" :only-contents t :lines \"10-\"\n\n")))


    #+END_SRC
***** package
     #+BEGIN_SRC emacs-lisp
(use-package howm
  :init
  (setq howm-template
":HIDDEN:
,#+PARENTS:
,#+CHILDREN:
,#+FRIENDS:

:RELATED:
%file
%title

:RESOURCES:

:END:
,#+TITLE: %cursor
%fname
%date
,#+CATEGORY:
,#+KEYWORDS:

  ")

  :config
  (define-key howm-view-summary-mode-map (kbd "M-C-m") 'howm-open-new-frame-summary)
  (define-key howm-view-summary-mode-map [tab] 'my/howm-view-summary-open))


     #+END_SRC
** Media
*** emms
  #+BEGIN_SRC emacs-lisp
(use-package emms
  :commands emms
  :config
  (require 'emms)
  (emms-all)
  (emms-default-players)
  (setq emms-playlist-buffer-name "*Music*")
  (setq emms-info-asynchronously t)
  (setq emms-info-functions '(emms-info-libtag))
  (emms-mode-line 0)
  (emms-playing-time 1))

  #+END_SRC
*** circe
  #+BEGIN_SRC emacs-lisp
(use-package circe
  :defer t
  :config
  (setf (cdr tracking-mode-map) nil)
  (defun my/rename-irc-channel-buffer ()
    (rename-buffer (concat (buffer-name) "@" (with-circe-server-buffer circe-network))))
  (add-hook 'circe-channel-mode-hook 'my/rename-irc-channel-buffer)
  (defun my/highlight-channel ()
    (interactive)
    (setq-local my/buffer-notify t))
  (add-hook 'tracking-buffer-added-hook 'my/highlight-channel)
  (defun my/de-highlight-channel ()
    (interactive)
    (setq-local my/buffer-notify nil))
  (add-hook 'tracking-buffer-removed-hook 'my/de-highlight-channel)
  (enable-circe-color-nicks)
  (setq lui-fill-column 100000
        lui-time-stamp-position 'left
        circe-lagmon-timer-tick 120
        circe-reduce-lurker-spam t
        circe-server-buffer-name "{network}"
        circe-default-nick "Dynamicmetaflow"
        circe-default-user "Dynamicmetaflow"
        circe-default-realname "Dynamicmetaflow"
        ))
  #+END_SRC
*** pdf-tools
  #+BEGIN_SRC emacs-lisp
(use-package pdf-tools :ensure t
  :defer 0.1
  :config
  (unless noninteractive
    (pdf-tools-install))
  (setq-default pdf-view-display-size 'fit-page))
  #+END_SRC

** Buffers
*** torus
  #+BEGIN_SRC emacs-lisp
(use-package torus
  :defer 0.1
  :bind-keymap ("C-x t" . torus-map)
  :bind (
         :map torus-map
         ("t" . torus-copy-to-circle))
  :hook ((emacs-startup . torus-start)
         (kill-emacs . torus-quit))
  :custom (
           (torus-binding-level 1)
           (torus-verbosity 1)
           (torus-dirname (concat user-emacs-directory (file-name-as-directory "torus")))
           (torus-load-on-startup t)
           (torus-save-on-exit t)
           (torus-autoread-file (concat torus-dirname "last.el"))
           (torus-autowrite-file torus-autoread-file)
           (torus-backup-number 5)
           (torus-history-maximum-elements 30)
           (torus-maximum-horizontal-split 3)
           (torus-maximum-vertical-split 4)
           (torus-display-tab-bar t)
           (torus-separator-torus-circle " >> ")
           (torus-separator-circle-location " > ")
           (torus-prefix-separator "/")
           (torus-join-separator " & "))
  :config
  (torus-init)
  (torus-install-default-bindings)
  (defun torus-read (filename)
    "Read main torus variables from FILENAME as Lisp code."
    (interactive
     (list
      (read-file-name
       "Torus file : "
       (file-name-as-directory torus-dirname))))
    (let*
        ((file-basename (file-name-nondirectory filename))
         (minus-len-ext (- (min (length torus-extension)
                                (length filename))))
         (buffer))
      (unless (equal (cl-subseq filename minus-len-ext) torus-extension)
        (setq filename (concat filename torus-extension)))
      (when (torus--update-input-history file-basename)
        (if (file-exists-p filename)
            (progn
              (setq buffer (find-file-noselect filename))
              (eval-buffer buffer)
              (kill-buffer buffer))
          (message "File %s does not exist." filename))))
    ;; Also saved in file
                                        ;(torus--update-meta)
                                        ;(torus--build-index)
                                        ;(torus--build-meta-index)
    (torus--jump))
  (setq torus-prefix-key (kbd "C-x t"))

  )

  #+END_SRC

** Utilities
*** kdeconnect
  #+BEGIN_SRC emacs-lisp
(use-package kdeconnect
  :defer t)
  #+END_SRC
*** [[https://github.com/redguardtoo/elpa-mirror][elpa-mirror: Create local emacs package repository]]
 #+BEGIN_SRC emacs-lisp
(use-package elpa-mirror)
 #+END_SRC

 - Use `elpa-mirror` to create local repository which contains all packages you are already using

 - Push the repository to github. Tag the repository and emacs setup with same version number (`1.1`, `1.2`...)

 - Done

 So you could always roll back to last stable version because of full control of the setup and packages

* Helpers
** defun
 #+BEGIN_SRC emacs-lisp
(defun get-envvar-name (envvar)
  "Return environment variable name for ENVVAR.
Code from `read-envvar-name'."
  (let ((str (substring envvar 0
                        (string-match "=" envvar))))
    (if (multibyte-string-p str)
        (decode-coding-string
         str locale-coding-system t)
      str)))

(defun create-safe-env-p (&rest keys)
  "Return predicate function that's non-NIL when it's argument KEY is in KEYS."
  (lambda (envlist)
    (-all-p (lambda (key)
              (-any-p (lambda (k)
                        (string= (get-envvar-name key) k)) keys)) envlist)))


(defun ivy-ignore-exwm-buffers (str)
  (let ((buf (get-buffer str)))
    (when buf
      (with-current-buffer buf
        (or
         (file-remote-p (or (buffer-file-name) default-directory))
         (eq major-mode 'exwm-mode))))))

(defun ivy-ignore-non-exwm-buffers (str)
  (let ((buf (get-buffer str)))
    (if buf
        (with-current-buffer buf
          (or
           (file-remote-p (or (buffer-file-name) default-directory))
           (not (eq major-mode 'exwm-mode))))
      t)))

(defun ivy-switch-buffer-exwm ()
  "Like ivy-switch-buffer but only shows EXWM buffers."
  (interactive)
  (let ((ivy-ignore-buffers (append ivy-ignore-buffers '(ivy-ignore-non-exwm-buffers))))
    (ivy-switch-buffer)))

(defun ivy-switch-buffer-non-exwm ()
  "Like ivy-switch-buffer but hides all EXWM buffers."
  (interactive)
  (let ((ivy-ignore-buffers (append ivy-ignore-buffers '(ivy-ignore-exwm-buffers))))
    (ivy-switch-buffer)))



(defun my/read-file (path)
  "Read the first s-expression in the file at PATH."
  (with-temp-buffer
    (insert-file-contents path)
    (read (current-buffer))))


(defun goto-button (heading loc)
  (widen)
  (goto-char(point-min))
  (search-forward-regexp heading)
  (org-narrow-to-subtree)
  (search-forward-regexp loc)
  (recenter-top-bottom))

(defun my/avy-goto-jump (char &optional arg)
  "Jump to the currently visible CHAR.
  The window scope is determined by `avy-all-windows' (ARG negates it)."
  (interactive (list (read-char "char: " t)
                     current-prefix-arg))
  (avy-with avy-goto-char
    (avy-jump
     (if (= 13 char)
         "\n"
       (regexp-quote (string char)))
     :window-flip arg))
  (hkey-either arg))

(defun my/exwm-counsel-yank-pop ()
  "Same as `counsel-yank-pop' and paste into exwm buffer."
  (interactive)
  (let ((inhibit-read-only t)
        (yank-pop-change-selection t))
    (call-interactively #'counsel-yank-pop))
  (when (derived-mode-p 'exwm-mode)
    (exwm-input--set-focus (exwm--buffer->id (window-buffer (selected-window))))
    (exwm-input--fake-key ?\C-v)))


(defun my/insert-mode ()
  (interactive)
  (boon-mode -1)
  (key-chord-mode -1)
  (setq cursor-type 'bar)
  (objed-mode +1)
  (objed-activate))

(defun em-comment ()
  (interactive)
  (objed-comment-or-uncomment-region))

(defun em-push-store-point ()
  (interactive)
  (if (not (boundp 'em-store-point-targets))
      (setq em-store-point-targets ()))
  (push (point) em-store-point-targets))

(defun em-pop ()
  (interactive)
  (goto-char (pop em-store-point-targets))
  (yank))

(defun em-pop-paste ()
  (interactive)
  (copy-region-as-kill (region-beginning) (region-end))
  (goto-char (pop em-store-point-targets))
  (yank))


(defun std::pacman-pkg-info ()
  (interactive)
  (let* ((completions (->> "pacman -Q"
                           (shell-command-to-string)
                           (s-trim)
                           (s-lines)
                           (--map (car (s-split " " it :no-nulls)))))
         (name (completing-read "Package: " completions)))
    (switch-to-buffer (get-buffer-create "*Package Info*"))
    (erase-buffer)
    (-> (format "pacman -Qi %s" name)
        (shell-command-to-string)
        (s-trim)
        (insert))
    (goto-char 0)
    (conf-mode)))

 #+END_SRC

 #+results:
 : std::pacman-pkg-info



  :RELATED:
  :END:

  :RESOURCES:
  :END:
** variables
 #+BEGIN_SRC emacs-lisp
(exwm-input-set-key (kbd "M-y") #'my/exwm-counsel-yank-pop)

(setq emms-source-file-default-directory "/home/alexander/org/data/c0/80320c-060b-4348-a413-ee7d8ed40dd6/")

;; (setq org-use-speed-commands
;;           (lambda () (or (eq (point) 1)
;;                          (looking-at org-outline-regexp-bol))))




(setq delete-by-moving-to-trash t)

(setq desktop-environment-screenshot-partial-command "scrot -s screenshot.png")
(setq desktop-environment-screenshot-directory "~/Pictures")


(setq imenu-max-items 100)
(setq org-imenu-depth 9)

(defalias 'insert-string 'insert)

(setq lpr-command "gtklp")

(setq org-expiry-created-property-name "CREATED")

(setq org-return-follows-link t)

(setq org-attach-directory "~/org/notes/data/")

(setq org-show-context-detail
      '((agenda . lineage) ;; instead of "local"
        (bookmark-jump . lineage)
        (isearch . lineage)
        (default . ancestors))
      )

(setq org-catch-invisible-edits "smart")

(defvar my-cpp-other-file-alist
  '(("\\.org\\'" (".org_archive"))
    ))
(setq-default ff-other-file-alist 'my-cpp-other-file-alist)

(setq org-agenda-inhibit-startup t) ;; ~50x speedup

(setq org-agenda-use-tag-inheritance nil) ;; 3-4x speedup

(setq load-dirs (concat user-emacs-directory "extra/"))

(setq grep-command "rg")

 #+END_SRC
** appointments and notifications
 #+BEGIN_SRC emacs-lisp
(setq appt-display-diary nil)
(appt-activate t)
(setq appt-display-interval 5)
(setq appt-message-warning-time 15)
(setq appt-display-mode-line t)
(display-time)
(setq appt-display-format 'window)
(setq appt-disp-window-function #'ora-appt-display)
(run-at-time "1 hour" 3600 #'ora-org-agenda-to-appt)
(remove-hook 'org-finalize-agenda-hook #'ora-org-agenda-to-appt)
(add-hook 'org-finalize-agenda-hook #'ora-org-agenda-to-appt)

(defun ora-appt-display (min-to-app new-time msg)
  "our little façade-function for ora-org-popup"
  (ora-org-popup (format "Appointment in %s minute(s)" min-to-app) msg
                 "~/Pictures/Icons/Gnome-appointment-soon.png") )

(defun ora-org-agenda-to-appt ()
  "Erase all reminders and rebuild reminders for today from the agenda"
  (interactive)
  ;; (setq appt-time-msg-list nil)
  (org-agenda-to-appt))


(defun ora-start-process (cmd)
  (start-process
   cmd nil shell-file-name
   shell-command-switch
   (format "nohup 1>/dev/null 2>/dev/null %s" cmd)))

(defun ora-org-popup (title msg &optional icon sound)
  "Show a popup if we're on X, or echo it otherwise; TITLE is the title
           of the message, MSG is the context. Optionally, you can provide an ICON and
           a sound to be played"
  (interactive)
  (if (eq window-system 'x)
      (progn
        (notifications-notify
         :title title
         :body msg
         :app-icon icon
         :urgency 'low)
        (ora-start-process
         (concat "mplayer -really-quiet " sound " 2> /dev/null")))
    ;; text only version
    (message (concat title ": " msg))))

(defun bh/org-agenda-to-appt ()
  (interactive)
  (setq appt-time-msg-list nil)
  (org-agenda-to-appt))

;; Rebuild the reminders everytime the agenda is displayed
(add-hook 'org-finalize-agenda-hook 'bh/org-agenda-to-appt 'append)

;; Activate appointments so we get notifications,
;; but only run this when emacs is idle for 15 seconds
(run-with-idle-timer 15 nil (lambda () (appt-activate t)))

;; If we leave Emacs running overnight - reset the appointments one minute after midnight
(run-at-time "24:01" nil 'bh/org-agenda-to-appt)

 #+END_SRC
** window-snapshots
 #+BEGIN_SRC emacs-lisp
(defvar window-snapshots '())

(defun save-window-snapshot ()
  "Save the current window configuration into `window-snapshots` alist."
  (interactive)
  (let ((key (read-string "Enter a name for the snapshot: ")))
    (setf (alist-get key window-snapshots) (current-window-configuration))
    (message "%s window snapshot saved!" key)))

(defun get-window-snapshot (key)
  "Given a KEY return the saved value in `window-snapshots` alist."
  (let ((value (assoc key window-snapshots)))
    (cdr value)))

(defun restore-window-snapshot ()
  "Restore a window snapshot from the window-snapshots alist."
  (interactive)
  (let* ((snapshot-name (completing-read "Choose snapshot: " (mapcar 'car window-snapshots)))
         (snapshot (get-window-snapshot snapshot-name)))
    (if snapshot
        (set-window-configuration snapshot)
      (message "Snapshot %s not found" snapshot-name))))


 #+END_SRC
** buffer
 #+BEGIN_SRC emacs-lisp
(defun save-buffer-always ()
  "Save the buffer even if it is not modified."
  (interactive)
  (set-buffer-modified-p t)
  (save-buffer))


(defun switch-to-scratch-buffer ()
  "Switch to the `*scratch*' buffer. Create it first if needed."
  (interactive)
  (let ((exists (get-buffer "*scratch*")))
    (switch-to-buffer (get-buffer-create "*scratch*"))
    (when (and (not exists)
               (not (eq major-mode 'fundamental-mode))
               (fboundp 'fundamental-mode))
      (funcall 'fundamental-mode))))

(defun safe-erase-buffer ()
  "Prompt before erasing the content of the file."
  (interactive)
  (if (y-or-n-p (format "Erase content of buffer %s ? " (current-buffer)))
      (erase-buffer)))

(defun copy-whole-buffer-to-clipboard ()
  "Copy entire buffer to clipboard"
  (interactive)
  (clipboard-kill-ring-save (point-min) (point-max)))

(defun kill-all-buffers()
  "Kill all buffers except current one and toolkit (*Messages*, *scratch*). Close other windows."
  (interactive)
  (mapc 'kill-buffer (remove-if
                      (lambda (x)
                        (or
                         (string-equal (buffer-name) (buffer-name x))
                         (string-equal "*Messages*" (buffer-name x))
                         (string-equal "*dashboard*" (buffer-name x))
                         (string-equal "*scratch*" (buffer-name x))))
                      (buffer-list)))
  (delete-other-windows))

 #+END_SRC
** window
 #+BEGIN_SRC emacs-lisp
(defun delete-window-balance ()
  "Delete window and rebalance the remaining ones."
  (interactive)
  (delete-window)
  (balance-windows))
(defun split-window-below-focus ()
  "Split window horizontally and move focus to other window."
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))

(defun split-window-right-focus ()
  "Split window vertically and move focus to other window."
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))



(defun my/toggle-maximize ()
  "Toggle maximization of current window."
  (interactive)
  (let ((register ?2))

    (if (eq (get-register register) nil)
        (progn
          (set-register register (current-window-configuration))
          (delete-other-windows))
      (progn
        (set-window-configuration (get-register register))
        (set-register register nil)))))

 #+END_SRC
** editing
 #+BEGIN_SRC emacs-lisp
(defun copy-line ()
  (interactive)
  (save-excursion
    (back-to-indentation)
    (kill-ring-save
     (point)
     (line-end-position)))
  (message "1 line copied"))


(defun goto-line-show ()
  "Show line numbers temporarily, while prompting for the line number input."
  (interactive)
  (unwind-protect
      (progn
        (linum-mode 1)
        (call-interactively #'goto-line))
    (linum-mode -1)))

 #+END_SRC
** flycheck
 #+BEGIN_SRC emacs-lisp
(defun toggle-flycheck-error-list ()
  "Toggle flycheck's error list window.
If the error list is visible, hide it.  Otherwise, show it."
  (interactive)
  (-if-let (window (flycheck-get-error-list-window))
      (quit-window nil window)
    (flycheck-list-errors)))

(defun goto-flycheck-error-list ()
  "Open and go to the error list buffer."
  (interactive)
  (unless (get-buffer-window (get-buffer flycheck-error-list-buffer))
    (flycheck-list-errors)
    (switch-to-buffer-other-window flycheck-error-list-buffer)))

(defun disable-fylcheck-in-org-src-block ()
  (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
 #+END_SRC
** test-emacs
 #+BEGIN_SRC emacs-lisp
(defun test-emacs ()
  "Test if emacs starts correctly."
  (interactive)
  (if (eq last-command this-command)
      (save-buffers-kill-terminal)
    (require 'async)
    (async-start
     (lambda () (shell-command-to-string
                 "emacs --batch --eval \"
(condition-case e
    (progn
      (load \\\"~/.emacs.d/init.el\\\")
      (message \\\"-OK-\\\"))
  (error
   (message \\\"ERROR!\\\")
   (signal (car e) (cdr e))))\""))
     `(lambda (output)
        (if (string-match "-OK-" output)
            (when ,(called-interactively-p 'any)
              (message "All is well"))
          (switch-to-buffer-other-window "*startup error*")
          (delete-region (point-min) (point-max))
          (insert output)
          (search-backward "ERROR!"))))))

 #+END_SRC

** time
 #+BEGIN_SRC emacs-lisp
(defun my/insert-created-timestamp()
  "Insert a CREATED property using org-expiry.el for TODO entries"
  (org-entry-put nil "CREATED" (format-time-string "<%Y-%m-%d %a %H:%M>"))
  (org-expiry-insert-created)
  (org-back-to-heading)
  (org-end-of-line)
  (insert " "))

 #+END_SRC
** archive
 #+BEGIN_SRC emacs-lisp
(defun org-archive-done-tasks ()
  (interactive)
  (org-map-entries 'org-archive-subtree "/DONE" 'file))

 #+END_SRC
** org-insert-link
 #+BEGIN_SRC emacs-lisp
(defun org-insert-link-with-default-description (file-name)
  (interactive (list (read-file-name "File: ")))
  (org-insert-link file-name file-name (file-name-nondirectory file-name)))

 #+END_SRC
** expansion
 #+BEGIN_SRC emacs-lisp
(defun check-expansion ()
  (save-excursion
    (if (looking-at "\\_>") t
      (backward-char 1)
      (if (looking-at "\\.") t
        (backward-char 1)
        (if (looking-at "->") t nil)))))

(defun do-yas-expand ()
  (let ((yas/fallback-behavior 'return-nil))
    (yas/expand)))
 #+END_SRC
** export-headlines
 #+BEGIN_SRC emacs-lisp
(defun my/org-export-headlines-to-org ()
  "Export all subtrees that are *not* tagged with :noexport: to
separate files.

Subtrees that do not have the :EXPORT_FILE_NAME: property set
are exported to a filename derived from the headline text."
  (interactive)
                                        ;  (save-buffer)
  (let ((modifiedp (buffer-modified-p)))
    (save-excursion
      (goto-char (point-min))
      (goto-char (re-search-forward "^*"))
      (set-mark (line-beginning-position))
      (goto-char (point-max))
      (org-map-entries
       (lambda ()
         (let ((export-file (org-entry-get (point) "EXPORT_FILE_NAME")))
           (unless export-file
             (org-set-property
              "EXPORT_FILE_NAME"
              (replace-regexp-in-string " " "_" (nth 4 (org-heading-components)))))
           (deactivate-mark)
           (org-org-export-to-org nil t)
           (unless export-file (org-delete-property "EXPORT_FILE_NAME"))
           (set-buffer-modified-p modifiedp)))
       "-noexport" 'region-start-level))))

 #+END_SRC
** org-id
 #+BEGIN_SRC emacs-lisp
(defun my/org-add-ids-to-headlines-in-file ()
  "Add CUSTOM_ID properties to all headlines in the
   current file which do not already have one."
  (interactive)
  (org-map-entries (lambda () (my/org-custom-id-get (point) 'create))))

(defun my/org-custom-id-get (&optional pom create prefix)
  "Get the CUSTOM_ID property of the entry at point-or-marker POM.
   If POM is nil, refer to the entry at point. If the entry does
   not have an CUSTOM_ID, the function returns nil. However, when
   CREATE is non nil, create a CUSTOM_ID if none is present
   already. PREFIX will be passed through to `org-id-new'. In any
   case, the CUSTOM_ID of the entry is returned."
  (interactive)
  (org-with-point-at pom
    (let ((id (org-entry-get nil "EXPORT_FILE_NAME")))
      (cond
       ((and id (stringp id) (string-match "\\S-" id))
        id)
       (create
        (setq id (org-id-new (concat prefix "h")))
        (org-entry-put pom "EXPORT_FILENAME" id)
        (org-id-add-location id (buffer-file-name (buffer-base-buffer)))
        id)))))
 #+END_SRC
** nov
 #+BEGIN_SRC emacs-lisp
(defun my-nov-font-setup ()
  (face-remap-add-relative 'variable-pitch :family "Liberation Serif"
                           :height 1.0))
 #+END_SRC
** org-mode-hooks
 #+BEGIN_SRC emacs-lisp
(defun my-org-mode-hooks ()
  (visual-line-mode)
  (turn-on-auto-fill)
  (turn-on-flyspell)
  (outline-minor-mode))
 #+END_SRC
** misc
 #+BEGIN_SRC emacs-lisp
(defun my/trim-non-chrome ()
  (delete-if-not (apply-partially 'string-match "- Google Chrome$")
                 ido-temp-list))

(add-hook 'exwm-manage-finish-hook
          (defun my/exwm-manage-hook ()
            (when (string-match "Google-chrome" exwm-class-name)
                                        ;                (exwm-workspace-move-window 0)
                                        ;                (exwm-layout-hide-mode-line)
              (setq ido-make-buffer-list-hook 'my/trim-non-chrome))))

(add-hook 'exwm-update-title-hook
          (defun my/exwm-title-hook ()
            (when (string-match "Google-chrome" exwm-class-name)
              (exwm-workspace-rename-buffer exwm-title))))

(setq browse-url-chrome-arguments '("--new-window"))


(defun tab-indent-or-complete ()
  (interactive)
  (if (minibufferp)
      (minibuffer-complete)
    (if (or (not yas/minor-mode)
            (null (do-yas-expand)))
        (if (check-expansion)
            (company-complete-common)
          (indent-for-tab-command)))))


(defun isearch-yank-symbol ()
  (interactive)
  (isearch-yank-internal (lambda () (forward-symbol 1) (point))))

 #+END_SRC
** save-hist
 #+BEGIN_SRC emacs-lisp
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring
        last-kbd-macro
        kmacro-ring
        shell-command-history
        Info-history-list
        extended-command-history
        ivy-history
        counsel-M-x-history

        ))


(savehist-mode 1)

 #+END_SRC

** xref
 #+BEGIN_SRC emacs-lisp
(custom-set-variables '(xref-show-xrefs-function #'ivy-xref-show-xrefs))

(defun my-xref-show-pos-in-buf--same-window (func &rest args)
  "Display xref location in the same window. See
   `display-buffer-same-window'."
  (let ((display-buffer-overriding-action '(display-buffer-same-window)))
    (apply func args)))

(advice-add 'xref--show-pos-in-buf
            :around #'my-xref-show-pos-in-buf--same-window)

 #+END_SRC
** counsel-network
Control network manager from Emacs
#+BEGIN_SRC emacs-lisp
(defvar counsel-network-manager-history nil
  "Network manager history.")

(defun counsel-network-manager (&optional initial-input)
  "Connect to wifi network."
  (interactive)
  (shell-command "nmcli device wifi rescan")
  (let ((networks-list (s-split "\n" (shell-command-to-string "nmcli device wifi list"))))
    (ivy-read "Select network" networks-list
              :initial-input initial-input
              :require-match t
              :history counsel-network-manager-history
              :sort nil
              :caller 'counsel-network-manager
              :action (lambda (line)
                        (let ((network (car (s-split " " (s-trim (s-chop-prefix "*" line)) t))))
                          (message "Connecting to \"%s\".." network)
                          (async-shell-command
                           (format "nmcli device wifi connect %s" (shell-quote-argument network))))))))
#+END_SRC

#+results:
: counsel-network-manager

* Activities
** Org
*** org-todo
#+BEGIN_SRC emacs-lisp
;; Keep tasks with dates on the global todo lists
(setq org-agenda-todo-ignore-with-date nil)

;; Keep tasks with deadlines on the global todo lists
(setq org-agenda-todo-ignore-deadlines nil)

;; Keep tasks with scheduled dates on the global todo lists
(setq org-agenda-todo-ignore-scheduled nil)

;; Keep tasks with timestamps on the global todo lists
(setq org-agenda-todo-ignore-timestamp nil)

;; Remove completed deadline tasks from the agenda view
(setq org-agenda-skip-deadline-if-done nil)

;; Remove completed scheduled tasks from the agenda view
(setq org-agenda-skip-scheduled-if-done nil)

;; Remove completed items from search results
(setq org-agenda-skip-timestamp-if-done nil)

;; Skip scheduled items if they are repeated beyond the current deadline.
(setq org-agenda-skip-scheduled-if-deadline-is-shown  (quote repeated-after-deadline))

(setq org-agenda-include-diary nil)
(setq org-agenda-insert-diary-extract-time t)

(setq org-default-notes-file "~/org/notes/inbox.org")

;; =TODO= state keywords and colour settings:
(setq org-todo-keywords
      (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
              (sequence "WAITING(w)" "HOLD(h)" "DELEGATE(D)" "|" "CANCELLED(c@/!)" "MEETING" "SCHEDULED")
              (sequence "ACTIVE(a)" "|" "DISABLED(i)")
              )))

;; ;; TODO Other todo keywords doesn't have appropriate faces yet. They should
;; ;; have faces similar to spacemacs defaults.
(setq org-todo-keyword-faces
      (quote (("TODO" :foreground "red" :weight bold)
              ("NEXT" :foreground "#007cee" :weight bold)
              ("DONE" :foreground "forest green" :weight bold)
              ("WAITING" :foreground "orange" :weight bold)
              ("DELEGATE" :foreground "purple" :weight bold)
              ("HOLD" :foreground "magenta" :weight bold)
              ("CANCELLED" :foreground "red" :weight bold)
              ("MEETING" :foreground "forest green" :weight bold)
              ("SCHEDULED" :foreground "forest green" :weight bold))))

(setq org-use-fast-todo-selection t)

;; This cycles through the todo states but skips setting timestamps and
;; entering notes which is very convenient when all you want to do is fix
;; up the status of an entry.
(setq org-treat-S-cursor-todo-selection-as-state-change nil)

(setq org-todo-state-tags-triggers
      (quote (("CANCELLED" ("CANCELLED" . t))
              ("WAITING" ("WAITING" . t))
              ("HOLD" ("WAITING") ("HOLD" . t))
              (done ("WAITING") ("HOLD"))
              ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
              ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
              ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))

#+END_SRC
*** org-refile
#+BEGIN_SRC emacs-lisp
(setq org-refile-targets (quote ((nil :maxlevel . 9)
                                 (org-agenda-files :maxlevel . 9)
                                 )))

(setq org-refile-use-outline-path 'file
      org-indent-indentation-per-level nil
      org-outline-path-complete-in-steps nil)


;; Allow refile to create parent tasks with confirmation
(setq org-refile-allow-creating-parent-nodes (quote confirm))

(setq org-refile-target-verify-function 'bh/verify-refile-target)

#+END_SRC
*** org-clock
#+BEGIN_SRC emacs-lisp
(setq org-agenda-clock-consistency-checks
      (quote (:max-duration "4:00"
                            :min-duration 0
                            :max-gap 0
                            :gap-ok-around ("4:00"))))

;; Agenda clock report parameters
(setq org-agenda-clockreport-parameter-plist
      (quote (:link t :maxlevel 5 :fileskip0 t :compact t :narrow 80)))

;; Show lot of clocking history so it's easy to pick items off the C-F11 list
(setq org-clock-history-length 23)
;; Resume clocking task on clock-in if the clock is open
(setq org-clock-in-resume t)
;; Change tasks to NEXT when clocking in
(setq org-clock-in-switch-to-state 'bh/clock-in-to-next)
;; Separate drawers for clocking and logs
(setq org-drawers (quote ("PROPERTIES" "LOGBOOK")))
;; Save clock data and state changes and notes in the LOGBOOK drawer
(setq org-clock-into-drawer t)

(setq org-log-into-drawer t)
;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
(setq org-clock-out-remove-zero-time-clocks t)
;; Clock out when moving task to a done state
(setq org-clock-out-when-done t)
;; Save the running clock and all clock history when exiting Emacs, load it on startup
(setq org-clock-persist t)
;; Do not prompt to resume an active clock
(setq org-clock-persist-query-resume nil)
;; Enable auto clock resolution for finding open clocks
                                        ;(setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
(setq org-clock-auto-clock-resolution nil)
;; Include current clocking task in clock reports
(setq org-clock-report-include-clocking-task t)
;; Resolve open clocks if the user is idle for more than 10 minutes.
(setq org-clock-idle-time 10)
;;
;; Resume clocking task when emacs is restarted
(org-clock-persistence-insinuate)

(setq bh/keep-clock-running nil)


(setq org-time-stamp-rounding-minutes (quote (1 1)))
;; ;; Sometimes I change tasks I'm clocking quickly - this removes clocked
;; ;; tasks with 0:00 duration
;; (setq org-clock-out-remove-zero-time-clocks t)

;; Set default column view headings: Task Effort Clock_Summary
(setq org-columns-default-format
      "%1PRIORITY %50ITEM %13AREA %10DEADLINE %50OUTCOME %10Effort(Effort){:} %10CLOCKSUM")
;; global Effort estimate values
;; global STYLE property values for completion
(setq org-global-properties (quote (("Effort_ALL" . "0:15 0:30 0:45 1:00 2:00 3:00 4:00 5:00 6:00 0:00")
                                    ("STYLE_ALL" . "habit"))))

#+END_SRC
*** org-tags
#+BEGIN_SRC emacs-lisp
(setq org-fast-tag-selection-include-todo t)

(setq org-tag-alist (quote ((:startgroup)
                            (:endgroup)
                            ("WAITING" . ?w)
                            ("HOLD" . ?h)
                            ("NOTE" . ?n)
                            ("CANCELLED" . ?c)
                            ("FLAGGED" . ??))))

(setq org-agenda-hide-tags-regexp "noexport\\|HOLD\\|REFILE\\|ARCHIVE\\|NOW\\|ignore\\|WAITING\\|nobrain\\|connect\\|clarify\\|capture\\|ATTACH")

;; Allow setting single tags without the menu
(setq org-fast-tag-selection-single-key (quote expert))

#+END_SRC
*** org-expiry
#+BEGIN_SRC emacs-lisp
(require 'org-expiry)

(setq org-expiry-inactive-timestamps t)
(org-expiry-insinuate)

(setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)

#+END_SRC
*** org-babel
#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil
      org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-src-preserve-indentation t
      org-src-window-setup 'current-window)

(setq org-modules '(org-habit
                    org-timer
                    org-collector))

(org-babel-do-load-languages
 (quote org-babel-load-languages)
 (quote ((emacs-lisp . t)
         (dot . t)
         (ditaa . t)
         (python . t)
         (gnuplot . t)
         (shell . t)
         (ledger . t)
         (org . t)
         (plantuml . t)
         (latex . t))))

(defadvice org-babel-execute-src-block (around load-language nil activate)
  "Load language if needed"
  (let ((language (org-element-property :language (org-element-at-point))))
    (unless (cdr (assoc (intern language) org-babel-load-languages))
      (add-to-list 'org-babel-load-languages (cons (intern language) t))
      (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
    ad-do-it))



(defun bh/display-inline-images ()
  (condition-case nil
      (org-display-inline-images)
    (error nil)))

(add-hook 'org-babel-after-execute-hook 'bh/display-inline-images 'append)



(setq org-confirm-babel-evaluate nil)

(setq org-babel-results-keyword "results")

(setq org-ditaa-jar-path "~/.emacs.d/ditaa0_9/ditaa0_9.jar")


#+END_SRC
*** org-habit
#+BEGIN_SRC emacs-lisp
(setq org-habit-show-habits-only-for-today t)
(setq org-agenda-tags-column -100
      org-habit-graph-column 45
      org-habit-preceding-days 28
      org-agenda-start-with-log-mode nil)

(setq org-habit-show-habits nil)

#+END_SRC
*** org-directory
 #+BEGIN_SRC emacs-lisp
(setq org-directory "~/org/agenda/")
(setq org-file-inbox (concat org-directory "inbox.org"))
(setq org-file-journal (concat org-directory "/archive/journal/journal.org"))
(setq org-file-reference (concat org-directory "reference.org"))
(setq org-file-calendar (concat org-directory "calendar.org"))
 #+END_SRC
*** org-agenda
 #+BEGIN_SRC emacs-lisp
(require 'org-agenda)

(setq org-agenda-files (apply 'append
                              (mapcar
                               (lambda (directory)
                                 (directory-files-recursively
                                  directory org-agenda-file-regexp))
                               '("~/org/agenda" "~/org/projects" "~/.personal.d/" "~/.emacs.d/"))))

(setq org-show-entry-below (quote ((default))))

;; Tags with fast selection keys
;; Disable the default org-mode stuck projects agenda view
(setq org-stuck-projects (quote ("" nil nil "")))

;; Limit restriction lock highlighting to the headline only
(setq org-agenda-restriction-lock-highlight-subtree nil)

;; Always hilight the current agenda line
(add-hook 'org-agenda-mode-hook
          '(lambda () (hl-line-mode 1))
          'append)



(setq org-agenda-auto-exclude-function 'bh/org-auto-exclude-function)

;; Agenda log mode items to display (closed and state changes by default)
(setq org-agenda-log-mode-items (quote (closed clock state)))

;; For tag searches ignore tasks with scheduled and deadline dates
(setq org-agenda-tags-todo-honor-ignore-options t)

(setq org-agenda-timegrid-use-ampm t)

(setq org-agenda-inhibit-startup t)

(setq org-agenda-span 'day)

(setq org-agenda-follow-indirect t)

(defvar org-timeline-files nil
  "The files to be included in `org-timeline-all-files'. Follows
        the same rules as `org-agenda-files'")

(setq org-timeline-files '("~/org/agenda/archive"))


;; Overwrite the current window with the agenda
(setq org-agenda-window-setup 'current-window)

;; Do not dim blocked tasks
(setq org-agenda-dim-blocked-tasks nil)

;; Compact the block agenda view
(setq org-agenda-compact-blocks nil)

;; Agenda clock report parameters
(setq org-agenda-clockreport-parameter-plist
      (quote (:link t :maxlevel 5 :fileskip0 t :compact nil :narrow 80)))

;; Agenda log mode items to display (closed and state changes by default)
(setq org-agenda-log-mode-items (quote (closed state clock)))

;; Keep tasks with dates on the global todo lists
(setq org-agenda-todo-ignore-with-date nil)

;; Keep tasks with deadlines on the global todo lists
(setq org-agenda-todo-ignore-deadlines nil)

;; Keep tasks with scheduled dates on the global todo lists
(setq org-agenda-todo-ignore-scheduled nil)

;; Keep tasks with timestamps on the global todo lists
(setq org-agenda-todo-ignore-timestamp nil)

;; Remove completed deadline tasks from the agenda view
(setq org-agenda-skip-deadline-if-done t)

;; Remove completed scheduled tasks from the agenda view
(setq org-agenda-skip-scheduled-if-done t)

;; Remove completed items from search results
(setq org-agenda-skip-timestamp-if-done t)

;; Include agenda archive files when searching for things
(setq org-agenda-text-search-extra-files (quote (agenda-archives)))

;; Show all future entries for repeating tasks
(setq org-agenda-repeating-timestamp-show-all t)

;; Show all agenda dates - even if they are empty
(setq org-agenda-show-all-dates t)

;; Start the weekly agenda on Monday
(setq org-agenda-start-on-weekday 1)

;; Use sticky agenda's so they persist
;;(setq org-agenda-sticky t)

;; Custom agenda command definitions
(setq org-agenda-custom-commands
      (quote (("N" "Notes" tags "NOTE"
               ((org-agenda-overriding-header "Notes")
                (org-tags-match-list-sublevels t)))
              ("h" "Habits" tags-todo "STYLE=\"habit\""
               ((org-agenda-overriding-header "Habits")
                (org-agenda-sorting-strategy
                 '(todo-state-down effort-up category-keep))))
              (" " "Agenda"
               ((agenda "" nil)
                (tags "REFILE"
                      ((org-agenda-overriding-header "Tasks to Refile")
                       (org-tags-match-list-sublevels nil)))
                (tags-todo "-CANCELLED/!"
                           ((org-agenda-overriding-header "Stuck Projects")
                            (org-agenda-skip-function 'bh/skip-non-stuck-projects)
                            (org-agenda-sorting-strategy
                             '(category-keep))))
                (tags-todo "-HOLD-CANCELLED/!"
                           ((org-agenda-overriding-header "Projects")
                            (org-agenda-skip-function 'bh/skip-non-projects)
                            (org-tags-match-list-sublevels 'indented)
                            (org-agenda-sorting-strategy
                             '(category-keep))))
                (tags-todo "-CANCELLED/!NEXT"
                           ((org-agenda-overriding-header (concat "Next Tasks"
                                                                  (if bh/hide-scheduled-and-waiting-next-tasks
                                                                      ""
                                                                    " (including WAITING and SCHEDULED tasks)")))
                            (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)
                            (org-tags-match-list-sublevels t)
                            (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-sorting-strategy
                             '(todo-state-down effort-up category-keep))))
                (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                           ((org-agenda-overriding-header (concat "Subtasks"
                                                                  (if bh/hide-scheduled-and-waiting-next-tasks
                                                                      ""
                                                                    " (including WAITING and SCHEDULED tasks)")))
                            (org-agenda-skip-function 'bh/skip-non-project-tasks)
                            (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-sorting-strategy
                             '(category-keep))))
                (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!"
                           ((org-agenda-overriding-header (concat "Actions"
                                                                  (if bh/hide-scheduled-and-waiting-next-tasks
                                                                      ""
                                                                    " (including WAITING and SCHEDULED tasks)")))
                            (org-agenda-skip-function 'bh/skip-project-tasks)
                            (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-with-date bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-sorting-strategy
                             '(category-keep))))
                (tags-todo "-CANCELLED+WAITING|HOLD/!"
                           ((org-agenda-overriding-header (concat "Waiting and Postponed Tasks"
                                                                  (if bh/hide-scheduled-and-waiting-next-tasks
                                                                      ""
                                                                    " (including WAITING and SCHEDULED tasks)")))
                            (org-agenda-skip-function 'bh/skip-non-tasks)
                            (org-tags-match-list-sublevels nil)
                            (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                            (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks)))

                )
               nil))))
;; Limit restriction lock highlighting to the headline only
(setq org-agenda-restriction-lock-highlight-subtree nil)


;; Sorting order for tasks on the agenda
(setq org-agenda-sorting-strategy
      (quote ((agenda habit-down time-up user-defined-up effort-up category-keep)
              (todo category-up effort-up)
              (tags category-up effort-up)
              (search category-up))))

;; Enable display of the time grid so we can see the marker for the current time
;;(setq org-agenda-time-grid (quote ((daily today remove-match)
;;                                   #("----------------" 0 16 (org-heading t))
;;                                   (0900 1100 1300 1500 1700))))

;; Display tags farther right
(setq org-agenda-tags-column -102)

;;
;; Agenda sorting functions
;;
(setq org-agenda-cmp-user-defined 'bh/agenda-sort)

 #+END_SRC
*** org-archive
#+BEGIN_SRC emacs-lisp
(setq org-archive-mark-done nil)

(setq org-archive-location "~/org/agenda/archive/%s_archive::/datetree/* Archived Tasks")

#+END_SRC
*** bh functions
#+BEGIN_SRC emacs-lisp
(defmacro bh/agenda-sort-test (fn a b)
  "Test for agenda sort"
  `(cond
                                        ; if both match leave them unsorted
    ((and (apply ,fn (list ,a))
          (apply ,fn (list ,b)))
     (setq result nil))
                                        ; if a matches put a first
    ((apply ,fn (list ,a))
     (setq result -1))
                                        ; otherwise if b matches put b first
    ((apply ,fn (list ,b))
     (setq result 1))
                                        ; if none match leave them unsorted
    (t nil)))

(defmacro bh/agenda-sort-test-num (fn compfn a b)
  `(cond
    ((apply ,fn (list ,a))
     (setq num-a (string-to-number (match-string 1 ,a)))
     (if (apply ,fn (list ,b))
         (progn
           (setq num-b (string-to-number (match-string 1 ,b)))
           (setq result (if (apply ,compfn (list num-a num-b))
                            -1
                          1)))
       (setq result -1)))
    ((apply ,fn (list ,b))
     (setq result 1))
    (t nil)))

(defun bh/agenda-sort (a b)
  "Sorting strategy for agenda items.
Late deadlines first, then scheduled, then non-late deadlines"
  (let (result num-a num-b)
    (cond
     ;; time specific items are already sorted first by org-agenda-sorting-strategy

     ;; non-deadline and non-scheduled items next
     ((bh/agenda-sort-test 'bh/is-not-scheduled-or-deadline a b))

     ;; deadlines for today next
     ((bh/agenda-sort-test 'bh/is-due-deadline a b))

     ;; late deadlines next
     ((bh/agenda-sort-test-num 'bh/is-late-deadline '> a b))

     ;; scheduled items for today next
     ((bh/agenda-sort-test 'bh/is-scheduled-today a b))

     ;; late scheduled items next
     ((bh/agenda-sort-test-num 'bh/is-scheduled-late '> a b))

     ;; pending deadlines last
     ((bh/agenda-sort-test-num 'bh/is-pending-deadline '< a b))

     ;; finally default to unsorted
     (t (setq result nil)))
    result))

(defun bh/is-project-p ()
  "Any task with a todo keyword subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task has-subtask))))

(defun bh/is-project-subtree-p ()
  "Any task with a todo keyword that is in a project subtree.
Callers of this function already widen the buffer view."
  (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                              (point))))
    (save-excursion
      (bh/find-project-task)
      (if (equal (point) task)
          nil
        t))))

(defun bh/is-task-p ()
  "Any task with a todo keyword and no subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task (not has-subtask)))))

(defun bh/is-subproject-p ()
  "Any task which is a subtask of another project"
  (let ((is-subproject)
        (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
    (save-excursion
      (while (and (not is-subproject) (org-up-heading-safe))
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq is-subproject t))))
    (and is-a-task is-subproject)))

(defun bh/list-sublevels-for-projects-indented ()
  "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
  This is normally used by skipping functions where this variable is already local to the agenda."
  (if (marker-buffer org-agenda-restrict-begin)
      (setq org-tags-match-list-sublevels 'indented)
    (setq org-tags-match-list-sublevels nil))
  nil)

(defun bh/list-sublevels-for-projects ()
  "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
  This is normally used by skipping functions where this variable is already local to the agenda."
  (if (marker-buffer org-agenda-restrict-begin)
      (setq org-tags-match-list-sublevels t)
    (setq org-tags-match-list-sublevels nil))
  nil)

(defvar bh/hide-scheduled-and-waiting-next-tasks t)

(defun bh/toggle-next-task-display ()
  (interactive)
  (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
  (when  (equal major-mode 'org-agenda-mode)
    (org-agenda-redo))
  (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

(defun bh/skip-stuck-projects ()
  "Skip trees that are not stuck projects"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (bh/is-project-p)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (has-next ))
            (save-excursion
              (forward-line 1)
              (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                (unless (member "WAITING" (org-get-tags))
                  (setq has-next t))))
            (if has-next
                nil
              next-headline)) ; a stuck project, has subtasks but no next task
        nil))))

(defun bh/skip-non-stuck-projects ()
  "Skip trees that are not stuck projects"
  ;; (bh/list-sublevels-for-projects-indented)
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (bh/is-project-p)
          (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                 (has-next ))
            (save-excursion
              (forward-line 1)
              (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                (unless (member "WAITING" (org-get-tags))
                  (setq has-next t))))
            (if has-next
                next-headline
              nil)) ; a stuck project, has subtasks but no next task
        next-headline))))

(defun bh/skip-non-projects ()
  "Skip trees that are not projects"
  ;; (bh/list-sublevels-for-projects-indented)
  (if (save-excursion (bh/skip-non-stuck-projects))
      (save-restriction
        (widen)
        (let ((subtree-end (save-excursion (org-end-of-subtree t))))
          (cond
           ((bh/is-project-p)
            nil)
           ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
            nil)
           (t
            subtree-end))))
    (save-excursion (org-end-of-subtree t))))

(defun bh/skip-non-tasks ()
  "Show non-project tasks.
Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((bh/is-task-p)
        nil)
       (t
        next-headline)))))

(defun bh/skip-project-trees-and-habits ()
  "Skip trees that are projects"
  (save-restriction
    (widen)
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-projects-and-habits-and-single-tasks ()
  "Skip trees that are projects, tasks that are habits, single non-project tasks"
  (save-restriction
    (widen)
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((org-is-habit-p)
        next-headline)
       ((and bh/hide-scheduled-and-waiting-next-tasks
             (member "WAITING" (org-get-tags)))
        next-headline)
       ((bh/is-project-p)
        next-headline)
       ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
        next-headline)
       (t
        nil)))))

(defun bh/skip-project-tasks-maybe ()
  "Show tasks related to the current restriction.
When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
When not restricted, skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
           (next-headline (save-excursion (or (outline-next-heading) (point-max))))
           (limit-to-project (marker-buffer org-agenda-restrict-begin)))
      (cond
       ((bh/is-project-p)
        next-headline)
       ((org-is-habit-p)
        subtree-end)
       ((and (not limit-to-project)
             (bh/is-project-subtree-p))
        subtree-end)
       ((and limit-to-project
             (bh/is-project-subtree-p)
             (member (org-get-todo-state) (list "NEXT")))
        subtree-end)
       (t
        nil)))))

(defun bh/skip-project-tasks ()
  "Show non-project tasks.
Skip project and sub-project tasks, habits, and project related tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       ((bh/is-project-subtree-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-non-project-tasks ()
  "Show project tasks.
Skip project and sub-project tasks, habits, and loose non-project tasks."
  (save-restriction
    (widen)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
           (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (cond
       ((bh/is-project-p)
        next-headline)
       ((org-is-habit-p)
        subtree-end)
       ((and (bh/is-project-subtree-p)
             (member (org-get-todo-state) (list "NEXT")))
        subtree-end)
       ((not (bh/is-project-subtree-p))
        subtree-end)
       (t
        nil)))))

(defun bh/skip-projects-and-habits ()
  "Skip trees that are projects and tasks that are habits"
  (save-restriction
    (widen)
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (cond
       ((bh/is-project-p)
        subtree-end)
       ((org-is-habit-p)
        subtree-end)
       (t
        nil)))))

(defun bh/skip-non-subprojects ()
  "Skip trees that are not projects"
  (let ((next-headline (save-excursion (outline-next-heading))))
    (if (bh/is-subproject-p)
        nil
      next-headline)))

;; Show 20 minute clocking gaps. Hit "v c" in the agenda view
(setq org-agenda-clock-consistency-checks
      '(:max-duration "4:00"
                      :min-duration 0
                      :max-gap 30
                      :gap-ok-around ("4:00" "11:00" "19:00" "20:00" "21:00")))

(defun bh/widen ()
  (interactive)
  (if (equal major-mode 'org-agenda-mode)
      (progn
        (org-agenda-remove-restriction-lock)
        (when org-agenda-sticky
          (org-agenda-redo)))
    (widen)))

(add-hook 'org-agenda-mode-hook
          '(lambda () (org-defkey org-agenda-mode-map "W" (lambda () (interactive) (setq bh/hide-scheduled-and-waiting-next-tasks t) (bh/widen))))
          'append)

(defun bh/skip-non-archivable-tasks ()
  "Skip trees that are not available for archiving."
  (save-restriction
    (widen)
    ;; Consider only tasks with done todo headings as archivable candidates
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
          (subtree-end (save-excursion (org-end-of-subtree t))))
      (if (member (org-get-todo-state) org-todo-keywords-1)
          (if (member (org-get-todo-state) org-done-keywords)
              (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
                     (a-month-ago (* 60 60 24 (+ daynr 1)))
                     (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                     (this-month (format-time-string "%Y-%m-" (current-time)))
                     (subtree-is-current (save-excursion
                                           (forward-line 1)
                                           (and (< (point) subtree-end)
                                                (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                (if subtree-is-current
                    subtree-end ; Has a date in this month or last month, skip it
                  nil))  ; available to archive
            (or subtree-end (point-max)))
        next-headline))))

(defun bh/is-not-scheduled-or-deadline (date-str)
  (and (not (bh/is-deadline date-str))
       (not (bh/is-scheduled date-str))))

(defun bh/is-due-deadline (date-str)
  (string-match "Deadline:" date-str))

(defun bh/is-late-deadline (date-str)
  (string-match "\\([0-9]*\\) d\. ago:" date-str))

(defun bh/is-pending-deadline (date-str)
  (string-match "In \\([^-]*\\)d\.:" date-str))

(defun bh/is-deadline (date-str)
  (or (bh/is-due-deadline date-str)
      (bh/is-late-deadline date-str)
      (bh/is-pending-deadline date-str)))

(defun bh/is-scheduled (date-str)
  (or (bh/is-scheduled-today date-str)
      (bh/is-scheduled-late date-str)))

(defun bh/is-scheduled-today (date-str)
  (string-match "Scheduled:" date-str))

(defun bh/is-scheduled-late (date-str)
  (string-match "Sched\.\\(.*\\)x:" date-str))

(defun bh/find-project-task ()
  "Move point to the parent (project) task if any"
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
      (while (org-up-heading-safe)
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq parent-task (point))))
      (goto-char parent-task)
      parent-task)))

(defun bh/verify-refile-target ()
  "Exclude todo keywords with a done state from refile targets"
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))

(defun bh/clock-in-to-next (kw)
  "Switch a task from TODO to NEXT when clocking in.
                   Skips capture tasks, projects, and subprojects.
                   Switch projects and subprojects from NEXT back to TODO"
  (when (not (and (boundp 'org-capture-mode) org-capture-mode))
    (cond
     ((and (member (org-get-todo-state) (list "TODO"))
           (bh/is-task-p))
      "NEXT")
     ((and (member (org-get-todo-state) (list "NEXT"))
           (bh/is-project-p))
      "TODO"))))
#+END_SRC
*** capture templates
 #+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      (quote (("t" "Task" entry (file org-file-inbox) (file "~/.emacs.d/templates/todo.tmplt") :clock-in t :clock-resume t)
              ("n" "Note" entry (file org-file-inbox) (file "~/.emacs.d/templates/note.tmplt")  :clock-in t :clock-resume t)
              ("e" "Event" entry (file+headline org-file-calendar "Calendar") (file "~/.emacs.d/templates/event.tmplt")  :clock-in t :clock-resume t))))

 #+END_SRC
** GTD
*** org-refile-directly
  #+BEGIN_SRC emacs-lisp
(setq org-refile-use-outline-path 'file
      org-outline-path-complete-in-steps nil)

(defun org-subtree-region ()
  "Return a list of the start and end of a subtree."
  (save-excursion
    (list (progn (org-back-to-heading) (point))
          (progn (org-end-of-subtree)  (point)))))

(defvar org-refile-directly-show-after nil
  "When refiling directly (using the `org-refile-directly'
 function), show the destination buffer afterwards if this is set
 to `t', otherwise, just do everything in the background.")

(defun org-refile-directly (file-dest)
  "Move the current subtree to the end of FILE-DEST.
 If SHOW-AFTER is non-nil, show the destination window,
 otherwise, this destination buffer is not shown."
  (interactive "fDestination: ")

  (defun dump-it (file contents)
    (find-file-other-window file-dest)
    (goto-char (point-max))
    (insert "\n" contents))

  (save-excursion
    (let* ((region (org-subtree-region))
           (contents (buffer-substring (first region) (second region))))
      (apply 'kill-region region)
      (if org-refile-directly-show-after
          (save-current-buffer (dump-it file-dest contents))
        (save-window-excursion (dump-it file-dest contents))))))
  #+END_SRC

*** org-boxes-workflow
  #+BEGIN_SRC emacs-lisp
(defun org-boxes-workflow ()
  "Load the default tasks file and start our hydra on the first task shown."
  (interactive)
  (find-file org-default-inbox-file)
  (goto-char (point-min))
  (org-next-visible-heading 2)
  (hydra-org-refiler/body))

  #+END_SRC
*** org-refile-to
  #+BEGIN_SRC emacs-lisp
(defun org-refile-to-incubate ()
  "Refile (move) the current Org subtree to `org-default-incubate-file'."
  (interactive)
  (org-todo "HOLD")
  (org-refile-directly org-default-incubate-file)
  (kill-line))

(defun org-refile-to-waiting ()
  "Refile (move) the current Org subtree to `org-default-incubate-file'."
  (interactive)
  (org-todo "WAITING")

  (org-refile-directly org-default-waiting-file)
  (kill-line))

(defun org-refile-to-calendar ()
  "Refile (move) the current Org subtree to `org-default-incubate-file'."
  (interactive)
  (org-todo "TODO")

  (org-refile-directly org-default-calendar-file)
  (kill-line))

(defun org-refile-to-task ()
  "Refile (move) the current Org subtree to `org-default-tasks-file'."
  (interactive)
  (org-todo "TODO")

  (org-refile-directly org-default-tasks-file)
  (kill-line))

(defun org-refile-to-projects-dir ()
  "Move the current subtree to a file in the `projects' directory."
  (interactive)
  (org-refile-subtree-to-file org-default-projects-dir))

(defun org-refile-to-technical-dir ()
  "Move the current subtree to a file in the `technical' directory."
  (interactive)
  (org-refile-subtree-to-file org-default-technical-dir))

(defun org-refile-to-personal-dir ()
  "Move the current subtree to a file in the `personal' directory."
  (interactive)
  (org-refile-subtree-to-file org-default-personal-dir))

(defun org-refile-to-zettelkasten-dir ()
  "Move the current subtree to a file in the `zettelkasten' directory."
  (interactive)
  (org-refile-notes-to-file org-default-zettelkasten-dir))

(defun org-refile-to-zettelkasten-dir-2 ()
  "Move the current subtree to a file in the `zettelkasten' directory."
  (interactive)
  (org-refile-subtree-to-file org-default-zettelkasten-dir))


(defun org-refile-to-headline (file headline)
  (let ((pos (save-excursion
               (find-file file)
               (org-find-exact-headline-in-buffer headline))))
    (org-refile nil nil (list headline file nil pos))
    (switch-to-buffer (current-buffer))))

(defun org-refile-to-process ()
  "Refile (move) the current Org subtree to `org-default-incubate-file'."
  (interactive)

  (org-refile-directly "~/org/notes/process.org")
  (kill-line)
  )

(defun org-refile-to-cross-ref ()
  "Refile (move) the current Org subtree to `org-default-incubate-file'."
  (interactive)

  (org-refile-directly "~/org/notes/cross-reference.org")
  (kill-line))
  #+END_SRC

*** note-to
  #+BEGIN_SRC emacs-lisp
(defun note-to-websites ()
  (interactive)
  (org-refile-to-headline org-file-reference "Websites"))

(defun note-to-images ()
  (interactive)
  (org-refile-to-headline org-file-reference "Images"))

(defun note-to-videos ()
  (interactive)
  (org-refile-to-headline org-file-reference "Videos"))

(defun note-to-audio ()
  (interactive)
  (org-refile-to-headline org-file-reference "Audio"))

(defun note-to-documents ()
  (interactive)
  (org-refile-to-headline org-file-reference "Documents"))

(defun refile-to-tickler ()
  (interactive)
  (org-refile-to-headline org-file-calendar "Tickler"))

(defun refile-to-calendar ()
  (interactive)
  (org-refile-to-headline org-file-calendar "Calendar"))

(defun org-refile-to-delegate ()
  "Refile (move) the current Org subtree to `org-default-incubate-file'."
  (interactive)
  (org-todo "DELEGATE")

  (org-refile-directly org-default-delegate-file)
  (kill-line))

  #+END_SRC
*** org-refile-subtree-to-file
  #+BEGIN_SRC emacs-lisp
(defun org-refile-subtree-to-file (dir)
  "Archive the org-mode subtree and create an entry in the
 directory folder specified by DIR. It attempts to move as many of
 the subtree's properties and other features to the new file."
  (interactive "DDestination: ")
  (let* ((props      (org-subtree-metadata))
         (head       (plist-get props :header))
         (body       (plist-get props :body))
         (tags       (plist-get props :tags))
         (properties (plist-get props :properties))
         (area       (plist-get props :region))
         (filename   (org-filename-from-title head))
         (filepath   (format "%s/%s.org" dir filename)))
    (apply #'delete-region area)
    (org-create-org-file filepath head body tags properties)))

(defun org-create-org-file (filepath header body tags properties)
  "Create a new Org file by FILEPATH. The contents of the file is
 pre-populated with the HEADER, BODY and any associated TAGS."
  (find-file-other-window filepath)
  (org-set-file-property "TITLE" header t)
  (org-set-file-property "CATEGORY" "project")
  (when tags
    (org-set-file-property "FILETAGS" (s-join " " tags)))

  ;;  Insert any drawer properties as #+PROPERTY entries:
  (when properties
    (goto-char (point-min))
    (or (re-search-forward "^\s*_\s$" nil t) (point-max))
    (--map (insert (format "#+PROPERTY: %s %s\n" (first it) (second it))) properties))

  ;; My auto-insert often adds an initial headline for a subtree, and in this
  ;; case, I don't want that... Yeah, this isn't really globally applicable,
  ;; but it shouldn't cause a problem for others.
  (when (re-search-forward "^\\* [0-9]$" nil t)
    (replace-match ""))

  (delete-blank-lines)
  (goto-char (point-max))
  (insert "\n")
  (insert "\n")
  (insert "* TODO " header)
  (insert "\n")
  (insert body))
  #+END_SRC
*** org-refile-notes-to-file
  #+BEGIN_SRC emacs-lisp
(defun org-refile-notes-to-file (dir)
  "Archive the org-mode subtree and create an entry in the
  directory folder specified by DIR. It attempts to move as many of
  the subtree's properties and other features to the new file."
  (interactive "DDestination: ")
  (let* ((props      (org-subtree-metadata))
         (head       (plist-get props :header))
         (body       (plist-get props :body))
         (tags       (plist-get props :tags))
                                        ;          (properties (plist-get props :properties))
         (area       (plist-get props :region))
         (filename   (concat (format-time-string "%Y-%m-%dT%H.%M.%S")))
         (filepath   (format "%s/%s.org" dir filename)))
    (apply #'delete-region area)
    (org-create-notes-file filepath head body tags)))

(defun org-create-notes-file (filepath header body tags)
  "Create a new Org file by FILEPATH. The contents of the file is
  pre-populated with the HEADER, BODY and any associated TAGS."
  (find-file filepath)
  (org-set-file-property "TITLE" header t)
  (org-set-file-property "DATE" (format-time-string "[%Y-%m-%d %H:%M]"))
  (org-set-file-property "KEYWORDS" (s-join "" tags))
  (goto-char (point-min))
  (when (re-search-forward "REFILE" nil t)
    (replace-match ""))

  (delete-blank-lines)
  (goto-char (point-max))
  (insert "\n\n")
                                        ;   (insert "* " header)
                                        ;   (insert "\n\n")
  (insert body)
  (goto-char (point-min))
  (save-buffer))
  #+END_SRC
*** org-rename-header
  #+BEGIN_SRC emacs-lisp
(defun org-rename-header (label)
  "Rename the current section's header to LABEL, and moves the
  point to the end of the line."
  (interactive (list
                (read-string "Header: "
                             (substring-no-properties (org-get-heading t t t t)))))
  (org-back-to-heading)
  (replace-string (org-get-heading t t t t) label))
  #+END_SRC
*** org-archive-subtree-as-completed
  #+BEGIN_SRC emacs-lisp
(defun org-archive-subtree-as-completed ()
  "Archives the current subtree to today's current journal entry."
  (interactive)
  (ignore-errors
    ;; According to the docs for `org-archive-subtree', the state should be
    ;; automatically marked as DONE, but I don't notice that:
    (when (not (equal "DONE" (org-get-todo-state)))
      (org-todo "DONE")))

  (let* ((org-archive-file (or org-default-completed-file
                               (todays-journal-entry)))
         (org-archive-location (format "%s::" org-archive-file)))
    (org-archive-subtree)))
  #+END_SRC
*** todays-journal-entry
  #+BEGIN_SRC emacs-lisp
(defun todays-journal-entry ()
  "Return the full pathname to the day's journal entry file.
  Granted, this assumes each journal's file entry to be formatted
  with year/month/day, as in `20190104' for January 4th.

  Note: `org-journal-dir' variable must be set to the directory
  where all good journal entries live, e.g. ~/journal."
  (let* ((daily-name   (format-time-string "%Y-%m-%d"))
         (file-name    (concat org-journal-dir daily-name)))
    (expand-file-name file-name)))
  #+END_SRC
*** org-subtree-metadata helpers
  #+BEGIN_SRC emacs-lisp
(defun org-subtree-metadata ()
  "Return a list of key aspects of an org-subtree. Includes the
  following: header text, body contents, list of tags, region list
  of the start and end of the subtree."
  (save-excursion
    ;; Jump to the parent header if not already on a header
    (when (not (org-at-heading-p))
      (org-previous-visible-heading 1))

    (let* ((context (org-element-context))
           (attrs   (second context))
           (props   (org-entry-properties)))

      (list :region     (list (plist-get attrs :begin) (plist-get attrs :end))
            :header     (plist-get attrs :title)
            :tags       (org-get-subtree-tags props)
            :properties (org-get-subtree-properties attrs)
            :body       (org-get-subtree-content attrs)))))

(defun org-get-subtree-tags (&optional props)
  "Given the properties, PROPS, from a call to
  `org-entry-properties', return a list of tags."
  (unless props
    (setq props (org-entry-properties)))
  (let ((tag-label (if org-get-subtree-tags-inherited "ALLTAGS" "TAGS")))
    (-some->> props
              (assoc tag-label)
              cdr
              substring-no-properties
              (s-split ":")
              (--filter (not (equalp "" it))))))

(defvar org-get-subtree-tags-inherited t
  "Returns a subtree's tags, and all tags inherited (from tags
    specified in parents headlines or on the file itself). Defaults
    to true.")

(defun org-get-subtree-properties (attributes)
  "Return a list of tuples of a subtrees properties where the keys are strings."

  (defun symbol-upcase? (sym)
    (let ((case-fold-search nil))
      (string-match-p "^:[A-Z]+$" (symbol-name sym))))

  (defun convert-tuple (tup)
    (let ((key (first tup))
          (val (second tup)))
      (list (substring (symbol-name key) 1) val)))

  (->> attributes
       (-partition 2)                         ; Convert plist to list of tuples
       (--filter (symbol-upcase? (first it))) ; Remove lowercase tuples
       (-map 'convert-tuple)))

(defun org-get-subtree-content (attributes)
  "Return the contents of the current subtree as a string."
  (let ((header-components '(clock diary-sexp drawer headline inlinetask
                                   node-property planning property-drawer section)))

    (goto-char (plist-get attributes :contents-begin))

    ;; Walk down past the properties, etc.
    (while
        (let* ((cntx (org-element-context))
               (elem (first cntx))
               (props (second cntx)))
          (when (member elem header-components)
            (goto-char (plist-get props :end)))))

    ;; At this point, we are at the beginning of what we consider
    ;; the contents of the subtree, so we can return part of the buffer:
    (buffer-substring-no-properties (point) (org-end-of-subtree))))

(defun org-filename-from-title (title)
  "Creates a useful filename based on a header string, TITLE.
  For instance, given the string:    What's all this then?
       This function will return:    whats-all-this-then"
  (let* ((no-letters (rx (one-or-more (not alphanumeric))))
         (init-try (->> title
                        downcase
                        (replace-regexp-in-string "'" "")
                        (replace-regexp-in-string no-letters "-"))))
    (string-trim init-try "-+" "-+")))

(defun org-set-file-property (key value &optional spot)
  "Make sure file contains a top-level, file-wide property.
  KEY is something like `TITLE' or `FILETAGS'. This function makes
  sure that the property contains the contents of VALUE, and if the
  file doesn't have the property, it is inserted at either SPOT, or
  if nil,the top of the file."
  (save-excursion
    (goto-char (point-min))
    (let ((case-fold-search t))
      (if (re-search-forward (format "^#\\+%s:\s*\\(.*\\)" key) nil t)
          (replace-match value nil nil nil 1)

        (cond
         ;; if SPOT is a number, go to it:
         ((numberp spot) (goto-char spot))
         ;; If SPOT is not given, jump to first blank line:
         ((null spot) (progn (goto-char (point-min))
                             (re-search-forward "^\s*$" nil t)))
         (t (goto-char (point-min))))

        (insert (format "#+%s: %s\n" (upcase key) value))))))

  #+END_SRC
** Journal
 #+BEGIN_SRC emacs-lisp
(setq journal-author "Alexander Soto")

;; This is the base folder where all your "books"
;; will be stored.
(setq journal-base-dir "~/org/notes")


;; These are your "books" (folders), add as many as you like.
;; Note: "sub volumes" are acheivable with sub folders.
(setq journal-books
      '("projects"
        "personal"))

;; Functions for journal
(defun get-journal-file-today (book)
  "Return today's filename for a books journal file."
  (interactive (list (completing-read "Book: " journal-books) ))
  (cond

   ((string-match "personal" book)
    (expand-file-name
     (concat journal-base-dir book "/"
             (format-time-string "%Y-%m-%dT%H.%M.%S") ".org.gpg" )))

   ((unless (equal book '("personal"))
      (expand-file-name
       (concat journal-base-dir book "/"
               (format-time-string "%Y-%m-%dT%H.%M.%S") ".org" ))))))

                                        ;  (expand-file-name
                                        ;   (concat journal-base-dir book "/" (format-time-string "%Y%m%d") ".org" )) )



(defun journal-today ()
  "Load todays journal entry for book"
  (interactive)
  (auto-insert-mode)
  (find-file (call-interactively 'get-journal-file-today)) )

(defun journal-entry-date ()
  "Inserts the journal heading based on the file's name."
  (when (string-match
         "\\(20[0-9][0-9]\\)\\([0-9][0-9]\\)\\([0-9][0-9]\\)\\(.org\\)"
         (buffer-name))
    (let ((year  (string-to-number (match-string 2 (buffer-name))))
          (month (string-to-number (match-string 3 (buffer-name))))
          (day   (string-to-number (match-string 4 (buffer-name))))
          (datim nil))
      (setq datim (encode-time 0 0 0 day month year))
      (format-time-string "%Y-%m-%d (%A)" datim))))

;; Auto-insert journal header

(eval-after-load 'autoinsert
  '(define-auto-insert
     '("\\(20[0-9][0-9]\\)\\(-\\)\\([0-9][0-9]\\)\\(-\\)\\([0-9][0-9]\\)\\(-\\)\\([0-9][0-9][0-9][0-9][0-9][0-9]\\)\\(.*\\)" . "Journal Header")
     '("Short description: "
       "#+TITLE: "
       (read-string "Title: ") \n
       "#+DATE: " (format-time-string "[%Y-%m-%d %H:%M]") \n
       "#+KEYWORDS: "
       (read-string "Keyword: ") \n \n

       > _ \n \n \n \n \n
       "
---
,*Related:*


---
,*References:*
"

       )))

 #+END_SRC
* Keybindings
#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "C-x b") 'ivy-switch-buffer-non-exwm)
(define-key org-agenda-mode-map (kbd "x") 'org-agenda-exit)
#+END_SRC
** unbound keys
 #+BEGIN_SRC emacs-lisp
 (define-key winner-mode-map (kbd "C-c <left>") nil)
 (define-key winner-mode-map (kbd "C-c <right>") nil)
 (define-key global-map (kbd "C-c <tab>") nil)
 (define-key yas-minor-mode-map (kbd "C-c &") nil)
 (define-key global-map (kbd "C-c ,") nil)
 (define-key global-map (kbd "C-c C-j") nil)
 (define-key org-mode-map (kbd "<tab>") nil)
 #+END_SRC
* Org-Babel Load Files
#+BEGIN_SRC emacs-lisp
(org-babel-load-file "~/.personal.d/encryption.org")
#+END_SRC
